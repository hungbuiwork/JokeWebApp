(self.webpackChunkat_alternative_interaction_solution=self.webpackChunkat_alternative_interaction_solution||[]).push([[179],{471:(ce,_e,B)=>{"use strict";var he={};B.r(he),B.d(he,{assertParamsValid:()=>OC,computeFlatOffset:()=>PC,computeOutShape:()=>y2,getNormalizedAxes:()=>w2,isSliceContinous:()=>MC,maskToAxes:()=>kg,parseSliceParams:()=>Ag,sliceInfo:()=>LC,startForAxis:()=>_2,startIndicesWithElidedDims:()=>C2,stopForAxis:()=>S2,stopIndicesWithElidedDims:()=>I2,stridesForAxis:()=>D2,stridesWithElidedDims:()=>b2});var at={};B.r(at),B.d(at,{collectGatherOpShapeInfo:()=>VI,computeOutShape:()=>sF,segOpComputeOptimalWindowSize:()=>rF});var X={};B.r(X),B.d(X,{ERF_A1:()=>FI,ERF_A2:()=>OI,ERF_A3:()=>MI,ERF_A4:()=>PI,ERF_A5:()=>LI,ERF_P:()=>$I,PARALLELIZE_THRESHOLD:()=>NI,SELU_SCALE:()=>ty,SELU_SCALEALPHA:()=>ey,applyActivation:()=>Yg,assertAndGetBroadcastShape:()=>wt,assertAxesAreInnerMostDims:()=>dr,assertParamsConsistent:()=>EI,assignToTypedArray:()=>eF,axesAreInnerMostDims:()=>KC,calculateShapes:()=>Ph,combineLocations:()=>$2,complexWithEvenIndex:()=>Z2,complexWithOddIndex:()=>Q2,computeConv2DInfo:()=>er,computeConv3DInfo:()=>Yi,computeDefaultPad:()=>VC,computeDilation2DInfo:()=>wh,computeOptimalWindowSize:()=>Qg,computeOutAndReduceShapes:()=>tr,computeOutShape:()=>wi,computePool2DInfo:()=>Fs,computePool3DInfo:()=>pi,convertConv2DDataFormat:()=>mi,eitherStridesOrDilationsAreOne:()=>cr,expandShapeToKeepDim:()=>xn,exponent:()=>nF,exponents:()=>tF,fromStringArrayToUint8:()=>oF,fromUint8ToStringArray:()=>UI,getAxesPermutation:()=>wn,getBroadcastDims:()=>Dh,getComplexWithIndex:()=>BI,getFusedBiasGradient:()=>Xg,getFusedDyActivation:()=>Kg,getImageCenter:()=>TI,getInnerMostAxes:()=>kn,getPermuted:()=>Oh,getReductionAxes:()=>Vn,getReshaped:()=>Fh,getReshapedPermuted:()=>Mh,getSliceBeginCoords:()=>kI,getSliceSize:()=>AI,getUndoAxesPermutation:()=>_u,log:()=>rZ,mergeRealAndImagArrays:()=>Ci,prepareAndValidate:()=>RI,prepareSplitSize:()=>zI,segment_util:()=>at,shouldFuse:()=>Jg,slice_util:()=>he,splitRealAndImagArrays:()=>J2,tupleValuesAreOne:()=>Ji,upcastType:()=>ps,validateInput:()=>Y2,validateUpdateShape:()=>X2,warn:()=>Ru});var Qe={};B.r(Qe),B.d(Qe,{json:()=>Zne});var be={};B.r(be),B.d(be,{json:()=>Qne});var Ce={};B.r(Ce),B.d(Ce,{json:()=>ere});var ie={};B.r(ie),B.d(ie,{json:()=>tre});var P={};B.r(P),B.d(P,{json:()=>nre});var I={};B.r(I),B.d(I,{json:()=>rre});var k={};B.r(k),B.d(k,{json:()=>sre});var $={};B.r($),B.d($,{json:()=>ore});var E={};B.r(E),B.d(E,{json:()=>ire});var N={};B.r(N),B.d(N,{json:()=>are});var z={};B.r(z),B.d(z,{json:()=>lre});var H={};B.r(H),B.d(H,{json:()=>ure});var et={};B.r(et),B.d(et,{json:()=>cre});var Mt={};B.r(Mt),B.d(Mt,{json:()=>dre});var Dt={};B.r(Dt),B.d(Dt,{json:()=>hre});var Dn={};B.r(Dn),B.d(Dn,{json:()=>fre});var _n={};B.r(_n),B.d(_n,{json:()=>pre});var fe={};function ae(t){return"function"==typeof t}function Ye(t){const e=t(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}B.r(fe),B.d(fe,{addImpl:()=>OM,bincountImpl:()=>y_,bincountReduceImpl:()=>VM,ceilImpl:()=>UM,concatImpl:()=>HM,expImpl:()=>qM,expm1Impl:()=>XM,floorImpl:()=>ZM,gatherV2Impl:()=>QM,greaterImpl:()=>eP,lessImpl:()=>tP,linSpaceImpl:()=>nP,logImpl:()=>rP,maxImpl:()=>sP,maximumImpl:()=>iP,minimumImpl:()=>aP,multiplyImpl:()=>b_,negImpl:()=>uP,notEqualImpl:()=>cP,prodImpl:()=>pP,rangeImpl:()=>mP,rsqrtImpl:()=>gP,simpleAbsImpl:()=>PM,sliceImpl:()=>zM,squaredDifferenceImpl:()=>vP,stridedSliceImpl:()=>xP,subImpl:()=>YM,tileImpl:()=>wP,topKImpl:()=>CP,transposeImpl:()=>m_,uniqueImpl:()=>DP});const Re=Ye(t=>function(e){t(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function ke(t,n){if(t){const e=t.indexOf(n);0<=e&&t.splice(e,1)}}class He{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const o of e)o.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(ae(r))try{r()}catch(o){n=o instanceof Re?o.errors:[o]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const o of s)try{kt(o)}catch(i){n=n??[],i instanceof Re?n=[...n,...i.errors]:n.push(i)}}if(n)throw new Re(n)}}add(n){var e;if(n&&n!==this)if(this.closed)kt(n);else{if(n instanceof He){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(n)}}_hasParent(n){const{_parentage:e}=this;return e===n||Array.isArray(e)&&e.includes(n)}_addParent(n){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(n),e):e?[e,n]:n}_removeParent(n){const{_parentage:e}=this;e===n?this._parentage=null:Array.isArray(e)&&ke(e,n)}remove(n){const{_finalizers:e}=this;e&&ke(e,n),n instanceof He&&n._removeParent(this)}}He.EMPTY=(()=>{const t=new He;return t.closed=!0,t})();const bt=He.EMPTY;function dt(t){return t instanceof He||t&&"closed"in t&&ae(t.remove)&&ae(t.add)&&ae(t.unsubscribe)}function kt(t){ae(t)?t():t.unsubscribe()}const pt={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Rt={setTimeout(t,n,...e){const{delegate:r}=Rt;return r?.setTimeout?r.setTimeout(t,n,...e):setTimeout(t,n,...e)},clearTimeout(t){const{delegate:n}=Rt;return(n?.clearTimeout||clearTimeout)(t)},delegate:void 0};function mr(t){Rt.setTimeout(()=>{const{onUnhandledError:n}=pt;if(!n)throw t;n(t)})}function $n(){}const jL=sb("C",void 0,void 0);function sb(t,n,e){return{kind:t,value:n,error:e}}let pa=null;function pf(t){if(pt.useDeprecatedSynchronousErrorHandling){const n=!pa;if(n&&(pa={errorThrown:!1,error:null}),t(),n){const{errorThrown:e,error:r}=pa;if(pa=null,e)throw r}}else t()}class ob extends He{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,dt(n)&&n.add(this)):this.destination=ZL}static create(n,e,r){return new nc(n,e,r)}next(n){this.isStopped?ab(function qL(t){return sb("N",t,void 0)}(n),this):this._next(n)}error(n){this.isStopped?ab(function GL(t){return sb("E",void 0,t)}(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?ab(jL,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const XL=Function.prototype.bind;function ib(t,n){return XL.call(t,n)}class YL{constructor(n){this.partialObserver=n}next(n){const{partialObserver:e}=this;if(e.next)try{e.next(n)}catch(r){mf(r)}}error(n){const{partialObserver:e}=this;if(e.error)try{e.error(n)}catch(r){mf(r)}else mf(n)}complete(){const{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(e){mf(e)}}}class nc extends ob{constructor(n,e,r){let s;if(super(),ae(n)||!n)s={next:n??void 0,error:e??void 0,complete:r??void 0};else{let o;this&&pt.useDeprecatedNextContext?(o=Object.create(n),o.unsubscribe=()=>this.unsubscribe(),s={next:n.next&&ib(n.next,o),error:n.error&&ib(n.error,o),complete:n.complete&&ib(n.complete,o)}):s=n}this.destination=new YL(s)}}function mf(t){pt.useDeprecatedSynchronousErrorHandling?function KL(t){pt.useDeprecatedSynchronousErrorHandling&&pa&&(pa.errorThrown=!0,pa.error=t)}(t):mr(t)}function ab(t,n){const{onStoppedNotification:e}=pt;e&&Rt.setTimeout(()=>e(t,n))}const ZL={closed:!0,next:$n,error:function JL(t){throw t},complete:$n},lb="function"==typeof Symbol&&Symbol.observable||"@@observable";function ma(t){return t}function H_(t){return 0===t.length?ma:1===t.length?t[0]:function(e){return t.reduce((r,s)=>s(r),e)}}let Fn=(()=>{class t{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,s){const o=function tB(t){return t&&t instanceof ob||function eB(t){return t&&ae(t.next)&&ae(t.error)&&ae(t.complete)}(t)&&dt(t)}(e)?e:new nc(e,r,s);return pf(()=>{const{operator:i,source:a}=this;o.add(i?i.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=W_(r))((s,o)=>{const i=new nc({next:a=>{try{e(a)}catch(l){o(l),i.unsubscribe()}},error:o,complete:s});this.subscribe(i)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[lb](){return this}pipe(...e){return H_(e)(this)}toPromise(e){return new(e=W_(e))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return t.create=n=>new t(n),t})();function W_(t){var n;return null!==(n=t??pt.Promise)&&void 0!==n?n:Promise}const nB=Ye(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Wo=(()=>{class t extends Fn{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new j_(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new nB}next(e){pf(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){pf(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){pf(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:o}=this;return r||s?bt:(this.currentObservers=null,o.push(e),new He(()=>{this.currentObservers=null,ke(o,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:o}=this;r?e.error(s):o&&e.complete()}asObservable(){const e=new Fn;return e.source=this,e}}return t.create=(n,e)=>new j_(n,e),t})();class j_ extends Wo{constructor(n,e){super(),this.destination=n,this.source=e}next(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,n)}error(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,n)}complete(){var n,e;null===(e=null===(n=this.destination)||void 0===n?void 0:n.complete)||void 0===e||e.call(n)}_subscribe(n){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(n))&&void 0!==r?r:bt}}function G_(t){return ae(t?.lift)}function or(t){return n=>{if(G_(n))return n.lift(function(e){try{return t(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function ir(t,n,e,r,s){return new rB(t,n,e,r,s)}class rB extends ob{constructor(n,e,r,s,o,i){super(n),this.onFinalize=o,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){n.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){n.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(n=this.onFinalize)||void 0===n||n.call(this))}}}function gt(t,n){return or((e,r)=>{let s=0;e.subscribe(ir(r,o=>{r.next(t.call(n,o,s++))}))})}function ga(t){return this instanceof ga?(this.v=t,this):new ga(t)}function iB(t,n,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(t,n||[]),o=[];return s={},i("next"),i("throw"),i("return"),s[Symbol.asyncIterator]=function(){return this},s;function i(h){r[h]&&(s[h]=function(f){return new Promise(function(p,m){o.push([h,f,p,m])>1||a(h,f)})})}function a(h,f){try{!function l(h){h.value instanceof ga?Promise.resolve(h.value.v).then(u,c):d(o[0][2],h)}(r[h](f))}catch(p){d(o[0][3],p)}}function u(h){a("next",h)}function c(h){a("throw",h)}function d(h,f){h(f),o.shift(),o.length&&a(o[0][0],o[0][1])}}function aB(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t=function X_(t){var n="function"==typeof Symbol&&Symbol.iterator,e=n&&t[n],r=0;if(e)return e.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(o){e[o]=t[o]&&function(i){return new Promise(function(a,l){!function s(o,i,a,l){Promise.resolve(l).then(function(u){o({value:u,done:a})},i)}(a,l,(i=t[o](i)).done,i.value)})}}}const Y_=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function J_(t){return ae(t?.then)}function Z_(t){return ae(t[lb])}function Q_(t){return Symbol.asyncIterator&&ae(t?.[Symbol.asyncIterator])}function eS(t){return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const tS=function uB(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function nS(t){return ae(t?.[tS])}function rS(t){return iB(this,arguments,function*(){const e=t.getReader();try{for(;;){const{value:r,done:s}=yield ga(e.read());if(s)return yield ga(void 0);yield yield ga(r)}}finally{e.releaseLock()}})}function sS(t){return ae(t?.getReader)}function vo(t){if(t instanceof Fn)return t;if(null!=t){if(Z_(t))return function cB(t){return new Fn(n=>{const e=t[lb]();if(ae(e.subscribe))return e.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(t);if(Y_(t))return function dB(t){return new Fn(n=>{for(let e=0;e<t.length&&!n.closed;e++)n.next(t[e]);n.complete()})}(t);if(J_(t))return function hB(t){return new Fn(n=>{t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,mr)})}(t);if(Q_(t))return oS(t);if(nS(t))return function fB(t){return new Fn(n=>{for(const e of t)if(n.next(e),n.closed)return;n.complete()})}(t);if(sS(t))return function pB(t){return oS(rS(t))}(t)}throw eS(t)}function oS(t){return new Fn(n=>{(function mB(t,n){var e,r,s,o;return function sB(t,n,e,r){return new(e||(e=Promise))(function(o,i){function a(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?o(c.value):function s(o){return o instanceof e?o:new e(function(i){i(o)})}(c.value).then(a,l)}u((r=r.apply(t,n||[])).next())})}(this,void 0,void 0,function*(){try{for(e=aB(t);!(r=yield e.next()).done;)if(n.next(r.value),n.closed)return}catch(i){s={error:i}}finally{try{r&&!r.done&&(o=e.return)&&(yield o.call(e))}finally{if(s)throw s.error}}n.complete()})})(t,n).catch(e=>n.error(e))})}function jo(t,n,e,r=0,s=!1){const o=n.schedule(function(){e(),s?t.add(this.schedule(null,r)):this.unsubscribe()},r);if(t.add(o),!s)return o}function gr(t,n,e=1/0){return ae(n)?gr((r,s)=>gt((o,i)=>n(r,o,s,i))(vo(t(r,s))),e):("number"==typeof n&&(e=n),or((r,s)=>function gB(t,n,e,r,s,o,i,a){const l=[];let u=0,c=0,d=!1;const h=()=>{d&&!l.length&&!u&&n.complete()},f=m=>u<r?p(m):l.push(m),p=m=>{o&&n.next(m),u++;let g=!1;vo(e(m,c++)).subscribe(ir(n,y=>{s?.(y),o?f(y):n.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(u--;l.length&&u<r;){const y=l.shift();i?jo(n,i,()=>p(y)):p(y)}h()}catch(y){n.error(y)}}))};return t.subscribe(ir(n,f,()=>{d=!0,h()})),()=>{a?.()}}(r,s,t,e)))}function fl(t=1/0){return gr(ma,t)}const Go=new Fn(t=>t.complete());function cb(t){return t[t.length-1]}function rc(t){return function bB(t){return t&&ae(t.schedule)}(cb(t))?t.pop():void 0}function iS(t,n=0){return or((e,r)=>{e.subscribe(ir(r,s=>jo(r,t,()=>r.next(s),n),()=>jo(r,t,()=>r.complete(),n),s=>jo(r,t,()=>r.error(s),n)))})}function aS(t,n=0){return or((e,r)=>{r.add(t.schedule(()=>e.subscribe(r),n))})}function lS(t,n){if(!t)throw new Error("Iterable cannot be null");return new Fn(e=>{jo(e,n,()=>{const r=t[Symbol.asyncIterator]();jo(e,n,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function jn(t,n){return n?function SB(t,n){if(null!=t){if(Z_(t))return function wB(t,n){return vo(t).pipe(aS(n),iS(n))}(t,n);if(Y_(t))return function IB(t,n){return new Fn(e=>{let r=0;return n.schedule(function(){r===t.length?e.complete():(e.next(t[r++]),e.closed||this.schedule())})})}(t,n);if(J_(t))return function CB(t,n){return vo(t).pipe(aS(n),iS(n))}(t,n);if(Q_(t))return lS(t,n);if(nS(t))return function DB(t,n){return new Fn(e=>{let r;return jo(e,n,()=>{r=t[tS](),jo(e,n,()=>{let s,o;try{({value:s,done:o}=r.next())}catch(i){return void e.error(i)}o?e.complete():e.next(s)},0,!0)}),()=>ae(r?.return)&&r.return()})}(t,n);if(sS(t))return function _B(t,n){return lS(rS(t),n)}(t,n)}throw eS(t)}(t,n):vo(t)}function db(t,n,...e){if(!0===n)return void t();if(!1===n)return;const r=new nc({next:()=>{r.unsubscribe(),t()}});return n(...e).subscribe(r)}function Kt(t){for(let n in t)if(t[n]===Kt)return n;throw Error("Could not find renamed property on target object.")}function Xt(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(Xt).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const n=t.toString();if(null==n)return""+n;const e=n.indexOf("\n");return-1===e?n:n.substring(0,e)}function fb(t,n){return null==t||""===t?null===n?"":n:null==n||""===n?t:t+" "+n}const TB=Kt({__forward_ref__:Kt});function pb(t){return t.__forward_ref__=pb,t.toString=function(){return Xt(this())},t}function Ge(t){return function mb(t){return"function"==typeof t&&t.hasOwnProperty(TB)&&t.__forward_ref__===pb}(t)?t():t}function gb(t){return t&&!!t.\u0275providers}class xe extends Error{constructor(n,e){super(function gf(t,n){return`NG0${Math.abs(t)}${n?": "+n.trim():""}`}(n,e)),this.code=n}}function ot(t){return"string"==typeof t?t:null==t?"":String(t)}function yf(t,n){throw new xe(-201,!1)}function ss(t,n){null==t&&function Lt(t,n,e,r){throw new Error(`ASSERTION ERROR: ${t}`+(null==r?"":` [Expected=> ${e} ${r} ${n} <=Actual]`))}(n,t,null,"!=")}function tt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Ko(t){return{providers:t.providers||[],imports:t.imports||[]}}function bf(t){return uS(t,vf)||uS(t,dS)}function uS(t,n){return t.hasOwnProperty(n)?t[n]:null}function cS(t){return t&&(t.hasOwnProperty(yb)||t.hasOwnProperty(LB))?t[yb]:null}const vf=Kt({\u0275prov:Kt}),yb=Kt({\u0275inj:Kt}),dS=Kt({ngInjectableDef:Kt}),LB=Kt({ngInjectorDef:Kt});var qe=(()=>((qe=qe||{})[qe.Default=0]="Default",qe[qe.Host=1]="Host",qe[qe.Self=2]="Self",qe[qe.SkipSelf=4]="SkipSelf",qe[qe.Optional=8]="Optional",qe))();let bb;function Is(t){const n=bb;return bb=t,n}function hS(t,n,e){const r=bf(t);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&qe.Optional?null:void 0!==n?n:void yf(Xt(t))}const Qt=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),sc={},vb="__NG_DI_FLAG__",xf="ngTempTokenPath",VB=/\n/gm,fS="__source";let oc;function pl(t){const n=oc;return oc=t,n}function HB(t,n=qe.Default){if(void 0===oc)throw new xe(-203,!1);return null===oc?hS(t,void 0,n):oc.get(t,n&qe.Optional?null:void 0,n)}function $e(t,n=qe.Default){return(function BB(){return bb}()||HB)(Ge(t),n)}function $t(t,n=qe.Default){return $e(t,wf(n))}function wf(t){return typeof t>"u"||"number"==typeof t?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function xb(t){const n=[];for(let e=0;e<t.length;e++){const r=Ge(t[e]);if(Array.isArray(r)){if(0===r.length)throw new xe(900,!1);let s,o=qe.Default;for(let i=0;i<r.length;i++){const a=r[i],l=WB(a);"number"==typeof l?-1===l?s=a.token:o|=l:s=a}n.push($e(s,o))}else n.push($e(r))}return n}function ic(t,n){return t[vb]=n,t.prototype[vb]=n,t}function WB(t){return t[vb]}function ki(t){return{toString:t}.toString()}var Ks=(()=>((Ks=Ks||{})[Ks.OnPush=0]="OnPush",Ks[Ks.Default=1]="Default",Ks))(),xo=(()=>{return(t=xo||(xo={}))[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",xo;var t})();const Xo={},Ft=[],Cf=Kt({\u0275cmp:Kt}),wb=Kt({\u0275dir:Kt}),Cb=Kt({\u0275pipe:Kt}),mS=Kt({\u0275mod:Kt}),Yo=Kt({\u0275fac:Kt}),ac=Kt({__NG_ELEMENT_ID__:Kt});let qB=0;function ya(t){return ki(()=>{const e=!0===t.standalone,r={},s={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:r,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===Ks.OnPush,directiveDefs:null,pipeDefs:null,standalone:e,dependencies:e&&t.dependencies||null,getStandaloneInjector:null,selectors:t.selectors||Ft,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||xo.Emulated,id:"c"+qB++,styles:t.styles||Ft,_:null,setInput:null,schemas:t.schemas||null,tView:null,findHostDirectiveDefs:null,hostDirectives:null},o=t.dependencies,i=t.features;return s.inputs=bS(t.inputs,r),s.outputs=bS(t.outputs),i&&i.forEach(a=>a(s)),s.directiveDefs=o?()=>("function"==typeof o?o():o).map(gS).filter(yS):null,s.pipeDefs=o?()=>("function"==typeof o?o():o).map(Or).filter(yS):null,s})}function gS(t){return Bt(t)||Cr(t)}function yS(t){return null!==t}function Ai(t){return ki(()=>({type:t.type,bootstrap:t.bootstrap||Ft,declarations:t.declarations||Ft,imports:t.imports||Ft,exports:t.exports||Ft,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function bS(t,n){if(null==t)return Xo;const e={};for(const r in t)if(t.hasOwnProperty(r)){let s=t[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),e[s]=r,n&&(n[s]=o)}return e}const Fr=ya;function Bt(t){return t[Cf]||null}function Cr(t){return t[wb]||null}function Or(t){return t[Cb]||null}function os(t,n){const e=t[mS]||null;if(!e&&!0===n)throw new Error(`Type ${Xt(t)} does not have '\u0275mod' property.`);return e}function qr(t){return Array.isArray(t)&&"object"==typeof t[1]}function Ys(t){return Array.isArray(t)&&!0===t[1]}function _b(t){return 0!=(4&t.flags)}function Sf(t){return t.componentOffset>-1}function Ef(t){return 1==(1&t.flags)}function Js(t){return null!==t.template}function QB(t){return 0!=(256&t[2])}function Ca(t,n){return t.hasOwnProperty(Yo)?t[Yo]:null}class nz{constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function Ia(){return wS}function wS(t){return t.type.prototype.ngOnChanges&&(t.setInput=sz),rz}function rz(){const t=IS(this),n=t?.current;if(n){const e=t.previous;if(e===Xo)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function sz(t,n,e,r){const s=this.declaredInputs[e],o=IS(t)||function oz(t,n){return t[CS]=n}(t,{previous:Xo,current:null}),i=o.current||(o.current={}),a=o.previous,l=a[s];i[s]=new nz(l&&l.currentValue,n,a===Xo),t[r]=n}Ia.ngInherit=!0;const CS="__ngSimpleChanges__";function IS(t){return t[CS]||null}function On(t){for(;Array.isArray(t);)t=t[0];return t}function as(t,n){return On(n[t.index])}function kb(t,n){return t.data[n]}function ls(t,n){const e=n[t];return qr(e)?e:e[0]}function Tf(t){return 64==(64&t[2])}function Ri(t,n){return null==n?null:t[n]}function DS(t){t[18]=0}function Ab(t,n){t[5]+=n;let e=t,r=t[3];for(;null!==r&&(1===n&&1===e[5]||-1===n&&0===e[5]);)r[5]+=n,e=r,r=r[3]}const nt={lFrame:FS(null),bindingsEnabled:!0};function SS(){return nt.bindingsEnabled}function oe(){return nt.lFrame.lView}function Tt(){return nt.lFrame.tView}function Zs(t){return nt.lFrame.contextLView=t,t[8]}function Qs(t){return nt.lFrame.contextLView=null,t}function yr(){let t=ES();for(;null!==t&&64===t.type;)t=t.parent;return t}function ES(){return nt.lFrame.currentTNode}function wo(t,n){const e=nt.lFrame;e.currentTNode=t,e.isParent=n}function Rb(){return nt.lFrame.isParent}function xl(){return nt.lFrame.bindingIndex++}function xz(t,n){const e=nt.lFrame;e.bindingIndex=e.bindingRootIndex=t,Fb(n)}function Fb(t){nt.lFrame.currentDirectiveIndex=t}function AS(){return nt.lFrame.currentQueryIndex}function Mb(t){nt.lFrame.currentQueryIndex=t}function Cz(t){const n=t[1];return 2===n.type?n.declTNode:1===n.type?t[6]:null}function RS(t,n,e){if(e&qe.SkipSelf){let s=n,o=t;for(;!(s=s.parent,null!==s||e&qe.Host||(s=Cz(o),null===s||(o=o[15],10&s.type))););if(null===s)return!1;n=s,t=o}const r=nt.lFrame=$S();return r.currentTNode=n,r.lView=t,!0}function Pb(t){const n=$S(),e=t[1];nt.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function $S(){const t=nt.lFrame,n=null===t?null:t.child;return null===n?FS(t):n}function FS(t){const n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=n),n}function OS(){const t=nt.lFrame;return nt.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const MS=OS;function Lb(){const t=OS();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function Pr(){return nt.lFrame.selectedIndex}function Da(t){nt.lFrame.selectedIndex=t}function kf(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){const o=t.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=o;i&&(t.contentHooks||(t.contentHooks=[])).push(-e,i),a&&((t.contentHooks||(t.contentHooks=[])).push(e,a),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(e,a)),l&&(t.viewHooks||(t.viewHooks=[])).push(-e,l),u&&((t.viewHooks||(t.viewHooks=[])).push(e,u),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(e,u)),null!=c&&(t.destroyHooks||(t.destroyHooks=[])).push(e,c)}}function Af(t,n,e){PS(t,n,3,e)}function Rf(t,n,e,r){(3&t[2])===e&&PS(t,n,e,r)}function Bb(t,n){let e=t[2];(3&e)===n&&(e&=2047,e+=1,t[2]=e)}function PS(t,n,e,r){const o=r??-1,i=n.length-1;let a=0;for(let l=void 0!==r?65535&t[18]:0;l<i;l++)if("number"==typeof n[l+1]){if(a=n[l],null!=r&&a>=r)break}else n[l]<0&&(t[18]+=65536),(a<o||-1==o)&&(Az(t,e,n,l),t[18]=(4294901760&t[18])+l+2),l++}function Az(t,n,e,r){const s=e[r]<0,o=e[r+1],a=t[s?-e[r]:e[r]];if(s){if(t[2]>>11<t[18]>>16&&(3&t[2])===n){t[2]+=2048;try{o.call(a)}finally{}}}else try{o.call(a)}finally{}}class fc{constructor(n,e,r){this.factory=n,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function Vb(t,n,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const o=e[r++],i=e[r++],a=e[r++];t.setAttribute(n,i,a,o)}else{const o=s,i=e[++r];BS(o)?t.setProperty(n,o,i):t.setAttribute(n,o,i),r++}}return r}function LS(t){return 3===t||4===t||6===t}function BS(t){return 64===t.charCodeAt(0)}function mc(t,n){if(null!==n&&0!==n.length)if(null===t||0===t.length)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){const s=n[r];"number"==typeof s?e=s:0===e||zS(t,e,s,null,-1===e||2===e?n[++r]:null)}}return t}function zS(t,n,e,r,s){let o=0,i=t.length;if(-1===n)i=-1;else for(;o<t.length;){const a=t[o++];if("number"==typeof a){if(a===n){i=-1;break}if(a>n){i=o-1;break}}}for(;o<t.length;){const a=t[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(t[o+1]=s));if(r===t[o+1])return void(t[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(t.splice(i,0,n),o=i+1),t.splice(o++,0,e),null!==r&&t.splice(o++,0,r),null!==s&&t.splice(o++,0,s)}function VS(t){return-1!==t}function wl(t){return 32767&t}function Cl(t,n){let e=function Mz(t){return t>>16}(t),r=n;for(;e>0;)r=r[15],e--;return r}let Ub=!0;function $f(t){const n=Ub;return Ub=t,n}let Pz=0;const Co={};function Ff(t,n){const e=Wb(t,n);if(-1!==e)return e;const r=n[1];r.firstCreatePass&&(t.injectorIndex=n.length,Hb(r.data,t),Hb(n,null),Hb(r.blueprint,null));const s=Of(t,n),o=t.injectorIndex;if(VS(s)){const i=wl(s),a=Cl(s,n),l=a[1].data;for(let u=0;u<8;u++)n[o+u]=a[i+u]|l[i+u]}return n[o+8]=s,o}function Hb(t,n){t.push(0,0,0,0,0,0,0,0,n)}function Wb(t,n){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===n[t.injectorIndex+8]?-1:t.injectorIndex}function Of(t,n){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let e=0,r=null,s=n;for(;null!==s;){if(r=YS(s),null===r)return-1;if(e++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return-1}function jb(t,n,e){!function Lz(t,n,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(ac)&&(r=e[ac]),null==r&&(r=e[ac]=Pz++);const s=255&r;n.data[t+(s>>5)]|=1<<s}(t,n,e)}function WS(t,n,e){if(e&qe.Optional||void 0!==t)return t;yf()}function jS(t,n,e,r){if(e&qe.Optional&&void 0===r&&(r=null),0==(e&(qe.Self|qe.Host))){const s=t[9],o=Is(void 0);try{return s?s.get(n,r,e&qe.Optional):hS(n,r,e&qe.Optional)}finally{Is(o)}}return WS(r,0,e)}function GS(t,n,e,r=qe.Default,s){if(null!==t){if(1024&n[2]){const i=function Wz(t,n,e,r,s){let o=t,i=n;for(;null!==o&&null!==i&&1024&i[2]&&!(256&i[2]);){const a=qS(o,i,e,r|qe.Self,Co);if(a!==Co)return a;let l=o.parent;if(!l){const u=i[21];if(u){const c=u.get(e,Co,r);if(c!==Co)return c}l=YS(i),i=i[15]}o=l}return s}(t,n,e,r,Co);if(i!==Co)return i}const o=qS(t,n,e,r,Co);if(o!==Co)return o}return jS(n,e,r,s)}function qS(t,n,e,r,s){const o=function Vz(t){if("string"==typeof t)return t.charCodeAt(0)||0;const n=t.hasOwnProperty(ac)?t[ac]:void 0;return"number"==typeof n?n>=0?255&n:Uz:n}(e);if("function"==typeof o){if(!RS(n,t,r))return r&qe.Host?WS(s,0,r):jS(n,e,r,s);try{const i=o(r);if(null!=i||r&qe.Optional)return i;yf()}finally{MS()}}else if("number"==typeof o){let i=null,a=Wb(t,n),l=-1,u=r&qe.Host?n[16][6]:null;for((-1===a||r&qe.SkipSelf)&&(l=-1===a?Of(t,n):n[a+8],-1!==l&&XS(r,!1)?(i=n[1],a=wl(l),n=Cl(l,n)):a=-1);-1!==a;){const c=n[1];if(KS(o,a,c.data)){const d=zz(a,n,e,i,r,u);if(d!==Co)return d}l=n[a+8],-1!==l&&XS(r,n[1].data[a+8]===u)&&KS(o,a,n)?(i=c,a=wl(l),n=Cl(l,n)):a=-1}}return s}function zz(t,n,e,r,s,o){const i=n[1],a=i.data[t+8],c=Mf(a,i,e,null==r?Sf(a)&&Ub:r!=i&&0!=(3&a.type),s&qe.Host&&o===a);return null!==c?Il(n,i,c,a):Co}function Mf(t,n,e,r,s){const o=t.providerIndexes,i=n.data,a=1048575&o,l=t.directiveStart,c=o>>20,h=s?a+c:t.directiveEnd;for(let f=r?a:a+c;f<h;f++){const p=i[f];if(f<l&&e===p||f>=l&&p.type===e)return f}if(s){const f=i[l];if(f&&Js(f)&&f.type===e)return l}return null}function Il(t,n,e,r){let s=t[e];const o=n.data;if(function Rz(t){return t instanceof fc}(s)){const i=s;i.resolving&&function kB(t,n){const e=n?`. Dependency path: ${n.join(" > ")} > ${t}`:"";throw new xe(-200,`Circular dependency in DI detected for ${t}${e}`)}(function Pt(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():ot(t)}(o[e]));const a=$f(i.canSeeViewProviders);i.resolving=!0;const l=i.injectImpl?Is(i.injectImpl):null;RS(t,r,qe.Default);try{s=t[e]=i.factory(void 0,o,t,r),n.firstCreatePass&&e>=r.directiveStart&&function kz(t,n,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=n.type.prototype;if(r){const i=wS(n);(e.preOrderHooks||(e.preOrderHooks=[])).push(t,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(t,i)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-t,s),o&&((e.preOrderHooks||(e.preOrderHooks=[])).push(t,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(t,o))}(e,o[e],n)}finally{null!==l&&Is(l),$f(a),i.resolving=!1,MS()}}return s}function KS(t,n,e){return!!(e[n+(t>>5)]&1<<t)}function XS(t,n){return!(t&qe.Self||t&qe.Host&&n)}class Dl{constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return GS(this._tNode,this._lView,n,wf(r),e)}}function Uz(){return new Dl(yr(),oe())}function YS(t){const n=t[1],e=n.type;return 2===e?n.declTNode:1===e?t[6]:null}const Sl="__parameters__";function Nl(t,n,e){return ki(()=>{const r=function qb(t){return function(...e){if(t){const r=t(...e);for(const s in r)this[s]=r[s]}}}(n);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(l,u,c){const d=l.hasOwnProperty(Sl)?l[Sl]:Object.defineProperty(l,Sl,{value:[]})[Sl];for(;d.length<=c;)d.push(null);return(d[c]=d[c]||[]).push(i),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=t,s.annotationCls=s,s})}class Me{constructor(n,e){this._desc=n,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=tt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function us(t,n){void 0===n&&(n=t);for(let e=0;e<t.length;e++){let r=t[e];Array.isArray(r)?(n===t&&(n=t.slice(0,e)),us(r,n)):n!==t&&n.push(r)}return n}function _a(t,n){t.forEach(e=>Array.isArray(e)?_a(e,n):n(e))}function ZS(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function Lf(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}const vc=ic(Nl("Optional"),8),xc=ic(Nl("SkipSelf"),4);var Kr=(()=>((Kr=Kr||{})[Kr.Important=1]="Important",Kr[Kr.DashCase=2]="DashCase",Kr))();const tv=new Map;let g3=0;const rv="__ngContext__";function _r(t,n){qr(n)?(t[rv]=n[20],function b3(t){tv.set(t[20],t)}(n)):t[rv]=n}function ov(t,n){return undefined(t,n)}function Dc(t){const n=t[3];return Ys(n)?n[3]:n}function iv(t){return CE(t[13])}function av(t){return CE(t[4])}function CE(t){for(;null!==t&&!Ys(t);)t=t[4];return t}function Al(t,n,e,r,s){if(null!=r){let o,i=!1;Ys(r)?o=r:qr(r)&&(i=!0,r=r[0]);const a=On(r);0===t&&null!==e?null==s?NE(n,e,a):Sa(n,e,a,s||null,!0):1===t&&null!==e?Sa(n,e,a,s||null,!0):2===t?function pv(t,n,e){const r=Uf(t,n);r&&function B3(t,n,e,r){t.removeChild(n,e,r)}(t,r,n,e)}(n,a,i):3===t&&n.destroyNode(a),null!=o&&function U3(t,n,e,r,s){const o=e[7];o!==On(e)&&Al(n,t,r,o,s);for(let a=10;a<e.length;a++){const l=e[a];_c(l[1],l,t,n,r,o)}}(n,t,o,e,s)}}function uv(t,n,e){return t.createElement(n,e)}function DE(t,n){const e=t[9],r=e.indexOf(n),s=n[3];512&n[2]&&(n[2]&=-513,Ab(s,-1)),e.splice(r,1)}function cv(t,n){if(t.length<=10)return;const e=10+n,r=t[e];if(r){const s=r[17];null!==s&&s!==t&&DE(s,r),n>0&&(t[e-1][4]=r[4]);const o=Lf(t,10+n);!function A3(t,n){_c(t,n,n[11],2,null,null),n[0]=null,n[6]=null}(r[1],r);const i=o[19];null!==i&&i.detachView(o[1]),r[3]=null,r[4]=null,r[2]&=-65}return r}function _E(t,n){if(!(128&n[2])){const e=n[11];e.destroyNode&&_c(t,n,e,3,null,null),function F3(t){let n=t[13];if(!n)return dv(t[1],t);for(;n;){let e=null;if(qr(n))e=n[13];else{const r=n[10];r&&(e=r)}if(!e){for(;n&&!n[4]&&n!==t;)qr(n)&&dv(n[1],n),n=n[3];null===n&&(n=t),qr(n)&&dv(n[1],n),e=n&&n[4]}n=e}}(n)}}function dv(t,n){if(!(128&n[2])){n[2]&=-65,n[2]|=128,function L3(t,n){let e;if(null!=t&&null!=(e=t.destroyHooks))for(let r=0;r<e.length;r+=2){const s=n[e[r]];if(!(s instanceof fc)){const o=e[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],l=o[i+1];try{l.call(a)}finally{}}else try{o.call(s)}finally{}}}}(t,n),function P3(t,n){const e=t.cleanup,r=n[7];let s=-1;if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const i=e[o+1],a="function"==typeof i?i(n):On(n[i]),l=r[s=e[o+2]],u=e[o+3];"boolean"==typeof u?a.removeEventListener(e[o],l,u):u>=0?r[s=u]():r[s=-u].unsubscribe(),o+=2}else{const i=r[s=e[o+1]];e[o].call(i)}if(null!==r){for(let o=s+1;o<r.length;o++)(0,r[o])();n[7]=null}}(t,n),1===n[1].type&&n[11].destroy();const e=n[17];if(null!==e&&Ys(n[3])){e!==n[3]&&DE(e,n);const r=n[19];null!==r&&r.detachView(t)}!function v3(t){tv.delete(t[20])}(n)}}function SE(t,n,e){return function EE(t,n,e){let r=n;for(;null!==r&&40&r.type;)r=(n=r).parent;if(null===r)return e[0];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:o}=t.data[r.directiveStart+s];if(o===xo.None||o===xo.Emulated)return null}return as(r,e)}}(t,n.parent,e)}function Sa(t,n,e,r,s){t.insertBefore(n,e,r,s)}function NE(t,n,e){t.appendChild(n,e)}function TE(t,n,e,r,s){null!==r?Sa(t,n,e,r,s):NE(t,n,e)}function Uf(t,n){return t.parentNode(n)}let yv,RE=function AE(t,n,e){return 40&t.type?as(t,e):null};function Hf(t,n,e,r){const s=SE(t,r,n),o=n[11],a=function kE(t,n,e){return RE(t,n,e)}(r.parent||n[6],r,n);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)TE(o,s,e[l],a,!1);else TE(o,s,e,a,!1)}function Wf(t,n){if(null!==n){const e=n.type;if(3&e)return as(n,t);if(4&e)return fv(-1,t[n.index]);if(8&e){const r=n.child;if(null!==r)return Wf(t,r);{const s=t[n.index];return Ys(s)?fv(-1,s):On(s)}}if(32&e)return ov(n,t)()||On(t[n.index]);{const r=FE(t,n);return null!==r?Array.isArray(r)?r[0]:Wf(Dc(t[16]),r):Wf(t,n.next)}}return null}function FE(t,n){return null!==n?t[16][6].projection[n.projection]:null}function fv(t,n){const e=10+t+1;if(e<n.length){const r=n[e],s=r[1].firstChild;if(null!==s)return Wf(r,s)}return n[7]}function mv(t,n,e,r,s,o,i){for(;null!=e;){const a=r[e.index],l=e.type;if(i&&0===n&&(a&&_r(On(a),r),e.flags|=2),32!=(32&e.flags))if(8&l)mv(t,n,e.child,r,s,o,!1),Al(n,t,s,a,o);else if(32&l){const u=ov(e,r);let c;for(;c=u();)Al(n,t,s,c,o);Al(n,t,s,a,o)}else 16&l?OE(t,n,r,e,s,o):Al(n,t,s,a,o);e=i?e.projectionNext:e.next}}function _c(t,n,e,r,s,o){mv(e,r,t.firstChild,n,s,o,!1)}function OE(t,n,e,r,s,o){const i=e[16],l=i[6].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)Al(n,t,s,l[u],o);else mv(t,n,l,i[3],s,o,!0)}function ME(t,n,e){""===e?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function PE(t,n,e){const{mergedAttrs:r,classes:s,styles:o}=e;null!==r&&Vb(t,n,r),null!==s&&ME(t,n,s),null!==o&&function W3(t,n,e){t.setAttribute(n,"style",e)}(t,n,o)}const Kf=new Me("ENVIRONMENT_INITIALIZER"),ZE=new Me("INJECTOR",-1),QE=new Me("INJECTOR_DEF_TYPES");class e1{get(n,e=sc){if(e===sc){const r=new Error(`NullInjectorError: No provider for ${Xt(n)}!`);throw r.name="NullInjectorError",r}return e}}function bV(...t){return{\u0275providers:t1(0,t),\u0275fromNgModule:!0}}function t1(t,...n){const e=[],r=new Set;let s;return _a(n,o=>{const i=o;Iv(i,e,[],r)&&(s||(s=[]),s.push(i))}),void 0!==s&&n1(s,e),e}function n1(t,n){for(let e=0;e<t.length;e++){const{providers:s}=t[e];Dv(s,o=>{n.push(o)})}}function Iv(t,n,e,r){if(!(t=Ge(t)))return!1;let s=null,o=cS(t);const i=!o&&Bt(t);if(o||i){if(i&&!i.standalone)return!1;s=t}else{const l=t.ngModule;if(o=cS(l),!o)return!1;s=l}const a=r.has(s);if(i){if(a)return!1;if(r.add(s),i.dependencies){const l="function"==typeof i.dependencies?i.dependencies():i.dependencies;for(const u of l)Iv(u,n,e,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let u;r.add(s);try{_a(o.imports,c=>{Iv(c,n,e,r)&&(u||(u=[]),u.push(c))})}finally{}void 0!==u&&n1(u,n)}if(!a){const u=Ca(s)||(()=>new s);n.push({provide:s,useFactory:u,deps:Ft},{provide:QE,useValue:s,multi:!0},{provide:Kf,useValue:()=>$e(s),multi:!0})}const l=o.providers;null==l||a||Dv(l,c=>{n.push(c)})}}return s!==t&&void 0!==t.providers}function Dv(t,n){for(let e of t)gb(e)&&(e=e.\u0275providers),Array.isArray(e)?Dv(e,n):n(e)}const vV=Kt({provide:String,useValue:Kt});function _v(t){return null!==t&&"object"==typeof t&&vV in t}function Na(t){return"function"==typeof t}const Sv=new Me("Set Injector scope."),Xf={},wV={};let Ev;function Yf(){return void 0===Ev&&(Ev=new e1),Ev}class ei{}class o1 extends ei{constructor(n,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,Tv(n,i=>this.processProvider(i)),this.records.set(ZE,Rl(void 0,this)),s.has("environment")&&this.records.set(ei,Rl(void 0,this));const o=this.records.get(Sv);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(QE.multi,Ft,qe.Self))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const n of this._ngOnDestroyHooks)n.ngOnDestroy();for(const n of this._onDestroyHooks)n()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(n){this._onDestroyHooks.push(n)}runInContext(n){this.assertNotDestroyed();const e=pl(this),r=Is(void 0);try{return n()}finally{pl(e),Is(r)}}get(n,e=sc,r=qe.Default){this.assertNotDestroyed(),r=wf(r);const s=pl(this),o=Is(void 0);try{if(!(r&qe.SkipSelf)){let a=this.records.get(n);if(void 0===a){const l=function SV(t){return"function"==typeof t||"object"==typeof t&&t instanceof Me}(n)&&bf(n);a=l&&this.injectableDefInScope(l)?Rl(Nv(n),Xf):null,this.records.set(n,a)}if(null!=a)return this.hydrate(n,a)}return(r&qe.Self?Yf():this.parent).get(n,e=r&qe.Optional&&e===sc?null:e)}catch(i){if("NullInjectorError"===i.name){if((i[xf]=i[xf]||[]).unshift(Xt(n)),s)throw i;return function jB(t,n,e,r){const s=t[xf];throw n[fS]&&s.unshift(n[fS]),t.message=function GB(t,n,e,r=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.slice(2):t;let s=Xt(n);if(Array.isArray(n))s=n.map(Xt).join(" -> ");else if("object"==typeof n){let o=[];for(let i in n)if(n.hasOwnProperty(i)){let a=n[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):Xt(a)))}s=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${t.replace(VB,"\n  ")}`}("\n"+t.message,s,e,r),t.ngTokenPath=s,t[xf]=null,t}(i,n,"R3InjectorError",this.source)}throw i}finally{Is(o),pl(s)}}resolveInjectorInitializers(){const n=pl(this),e=Is(void 0);try{const r=this.get(Kf.multi,Ft,qe.Self);for(const s of r)s()}finally{pl(n),Is(e)}}toString(){const n=[],e=this.records;for(const r of e.keys())n.push(Xt(r));return`R3Injector[${n.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new xe(205,!1)}processProvider(n){let e=Na(n=Ge(n))?n:Ge(n&&n.provide);const r=function IV(t){return _v(t)?Rl(void 0,t.useValue):Rl(function i1(t,n,e){let r;if(Na(t)){const s=Ge(t);return Ca(s)||Nv(s)}if(_v(t))r=()=>Ge(t.useValue);else if(function s1(t){return!(!t||!t.useFactory)}(t))r=()=>t.useFactory(...xb(t.deps||[]));else if(function r1(t){return!(!t||!t.useExisting)}(t))r=()=>$e(Ge(t.useExisting));else{const s=Ge(t&&(t.useClass||t.provide));if(!function DV(t){return!!t.deps}(t))return Ca(s)||Nv(s);r=()=>new s(...xb(t.deps))}return r}(t),Xf)}(n);if(Na(n)||!0!==n.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=Rl(void 0,Xf,!0),s.factory=()=>xb(s.multi),this.records.set(e,s)),e=n,s.multi.push(n)}this.records.set(e,r)}hydrate(n,e){return e.value===Xf&&(e.value=wV,e.value=e.factory()),"object"==typeof e.value&&e.value&&function _V(t){return null!==t&&"object"==typeof t&&"function"==typeof t.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(n){if(!n.providedIn)return!1;const e=Ge(n.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function Nv(t){const n=bf(t),e=null!==n?n.factory:Ca(t);if(null!==e)return e;if(t instanceof Me)throw new xe(204,!1);if(t instanceof Function)return function CV(t){const n=t.length;if(n>0)throw function bc(t,n){const e=[];for(let r=0;r<t;r++)e.push(n);return e}(n,"?"),new xe(204,!1);const e=function MB(t){const n=t&&(t[vf]||t[dS]);if(n){const e=function PB(t){if(t.hasOwnProperty("name"))return t.name;const n=(""+t).match(/^function\s*([^\s(]+)/);return null===n?"":n[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`),n}return null}(t);return null!==e?()=>e.factory(t):()=>new t}(t);throw new xe(204,!1)}function Rl(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function Tv(t,n){for(const e of t)Array.isArray(e)?Tv(e,n):e&&gb(e)?Tv(e.\u0275providers,n):n(e)}class EV{}class a1{}class TV{resolveComponentFactory(n){throw function NV(t){const n=Error(`No component factory found for ${Xt(t)}. Did you add it to @NgModule.entryComponents?`);return n.ngComponent=t,n}(n)}}let Tc=(()=>{class t{}return t.NULL=new TV,t})();function kV(){return $l(yr(),oe())}function $l(t,n){return new Oi(as(t,n))}let Oi=(()=>{class t{constructor(e){this.nativeElement=e}}return t.__NG_ELEMENT_ID__=kV,t})();function AV(t){return t instanceof Oi?t.nativeElement:t}class u1{}let $V=(()=>{class t{}return t.\u0275prov=tt({token:t,providedIn:"root",factory:()=>null}),t})();class Zf{constructor(n){this.full=n,this.major=n.split(".")[0],this.minor=n.split(".")[1],this.patch=n.split(".").slice(2).join(".")}}const FV=new Zf("15.0.0"),kv={};function Rv(t){return t.ngOriginalError}class Fl{constructor(){this._console=console}handleError(n){const e=this._findOriginalError(n);this._console.error("ERROR",n),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(n){let e=n&&Rv(n);for(;e&&Rv(e);)e=Rv(e);return e||null}}function ti(t){return t instanceof Function?t():t}function d1(t,n,e){let r=t.length;for(;;){const s=t.indexOf(n,e);if(-1===s)return s;if(0===s||t.charCodeAt(s-1)<=32){const o=n.length;if(s+o===r||t.charCodeAt(s+o)<=32)return s}e=s+1}}const h1="ng-template";function jV(t,n,e){let r=0;for(;r<t.length;){let s=t[r++];if(e&&"class"===s){if(s=t[r],-1!==d1(s.toLowerCase(),n,0))return!0}else if(1===s){for(;r<t.length&&"string"==typeof(s=t[r++]);)if(s.toLowerCase()===n)return!0;return!1}}return!1}function f1(t){return 4===t.type&&t.value!==h1}function GV(t,n,e){return n===(4!==t.type||e?t.value:h1)}function qV(t,n,e){let r=4;const s=t.attrs||[],o=function YV(t){for(let n=0;n<t.length;n++)if(LS(t[n]))return n;return t.length}(s);let i=!1;for(let a=0;a<n.length;a++){const l=n[a];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!GV(t,l,e)||""===l&&1===n.length){if(eo(r))return!1;i=!0}}else{const u=8&r?l:n[++a];if(8&r&&null!==t.attrs){if(!jV(t.attrs,u,e)){if(eo(r))return!1;i=!0}continue}const d=KV(8&r?"class":l,s,f1(t),e);if(-1===d){if(eo(r))return!1;i=!0;continue}if(""!==u){let h;h=d>o?"":s[d+1].toLowerCase();const f=8&r?h:null;if(f&&-1!==d1(f,u,0)||2&r&&u!==h){if(eo(r))return!1;i=!0}}}}else{if(!i&&!eo(r)&&!eo(l))return!1;if(i&&eo(l))continue;i=!1,r=l|1&r}}return eo(r)||i}function eo(t){return 0==(1&t)}function KV(t,n,e,r){if(null===n)return-1;let s=0;if(r||!e){let o=!1;for(;s<n.length;){const i=n[s];if(i===t)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=n[++s];for(;"string"==typeof a;)a=n[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function JV(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){const r=t[e];if("number"==typeof r)return-1;if(r===n)return e;e++}return-1}(n,t)}function p1(t,n,e=!1){for(let r=0;r<n.length;r++)if(qV(t,n[r],e))return!0;return!1}function m1(t,n){return t?":not("+n.trim()+")":n}function QV(t){let n=t[0],e=1,r=2,s="",o=!1;for(;e<t.length;){let i=t[e];if("string"==typeof i)if(2&r){const a=t[++e];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!eo(i)&&(n+=m1(o,s),s=""),r=i,o=o||!eo(r);e++}return""!==s&&(n+=m1(o,s)),n}const it={};function Sn(t){g1(Tt(),oe(),Pr()+t,!1)}function g1(t,n,e,r){if(!r)if(3==(3&n[2])){const o=t.preOrderCheckHooks;null!==o&&Af(n,o,e)}else{const o=t.preOrderHooks;null!==o&&Rf(n,o,0,e)}Da(e)}function x1(t,n=null,e=null,r){const s=w1(t,n,e,r);return s.resolveInjectorInitializers(),s}function w1(t,n=null,e=null,r,s=new Set){const o=[e||Ft,bV(t)];return r=r||("object"==typeof t?void 0:Xt(t)),new o1(o,n||Yf(),r||null,s)}let to=(()=>{class t{static create(e,r){if(Array.isArray(e))return x1({name:""},r,e,"");{const s=e.name??"";return x1({name:s},e.parent,e.providers,s)}}}return t.THROW_IF_NOT_FOUND=sc,t.NULL=new e1,t.\u0275prov=tt({token:t,providedIn:"any",factory:()=>$e(ZE)}),t.__NG_ELEMENT_ID__=-1,t})();function Ke(t,n=qe.Default){const e=oe();return null===e?$e(t,n):GS(yr(),e,Ge(t),n)}function Pv(){throw new Error("invalid")}function L1(t,n){const e=t.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r],o=e[r+1];if(-1!==o){const i=t.data[o];Mb(s),i.contentQueries(2,n[o],o)}}}function rp(t,n,e,r,s,o,i,a,l,u,c){const d=n.blueprint.slice();return d[0]=s,d[2]=76|r,(null!==c||t&&1024&t[2])&&(d[2]|=1024),DS(d),d[3]=d[15]=t,d[8]=e,d[10]=i||t&&t[10],d[11]=a||t&&t[11],d[12]=l||t&&t[12]||null,d[9]=u||t&&t[9]||null,d[6]=o,d[20]=function y3(){return g3++}(),d[21]=c,d[16]=2==n.type?t[16]:d,d}function Pl(t,n,e,r,s){let o=t.data[n];if(null===o)o=function Kv(t,n,e,r,s){const o=ES(),i=Rb(),l=t.data[n]=function OU(t,n,e,r,s,o){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:n?n.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,e,n,r,s);return null===t.firstChild&&(t.firstChild=l),null!==o&&(i?null==o.child&&null!==l.parent&&(o.child=l):null===o.next&&(o.next=l)),l}(t,n,e,r,s),function vz(){return nt.lFrame.inI18n}()&&(o.flags|=32);else if(64&o.type){o.type=e,o.value=r,o.attrs=s;const i=function hc(){const t=nt.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return wo(o,!0),o}function kc(t,n,e,r){if(0===e)return-1;const s=n.length;for(let o=0;o<e;o++)n.push(r),t.blueprint.push(r),t.data.push(null);return s}function Xv(t,n,e){Pb(n);try{const r=t.viewQuery;null!==r&&ox(1,r,e);const s=t.template;null!==s&&B1(t,n,s,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&L1(t,n),t.staticViewQueries&&ox(2,t.viewQuery,e);const o=t.components;null!==o&&function RU(t,n){for(let e=0;e<n.length;e++)e4(t,n[e])}(n,o)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[2]&=-5,Lb()}}function sp(t,n,e,r){const s=n[2];if(128!=(128&s)){Pb(n);try{DS(n),function TS(t){return nt.lFrame.bindingIndex=t}(t.bindingStartIndex),null!==e&&B1(t,n,e,2,r);const i=3==(3&s);if(i){const u=t.preOrderCheckHooks;null!==u&&Af(n,u,null)}else{const u=t.preOrderHooks;null!==u&&Rf(n,u,0,null),Bb(n,0)}if(function ZU(t){for(let n=iv(t);null!==n;n=av(n)){if(!n[2])continue;const e=n[9];for(let r=0;r<e.length;r++){const s=e[r],o=s[3];0==(512&s[2])&&Ab(o,1),s[2]|=512}}}(n),function JU(t){for(let n=iv(t);null!==n;n=av(n))for(let e=10;e<n.length;e++){const r=n[e],s=r[1];Tf(r)&&sp(s,r,s.template,r[8])}}(n),null!==t.contentQueries&&L1(t,n),i){const u=t.contentCheckHooks;null!==u&&Af(n,u)}else{const u=t.contentHooks;null!==u&&Rf(n,u,1),Bb(n,1)}!function kU(t,n){const e=t.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)Da(~s);else{const o=s,i=e[++r],a=e[++r];xz(i,o),a(2,n[o])}}}finally{Da(-1)}}(t,n);const a=t.components;null!==a&&function AU(t,n){for(let e=0;e<n.length;e++)QU(t,n[e])}(n,a);const l=t.viewQuery;if(null!==l&&ox(2,l,r),i){const u=t.viewCheckHooks;null!==u&&Af(n,u)}else{const u=t.viewHooks;null!==u&&Rf(n,u,2),Bb(n,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),n[2]&=-41,512&n[2]&&(n[2]&=-513,Ab(n[3],-1))}finally{Lb()}}}function B1(t,n,e,r,s){const o=Pr(),i=2&r;try{Da(-1),i&&n.length>22&&g1(t,n,22,!1),e(r,s)}finally{Da(o)}}function Yv(t,n,e){if(_b(n)){const s=n.directiveEnd;for(let o=n.directiveStart;o<s;o++){const i=t.data[o];i.contentQueries&&i.contentQueries(1,e[o],o)}}}function Jv(t,n,e){!SS()||(function VU(t,n,e,r){const s=e.directiveStart,o=e.directiveEnd;t.firstCreatePass||Ff(e,n),_r(r,n);const i=e.initialInputs;for(let a=s;a<o;a++){const l=t.data[a],u=Js(l);u&&KU(n,e,l);const c=Il(n,t,a,e);_r(c,n),null!==i&&XU(0,a-s,c,l,0,i),u&&(ls(e.index,n)[8]=c)}}(t,n,e,as(e,n)),64==(64&e.flags)&&G1(t,n,e))}function Zv(t,n,e=as){const r=n.localNames;if(null!==r){let s=n.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?e(n,t):t[i];t[s++]=a}}}function z1(t){const n=t.tView;return null===n||n.incompleteFirstPass?t.tView=Qv(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):n}function Qv(t,n,e,r,s,o,i,a,l,u){const c=22+r,d=c+s,h=function $U(t,n){const e=[];for(let r=0;r<n;r++)e.push(r<t?null:it);return e}(c,d),f="function"==typeof u?u():u;return h[1]={type:t,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:n,data:h.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:f,incompleteFirstPass:!1}}function V1(t,n,e,r){const s=K1(n);null===e?s.push(r):(s.push(e),t.firstCreatePass&&X1(t).push(r,s.length-1))}function U1(t,n,e,r){for(let s in t)if(t.hasOwnProperty(s)){e=null===e?{}:e;const o=t[s];null===r?H1(e,n,s,o):r.hasOwnProperty(s)&&H1(e,n,r[s],o)}return e}function H1(t,n,e,r){t.hasOwnProperty(e)?t[e].push(n,r):t[e]=[n,r]}function W1(t,n){const e=ls(n,t);16&e[2]||(e[2]|=32)}function ex(t,n,e,r){let s=!1;if(SS()){const o=null===r?null:{"":-1},i=function HU(t,n){const e=t.directiveRegistry;let r=null,s=null;if(e)for(let o=0;o<e.length;o++){const i=e[o];if(p1(n,i.selectors,!1))if(r||(r=[]),Js(i))if(null!==i.findHostDirectiveDefs){const a=[];s=s||new Map,i.findHostDirectiveDefs(i,a,s),r.unshift(...a,i),tx(t,n,a.length)}else r.unshift(i),tx(t,n,0);else s=s||new Map,i.findHostDirectiveDefs?.(i,r,s),r.push(i)}return null===r?null:[r,s]}(t,e);let a,l;null===i?a=l=null:[a,l]=i,null!==a&&(s=!0,j1(t,n,e,a,o,l)),o&&function WU(t,n,e){if(n){const r=t.localNames=[];for(let s=0;s<n.length;s+=2){const o=e[n[s+1]];if(null==o)throw new xe(-301,!1);r.push(n[s],o)}}}(e,r,o)}return e.mergedAttrs=mc(e.mergedAttrs,e.attrs),s}function j1(t,n,e,r,s,o){for(let u=0;u<r.length;u++)jb(Ff(e,n),t,r[u].type);!function GU(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}(e,t.data.length,r.length);for(let u=0;u<r.length;u++){const c=r[u];c.providersResolver&&c.providersResolver(c)}let i=!1,a=!1,l=kc(t,n,r.length,null);for(let u=0;u<r.length;u++){const c=r[u];e.mergedAttrs=mc(e.mergedAttrs,c.hostAttrs),qU(t,e,n,l,c),jU(l,c,s),null!==c.contentQueries&&(e.flags|=4),(null!==c.hostBindings||null!==c.hostAttrs||0!==c.hostVars)&&(e.flags|=64);const d=c.type.prototype;!i&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(e.index),i=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(e.index),a=!0),l++}!function MU(t,n,e){const s=n.directiveEnd,o=t.data,i=n.attrs,a=[];let l=null,u=null;for(let c=n.directiveStart;c<s;c++){const d=o[c],h=e?e.get(d):null,p=h?h.outputs:null;l=U1(d.inputs,c,l,h?h.inputs:null),u=U1(d.outputs,c,u,p);const m=null===l||null===i||f1(n)?null:YU(l,c,i);a.push(m)}null!==l&&(l.hasOwnProperty("class")&&(n.flags|=8),l.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=l,n.outputs=u}(t,e,o)}function G1(t,n,e){const r=e.directiveStart,s=e.directiveEnd,o=e.index,i=function wz(){return nt.lFrame.currentDirectiveIndex}();try{Da(o);for(let a=r;a<s;a++){const l=t.data[a],u=n[a];Fb(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&UU(l,u)}}finally{Da(-1),Fb(i)}}function UU(t,n){null!==t.hostBindings&&t.hostBindings(1,n)}function tx(t,n,e){n.componentOffset=e,(t.components||(t.components=[])).push(n.index)}function jU(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;Js(n)&&(e[""]=t)}}function qU(t,n,e,r,s){t.data[r]=s;const o=s.factory||(s.factory=Ca(s.type)),i=new fc(o,Js(s),Ke);t.blueprint[r]=i,e[r]=i,function BU(t,n,e,r,s){const o=s.hostBindings;if(o){let i=t.hostBindingOpCodes;null===i&&(i=t.hostBindingOpCodes=[]);const a=~n.index;(function zU(t){let n=t.length;for(;n>0;){const e=t[--n];if("number"==typeof e&&e<0)return e}return 0})(i)!=a&&i.push(a),i.push(e,r,o)}}(t,n,r,kc(t,e,s.hostVars,it),s)}function KU(t,n,e){const r=as(n,t),s=z1(e),o=t[10],i=op(t,rp(t,s,null,e.onPush?32:16,r,n,o,o.createRenderer(r,e),null,null,null));t[n.index]=i}function XU(t,n,e,r,s,o){const i=o[n];if(null!==i){const a=r.setInput;for(let l=0;l<i.length;){const u=i[l++],c=i[l++],d=i[l++];null!==a?r.setInput(e,d,u,c):e[c]=d}}}function YU(t,n,e){let r=null,s=0;for(;s<e.length;){const o=e[s];if(0!==o)if(5!==o){if("number"==typeof o)break;if(t.hasOwnProperty(o)){null===r&&(r=[]);const i=t[o];for(let a=0;a<i.length;a+=2)if(i[a]===n){r.push(o,i[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function q1(t,n,e,r){return new Array(t,!0,!1,n,null,0,r,e,null,null)}function QU(t,n){const e=ls(n,t);if(Tf(e)){const r=e[1];48&e[2]?sp(r,e,r.template,e[8]):e[5]>0&&rx(e)}}function rx(t){for(let r=iv(t);null!==r;r=av(r))for(let s=10;s<r.length;s++){const o=r[s];if(Tf(o))if(512&o[2]){const i=o[1];sp(i,o,i.template,o[8])}else o[5]>0&&rx(o)}const e=t[1].components;if(null!==e)for(let r=0;r<e.length;r++){const s=ls(e[r],t);Tf(s)&&s[5]>0&&rx(s)}}function e4(t,n){const e=ls(n,t),r=e[1];(function t4(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])})(r,e),Xv(r,e,e[8])}function op(t,n){return t[13]?t[14][4]=n:t[13]=n,t[14]=n,n}function sx(t){for(;t;){t[2]|=32;const n=Dc(t);if(QB(t)&&!n)return t;t=n}return null}function ip(t,n,e,r=!0){const s=n[10];s.begin&&s.begin();try{sp(t,n,t.template,e)}catch(i){throw r&&J1(n,i),i}finally{s.end&&s.end()}}function ox(t,n,e){Mb(0),n(t,e)}function K1(t){return t[7]||(t[7]=[])}function X1(t){return t.cleanup||(t.cleanup=[])}function J1(t,n){const e=t[9],r=e?e.get(Fl,null):null;r&&r.handleError(n)}function ix(t,n,e,r,s){for(let o=0;o<e.length;){const i=e[o++],a=e[o++],l=n[i],u=t.data[i];null!==u.setInput?u.setInput(l,s,r,a):l[a]=s}}function ri(t,n,e){const r=function Nf(t,n){return On(n[t])}(n,t);!function IE(t,n,e){t.setValue(n,e)}(t[11],r,e)}function ap(t,n,e){let r=e?t.styles:null,s=e?t.classes:null,o=0;if(null!==n)for(let i=0;i<n.length;i++){const a=n[i];"number"==typeof a?o=a:1==o?s=fb(s,a):2==o&&(r=fb(r,a+": "+n[++i]+";"))}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=s:t.classesWithoutHost=s}function lp(t,n,e,r,s=!1){for(;null!==e;){const o=n[e.index];if(null!==o&&r.push(On(o)),Ys(o))for(let a=10;a<o.length;a++){const l=o[a],u=l[1].firstChild;null!==u&&lp(l[1],l,u,r)}const i=e.type;if(8&i)lp(t,n,e.child,r);else if(32&i){const a=ov(e,n);let l;for(;l=a();)r.push(l)}else if(16&i){const a=FE(n,e);if(Array.isArray(a))r.push(...a);else{const l=Dc(n[16]);lp(l[1],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Ac{constructor(n,e){this._lView=n,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const n=this._lView,e=n[1];return lp(e,n,e.firstChild,[])}get context(){return this._lView[8]}set context(n){this._lView[8]=n}get destroyed(){return 128==(128&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const n=this._lView[3];if(Ys(n)){const e=n[8],r=e?e.indexOf(this):-1;r>-1&&(cv(n,r),Lf(e,r))}this._attachedToViewContainer=!1}_E(this._lView[1],this._lView)}onDestroy(n){V1(this._lView[1],this._lView,null,n)}markForCheck(){sx(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-65}reattach(){this._lView[2]|=64}detectChanges(){ip(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new xe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function $3(t,n){_c(t,n,n[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new xe(902,!1);this._appRef=n}}class n4 extends Ac{constructor(n){super(n),this._view=n}detectChanges(){const n=this._view;ip(n[1],n,n[8],!1)}checkNoChanges(){}get context(){return null}}class ax extends Tc{constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){const e=Bt(n);return new Rc(e,this.ngModule)}}function Z1(t){const n=[];for(let e in t)t.hasOwnProperty(e)&&n.push({propName:t[e],templateName:e});return n}class s4{constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){r=wf(r);const s=this.injector.get(n,kv,r);return s!==kv||e===kv?s:this.parentInjector.get(n,e,r)}}class Rc extends a1{constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=function eU(t){return t.map(QV).join(",")}(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return Z1(this.componentDef.inputs)}get outputs(){return Z1(this.componentDef.outputs)}create(n,e,r,s){let o=(s=s||this.ngModule)instanceof ei?s:s?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const i=o?new s4(n,o):n,a=i.get(u1,null);if(null===a)throw new xe(407,!1);const l=i.get($V,null),u=a.createRenderer(null,this.componentDef),c=this.componentDef.selectors[0][0]||"div",d=r?function FU(t,n,e){return t.selectRootElement(n,e===xo.ShadowDom)}(u,r,this.componentDef.encapsulation):uv(u,c,function r4(t){const n=t.toLowerCase();return"svg"===n?"svg":"math"===n?"math":null}(c)),h=this.componentDef.onPush?288:272,f=Qv(0,null,null,1,0,null,null,null,null,null),p=rp(null,f,null,h,null,null,a,u,l,i,null);let m,g;Pb(p);try{const y=this.componentDef;let b,v=null;y.findHostDirectiveDefs?(b=[],v=new Map,y.findHostDirectiveDefs(y,b,v),b.push(y)):b=[y];const x=function a4(t,n){const e=t[1];return t[22]=n,Pl(e,22,2,"#host",null)}(p,d),w=function l4(t,n,e,r,s,o,i,a){const l=s[1];!function u4(t,n,e,r){for(const s of t)n.mergedAttrs=mc(n.mergedAttrs,s.hostAttrs);null!==n.mergedAttrs&&(ap(n,n.mergedAttrs,!0),null!==e&&PE(r,e,n))}(r,t,n,i);const u=o.createRenderer(n,e),c=rp(s,z1(e),null,e.onPush?32:16,s[t.index],t,o,u,a||null,null,null);return l.firstCreatePass&&tx(l,t,r.length-1),op(s,c),s[t.index]=c}(x,d,y,b,p,a,u);g=kb(f,22),d&&function d4(t,n,e,r){if(r)Vb(t,e,["ng-version",FV.full]);else{const{attrs:s,classes:o}=function tU(t){const n=[],e=[];let r=1,s=2;for(;r<t.length;){let o=t[r];if("string"==typeof o)2===s?""!==o&&n.push(o,t[++r]):8===s&&e.push(o);else{if(!eo(s))break;s=o}r++}return{attrs:n,classes:e}}(n.selectors[0]);s&&Vb(t,e,s),o&&o.length>0&&ME(t,e,o.join(" "))}}(u,y,d,r),void 0!==e&&function h4(t,n,e){const r=t.projection=[];for(let s=0;s<n.length;s++){const o=e[s];r.push(null!=o?Array.from(o):null)}}(g,this.ngContentSelectors,e),m=function c4(t,n,e,r,s,o){const i=yr(),a=s[1],l=as(i,s);j1(a,s,i,e,null,r);for(let c=0;c<e.length;c++)_r(Il(s,a,i.directiveStart+c,i),s);G1(a,s,i),l&&_r(l,s);const u=Il(s,a,i.directiveStart+i.componentOffset,i);if(t[8]=s[8]=u,null!==o)for(const c of o)c(u,n);return Yv(a,i,t),u}(w,y,b,v,p,[f4]),Xv(f,p,null)}finally{Lb()}return new i4(this.componentType,m,$l(g,p),p,g)}}class i4 extends EV{constructor(n,e,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.instance=e,this.hostView=this.changeDetectorRef=new n4(s),this.componentType=n}setInput(n,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[n])){const o=this._rootLView;ix(o[1],o,s,n,e),W1(o,this._tNode.index)}}get injector(){return new Dl(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}}function f4(){const t=yr();kf(oe()[1],t)}let up=null;function Ta(){if(!up){const t=Qt.Symbol;if(t&&t.iterator)up=t.iterator;else{const n=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<n.length;++e){const r=n[e];"entries"!==r&&"size"!==r&&Map.prototype[r]===Map.prototype.entries&&(up=r)}}}return up}function $c(t){return!!function ux(t){return null!==t&&("function"==typeof t||"object"==typeof t)}(t)&&(Array.isArray(t)||!(t instanceof Map)&&Ta()in t)}function Sr(t,n,e){return!Object.is(t[n],e)&&(t[n]=e,!0)}function Es(t,n,e,r,s,o,i,a){const l=oe(),u=Tt(),c=t+22,d=u.firstCreatePass?function E4(t,n,e,r,s,o,i,a,l){const u=n.consts,c=Pl(n,t,4,i||null,Ri(u,a));ex(n,e,c,Ri(u,l)),kf(n,c);const d=c.tViews=Qv(2,c,r,s,o,n.directiveRegistry,n.pipeRegistry,null,n.schemas,u);return null!==n.queries&&(n.queries.template(n,c),d.queries=n.queries.embeddedTView(c)),c}(c,u,l,n,e,r,s,o,i):u.data[c];wo(d,!1);const h=l[11].createComment("");Hf(u,l,h,d),_r(h,l),op(l,l[c]=q1(h,l,h,d)),Ef(d)&&Jv(u,l,d),null!=i&&Zv(l,d,a)}function hs(t,n,e){const r=oe();return Sr(r,xl(),n)&&function ds(t,n,e,r,s,o,i,a){const l=as(n,e);let c,u=n.inputs;!a&&null!=u&&(c=u[r])?(ix(t,e,c,r,s),Sf(n)&&W1(e,n.index)):3&n.type&&(r=function PU(t){return"class"===t?"className":"for"===t?"htmlFor":"formaction"===t?"formAction":"innerHtml"===t?"innerHTML":"readonly"===t?"readOnly":"tabindex"===t?"tabIndex":t}(r),s=null!=i?i(s,n.value||"",r):s,o.setProperty(l,r,s))}(Tt(),function fn(){const t=nt.lFrame;return kb(t.tView,t.selectedIndex)}(),r,t,n,r[11],e,!1),hs}function dx(t,n,e,r,s){const i=s?"class":"style";ix(t,e,n.inputs[i],i,r)}function Je(t,n,e,r){const s=oe(),o=Tt(),i=22+t,a=s[11],l=s[i]=uv(a,n,function Tz(){return nt.lFrame.currentNamespace}()),u=o.firstCreatePass?function k4(t,n,e,r,s,o,i){const a=n.consts,u=Pl(n,t,2,s,Ri(a,o));return ex(n,e,u,Ri(a,i)),null!==u.attrs&&ap(u,u.attrs,!1),null!==u.mergedAttrs&&ap(u,u.mergedAttrs,!0),null!==n.queries&&n.queries.elementStart(n,u),u}(i,o,s,0,n,e,r):o.data[i];return wo(u,!0),PE(a,l,u),32!=(32&u.flags)&&Hf(o,s,l,u),0===function fz(){return nt.lFrame.elementDepthCount}()&&_r(l,s),function pz(){nt.lFrame.elementDepthCount++}(),Ef(u)&&(Jv(o,s,u),Yv(o,u,s)),null!==r&&Zv(s,u),Je}function Ze(){let t=yr();Rb()?function $b(){nt.lFrame.isParent=!1}():(t=t.parent,wo(t,!1));const n=t;!function mz(){nt.lFrame.elementDepthCount--}();const e=Tt();return e.firstCreatePass&&(kf(e,t),_b(t)&&e.queries.elementEnd(t)),null!=n.classesWithoutHost&&function Fz(t){return 0!=(8&t.flags)}(n)&&dx(e,n,oe(),n.classesWithoutHost,!0),null!=n.stylesWithoutHost&&function Oz(t){return 0!=(16&t.flags)}(n)&&dx(e,n,oe(),n.stylesWithoutHost,!1),Ze}function qn(t,n,e,r){return Je(t,n,e,r),Ze(),qn}function ql(){return oe()}function dp(t){return!!t&&"function"==typeof t.then}const mN=function pN(t){return!!t&&"function"==typeof t.subscribe};function br(t,n,e,r){const s=oe(),o=Tt(),i=yr();return function yN(t,n,e,r,s,o,i,a){const l=Ef(r),c=t.firstCreatePass&&X1(t),d=n[8],h=K1(n);let f=!0;if(3&r.type||a){const g=as(r,n),y=a?a(g):g,b=h.length,v=a?w=>a(On(w[r.index])):r.index;let x=null;if(!a&&l&&(x=function R4(t,n,e,r){const s=t.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===e&&s[o+1]===r){const a=n[7],l=s[o+2];return a.length>l?a[l]:null}"string"==typeof i&&(o+=2)}return null}(t,n,s,r.index)),null!==x)(x.__ngLastListenerFn__||x).__ngNextListenerFn__=o,x.__ngLastListenerFn__=o,f=!1;else{o=vN(r,n,d,o,!1);const w=e.listen(y,s,o);h.push(o,w),c&&c.push(s,v,b,b+1)}}else o=vN(r,n,d,o,!1);const p=r.outputs;let m;if(f&&null!==p&&(m=p[s])){const g=m.length;if(g)for(let y=0;y<g;y+=2){const _=n[m[y]][m[y+1]].subscribe(o),D=h.length;h.push(o,_),c&&c.push(s,r.index,D,-(D+1))}}}(o,s,s[11],i,t,n,0,r),br}function bN(t,n,e,r){try{return!1!==e(r)}catch(s){return J1(t,s),!1}}function vN(t,n,e,r,s){return function o(i){if(i===Function)return r;sx(t.componentOffset>-1?ls(t.index,n):n);let l=bN(n,0,r,i),u=o.__ngNextListenerFn__;for(;u;)l=bN(n,0,u,i)&&l,u=u.__ngNextListenerFn__;return s&&!1===l&&(i.preventDefault(),i.returnValue=!1),l}}function Er(t=1){return function Iz(t){return(nt.lFrame.contextLView=function Dz(t,n){for(;t>0;)n=n[15],t--;return n}(t,nt.lFrame.contextLView))[8]}(t)}function _t(t,n=""){const e=oe(),r=Tt(),s=t+22,o=r.firstCreatePass?Pl(r,s,1,n,null):r.data[s],i=e[s]=function lv(t,n){return t.createText(n)}(e[11],n);Hf(r,e,i,o),wo(o,!1)}function Eo(t){return fp("",t,""),Eo}function fp(t,n,e){const r=oe(),s=function Bl(t,n,e,r){return Sr(t,xl(),e)?n+ot(e)+r:it}(r,t,n,e);return s!==it&&ri(r,Pr(),s),fp}const Yl="en-US";let dT=Yl;class Ra{}class PT{}class LT extends Ra{constructor(n,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new ax(this);const r=os(n);this._bootstrapComponents=ti(r.bootstrap),this._r3Injector=w1(n,e,[{provide:Ra,useValue:this},{provide:Tc,useValue:this.componentFactoryResolver}],Xt(n),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(n)}get injector(){return this._r3Injector}destroy(){const n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}}class Cx extends PT{constructor(n){super(),this.moduleType=n}create(n){return new LT(this.moduleType,n)}}class xW extends Ra{constructor(n,e,r){super(),this.componentFactoryResolver=new ax(this),this.instance=null;const s=new o1([...n,{provide:Ra,useValue:this},{provide:Tc,useValue:this.componentFactoryResolver}],e||Yf(),r,new Set(["environment"]));this.injector=s,s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}}function bp(t,n,e=null){return new xW(t,n,e).injector}let wW=(()=>{class t{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=t1(0,e.type),s=r.length>0?bp([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return t.\u0275prov=tt({token:t,providedIn:"environment",factory:()=>new t($e(ei))}),t})();function BT(t){t.getStandaloneInjector=n=>n.get(wW).getOrCreateStandaloneInjector(t)}function Dx(t){return n=>{setTimeout(t,void 0,n)}}const Nr=class qW extends Wo{constructor(n=!1){super(),this.__isAsync=n}emit(n){super.next(n)}subscribe(n,e,r){let s=n,o=e||(()=>null),i=r;if(n&&"object"==typeof n){const l=n;s=l.next?.bind(l),o=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(o=Dx(o),s&&(s=Dx(s)),i&&(i=Dx(i)));const a=super.subscribe({next:s,error:o,complete:i});return n instanceof He&&n.add(a),a}};function KW(){return this._results[Ta()]()}class _x{constructor(n=!1){this._emitDistinctChangesOnly=n,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Ta(),r=_x.prototype;r[e]||(r[e]=KW)}get changes(){return this._changes||(this._changes=new Nr)}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){const r=this;r.dirty=!1;const s=us(n);(this._changesDetected=!function Gz(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let s=t[r],o=n[r];if(e&&(s=e(s),o=e(o)),o!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let si=(()=>{class t{}return t.__NG_ELEMENT_ID__=JW,t})();const XW=si,YW=class extends XW{constructor(n,e,r){super(),this._declarationLView=n,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(n,e){const r=this._declarationTContainer.tViews,s=rp(this._declarationLView,r,n,16,null,r.declTNode,null,null,null,null,e||null);s[17]=this._declarationLView[this._declarationTContainer.index];const i=this._declarationLView[19];return null!==i&&(s[19]=i.createEmbeddedView(r)),Xv(r,s,n),new Ac(s)}};function JW(){return vp(yr(),oe())}function vp(t,n){return 4&t.type?new YW(n,t,$l(t,n)):null}let oo=(()=>{class t{}return t.__NG_ELEMENT_ID__=ZW,t})();function ZW(){return QT(yr(),oe())}const QW=oo,JT=class extends QW{constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return $l(this._hostTNode,this._hostLView)}get injector(){return new Dl(this._hostTNode,this._hostLView)}get parentInjector(){const n=Of(this._hostTNode,this._hostLView);if(VS(n)){const e=Cl(n,this._hostLView),r=wl(n);return new Dl(e[1].data[r+8],e)}return new Dl(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){const e=ZT(this._lContainer);return null!==e&&e[n]||null}get length(){return this._lContainer.length-10}createEmbeddedView(n,e,r){let s,o;"number"==typeof r?s=r:null!=r&&(s=r.index,o=r.injector);const i=n.createEmbeddedView(e||{},o);return this.insert(i,s),i}createComponent(n,e,r,s,o){const i=n&&!function yc(t){return"function"==typeof t}(n);let a;if(i)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,o=d.environmentInjector||d.ngModuleRef}const l=i?n:new Rc(Bt(n)),u=r||this.parentInjector;if(!o&&null==l.ngModule){const h=(i?u:this.parentInjector).get(ei,null);h&&(o=h)}const c=l.create(u,s,void 0,o);return this.insert(c.hostView,a),c}insert(n,e){const r=n._lView,s=r[1];if(function hz(t){return Ys(t[3])}(r)){const c=this.indexOf(n);if(-1!==c)this.detach(c);else{const d=r[3],h=new JT(d,d[6],d[3]);h.detach(h.indexOf(n))}}const o=this._adjustIndex(e),i=this._lContainer;!function O3(t,n,e,r){const s=10+r,o=e.length;r>0&&(e[s-1][4]=n),r<o-10?(n[4]=e[s],ZS(e,10+r,n)):(e.push(n),n[4]=null),n[3]=e;const i=n[17];null!==i&&e!==i&&function M3(t,n){const e=t[9];n[16]!==n[3][3][16]&&(t[2]=!0),null===e?t[9]=[n]:e.push(n)}(i,n);const a=n[19];null!==a&&a.insertView(t),n[2]|=64}(s,r,i,o);const a=fv(o,i),l=r[11],u=Uf(l,i[7]);return null!==u&&function R3(t,n,e,r,s,o){r[0]=s,r[6]=n,_c(t,r,e,1,s,o)}(s,i[6],l,r,u,a),n.attachToViewContainerRef(),ZS(Sx(i),o,n),n}move(n,e){return this.insert(n,e)}indexOf(n){const e=ZT(this._lContainer);return null!==e?e.indexOf(n):-1}remove(n){const e=this._adjustIndex(n,-1),r=cv(this._lContainer,e);r&&(Lf(Sx(this._lContainer),e),_E(r[1],r))}detach(n){const e=this._adjustIndex(n,-1),r=cv(this._lContainer,e);return r&&null!=Lf(Sx(this._lContainer),e)?new Ac(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function ZT(t){return t[8]}function Sx(t){return t[8]||(t[8]=[])}function QT(t,n){let e;const r=n[t.index];if(Ys(r))e=r;else{let s;if(8&t.type)s=On(r);else{const o=n[11];s=o.createComment("");const i=as(t,n);Sa(o,Uf(o,i),s,function z3(t,n){return t.nextSibling(n)}(o,i),!1)}n[t.index]=e=q1(r,n,s,t),op(n,e)}return new JT(e,t,n)}class Ex{constructor(n){this.queryList=n,this.matches=null}clone(){return new Ex(this.queryList)}setDirty(){this.queryList.setDirty()}}class Nx{constructor(n=[]){this.queries=n}createEmbeddedView(n){const e=n.queries;if(null!==e){const r=null!==n.contentQueries?n.contentQueries[0]:e.length,s=[];for(let o=0;o<r;o++){const i=e.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new Nx(s)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)null!==ok(n,e).matches&&this.queries[e].setDirty()}}class ek{constructor(n,e,r=null){this.predicate=n,this.flags=e,this.read=r}}class Tx{constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(n,s);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new Tx(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}}class kx{constructor(n,e=-1){this.metadata=n,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new kx(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=n.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(n,e,nj(e,o)),this.matchTNodeWithReadOption(n,e,Mf(e,n,o,!1,!1))}else r===si?4&e.type&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,Mf(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===Oi||s===oo||s===si&&4&e.type)this.addMatch(e.index,-2);else{const o=Mf(e,n,s,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(n,e){null===this.matches?this.matches=[n,e]:this.matches.push(n,e)}}function nj(t,n){const e=t.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1];return null}function sj(t,n,e,r){return-1===e?function rj(t,n){return 11&t.type?$l(t,n):4&t.type?vp(t,n):null}(n,t):-2===e?function oj(t,n,e){return e===Oi?$l(n,t):e===si?vp(n,t):e===oo?QT(n,t):void 0}(t,n,r):Il(t,t[1],e,n)}function tk(t,n,e,r){const s=n[19].queries[r];if(null===s.matches){const o=t.data,i=e.matches,a=[];for(let l=0;l<i.length;l+=2){const u=i[l];a.push(u<0?null:sj(n,o[u],i[l+1],e.metadata.read))}s.matches=a}return s.matches}function Ax(t,n,e,r){const s=t.queries.getByIndex(e),o=s.matches;if(null!==o){const i=tk(t,n,s,e);for(let a=0;a<o.length;a+=2){const l=o[a];if(l>0)r.push(i[a/2]);else{const u=o[a+1],c=n[-l];for(let d=10;d<c.length;d++){const h=c[d];h[17]===h[3]&&Ax(h[1],h,u,r)}if(null!==c[9]){const d=c[9];for(let h=0;h<d.length;h++){const f=d[h];Ax(f[1],f,u,r)}}}}}return r}function xp(t){const n=oe(),e=Tt(),r=AS();Mb(r+1);const s=ok(e,r);if(t.dirty&&function dz(t){return 4==(4&t[2])}(n)===(2==(2&s.metadata.flags))){if(null===s.matches)t.reset([]);else{const o=s.crossesNgTemplate?Ax(e,n,r,[]):tk(e,n,s,r);t.reset(o,AV),t.notifyOnChanges()}return!0}return!1}function Rx(t,n,e){const r=Tt();r.firstCreatePass&&(function sk(t,n,e){null===t.queries&&(t.queries=new Tx),t.queries.track(new kx(n,e))}(r,new ek(t,n,e),-1),2==(2&n)&&(r.staticViewQueries=!0)),function rk(t,n,e){const r=new _x(4==(4&e));V1(t,n,r,r.destroy),null===n[19]&&(n[19]=new Nx),n[19].queries.push(new Ex(r))}(r,oe(),n)}function wp(){return function ij(t,n){return t[19].queries[n].queryList}(oe(),AS())}function ok(t,n){return t.queries.getByIndex(n)}function Ip(...t){}const Dp=new Me("Application Initializer");let _p=(()=>{class t{constructor(e){this.appInits=e,this.resolve=Ip,this.reject=Ip,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const o=this.appInits[s]();if(dp(o))e.push(o);else if(mN(o)){const i=new Promise((a,l)=>{o.subscribe({complete:a,error:l})});e.push(i)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)($e(Dp,8))},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Wc=new Me("AppId",{providedIn:"root",factory:function Dk(){return`${Px()}${Px()}${Px()}`}});function Px(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const _k=new Me("Platform Initializer"),Lx=new Me("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),Sk=new Me("appBootstrapListener");let Nj=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();const oi=new Me("LocaleId",{providedIn:"root",factory:()=>$t(oi,qe.Optional|qe.SkipSelf)||function Tj(){return typeof $localize<"u"&&$localize.locale||Yl}()});class Aj{constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}}let Bx=(()=>{class t{compileModuleSync(e){return new Cx(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),o=ti(os(e).declarations).reduce((i,a)=>{const l=Bt(a);return l&&i.push(new Rc(l)),i},[]);return new Aj(r,o)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Fj=(()=>Promise.resolve(0))();function zx(t){typeof Zone>"u"?Fj.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class Pn{constructor({enableLongStackTrace:n=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Nr(!1),this.onMicrotaskEmpty=new Nr(!1),this.onStable=new Nr(!1),this.onError=new Nr(!1),typeof Zone>"u")throw new xe(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),n&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function Oj(){let t=Qt.requestAnimationFrame,n=Qt.cancelAnimationFrame;if(typeof Zone<"u"&&t&&n){const e=t[Zone.__symbol__("OriginalDelegate")];e&&(t=e);const r=n[Zone.__symbol__("OriginalDelegate")];r&&(n=r)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:n}}().nativeRequestAnimationFrame,function Lj(t){const n=()=>{!function Pj(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(Qt,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,Ux(t),t.isCheckStableRunning=!0,Vx(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),Ux(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,o,i,a)=>{try{return Tk(t),e.invokeTask(s,o,i,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||t.shouldCoalesceRunChangeDetection)&&n(),kk(t)}},onInvoke:(e,r,s,o,i,a,l)=>{try{return Tk(t),e.invoke(s,o,i,a,l)}finally{t.shouldCoalesceRunChangeDetection&&n(),kk(t)}},onHasTask:(e,r,s,o)=>{e.hasTask(s,o),r===s&&("microTask"==o.change?(t._hasPendingMicrotasks=o.microTask,Ux(t),Vx(t)):"macroTask"==o.change&&(t.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,s,o)=>(e.handleError(s,o),t.runOutsideAngular(()=>t.onError.emit(o)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Pn.isInAngularZone())throw new xe(909,!1)}static assertNotInAngularZone(){if(Pn.isInAngularZone())throw new xe(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,n,Mj,Ip,Ip);try{return o.runTask(i,e,r)}finally{o.cancelTask(i)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}}const Mj={};function Vx(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function Ux(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function Tk(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function kk(t){t._nesting--,Vx(t)}class Bj{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Nr,this.onMicrotaskEmpty=new Nr,this.onStable=new Nr,this.onError=new Nr}run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,s){return n.apply(e,r)}}const Ak=new Me(""),Sp=new Me("");let jx,Hx=(()=>{class t{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,jx||(function zj(t){jx=t}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Pn.assertNotInAngularZone(),zx(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())zx(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(i=>i.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return t.\u0275fac=function(e){return new(e||t)($e(Pn),$e(Wx),$e(Sp))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})(),Wx=(()=>{class t{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return jx?.findTestabilityInTree(this,e,r)??null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})(),Li=null;const Rk=new Me("AllowMultipleToken"),Gx=new Me("PlatformDestroyListeners");class $k{constructor(n,e){this.name=n,this.token=e}}function Ok(t,n,e=[]){const r=`Platform: ${n}`,s=new Me(r);return(o=[])=>{let i=qx();if(!i||i.injector.get(Rk,!1)){const a=[...e,...o,{provide:s,useValue:!0}];t?t(a):function Hj(t){if(Li&&!Li.get(Rk,!1))throw new xe(400,!1);Li=t;const n=t.get(Pk);(function Fk(t){const n=t.get(_k,null);n&&n.forEach(e=>e())})(t)}(function Mk(t=[],n){return to.create({name:n,providers:[{provide:Sv,useValue:"platform"},{provide:Gx,useValue:new Set([()=>Li=null])},...t]})}(a,r))}return function jj(t){const n=qx();if(!n)throw new xe(401,!1);return n}()}}function qx(){return Li?.get(Pk)??null}let Pk=(()=>{class t{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function Bk(t,n){let e;return e="noop"===t?new Bj:("zone.js"===t?void 0:t)||new Pn(n),e}(r?.ngZone,function Lk(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!t||!t.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!t||!t.ngZoneRunCoalescing)||!1}}(r)),o=[{provide:Pn,useValue:s}];return s.run(()=>{const i=to.create({providers:o,parent:this.injector,name:e.moduleType.name}),a=e.create(i),l=a.injector.get(Fl,null);if(!l)throw new xe(402,!1);return s.runOutsideAngular(()=>{const u=s.onError.subscribe({next:c=>{l.handleError(c)}});a.onDestroy(()=>{Np(this._modules,a),u.unsubscribe()})}),function zk(t,n,e){try{const r=e();return dp(r)?r.catch(s=>{throw n.runOutsideAngular(()=>t.handleError(s)),s}):r}catch(r){throw n.runOutsideAngular(()=>t.handleError(r)),r}}(l,s,()=>{const u=a.injector.get(_p);return u.runInitializers(),u.donePromise.then(()=>(function hT(t){ss(t,"Expected localeId to be defined"),"string"==typeof t&&(dT=t.toLowerCase().replace(/_/g,"-"))}(a.injector.get(oi,Yl)||Yl),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=Vk({},r);return function Vj(t,n,e){const r=new Cx(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,s))}_moduleDoBootstrap(e){const r=e.injector.get(Ep);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new xe(403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new xe(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(Gx,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)($e(to))},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();function Vk(t,n){return Array.isArray(n)?n.reduce(Vk,t):{...t,...n}}let Ep=(()=>{class t{constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new Fn(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),i=new Fn(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{Pn.assertNotInAngularZone(),zx(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const u=this._zone.onUnstable.subscribe(()=>{Pn.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),u.unsubscribe()}});this.isStable=function EB(...t){const n=rc(t),e=function xB(t,n){return"number"==typeof cb(t)?t.pop():n}(t,1/0),r=t;return r.length?1===r.length?vo(r[0]):fl(e)(jn(r,n)):Go}(o,i.pipe(function NB(t={}){const{connector:n=(()=>new Wo),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=t;return o=>{let i,a,l,u=0,c=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},f=()=>{h(),i=l=void 0,c=d=!1},p=()=>{const m=i;f(),m?.unsubscribe()};return or((m,g)=>{u++,!d&&!c&&h();const y=l=l??n();g.add(()=>{u--,0===u&&!d&&!c&&(a=db(p,s))}),y.subscribe(g),!i&&u>0&&(i=new nc({next:b=>y.next(b),error:b=>{d=!0,h(),a=db(f,e,b),y.error(b)},complete:()=>{c=!0,h(),a=db(f,r),y.complete()}}),vo(m).subscribe(i))})(o)}}()))}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const s=e instanceof a1;if(!this._injector.get(_p).done)throw!s&&function ml(t){const n=Bt(t)||Cr(t)||Or(t);return null!==n&&n.standalone}(e),new xe(405,false);let i;i=s?e:this._injector.get(Tc).resolveComponentFactory(e),this.componentTypes.push(i.componentType);const a=function Uj(t){return t.isBoundToModule}(i)?void 0:this._injector.get(Ra),u=i.create(to.NULL,[],r||i.selector,a),c=u.location.nativeElement,d=u.injector.get(Ak,null);return d?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),Np(this.components,u),d?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){if(this._runningTick)throw new xe(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;Np(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(Sk,[]).concat(this._bootstrapListeners).forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>Np(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new xe(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return t.\u0275fac=function(e){return new(e||t)($e(Pn),$e(ei),$e(Fl))},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function Np(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}let Kx=(()=>{class t{}return t.__NG_ELEMENT_ID__=qj,t})();function qj(t){return function Kj(t,n,e){if(Sf(t)&&!e){const r=ls(t.index,n);return new Ac(r,r)}return 47&t.type?new Ac(n[16],n):null}(yr(),oe(),16==(16&t))}class Gk{constructor(){}supports(n){return $c(n)}create(n){return new eG(n)}}const Qj=(t,n)=>n;class eG{constructor(n){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=n||Qj}forEachItem(n){let e;for(e=this._itHead;null!==e;e=e._next)n(e)}forEachOperation(n){let e=this._itHead,r=this._removalsHead,s=0,o=null;for(;e||r;){const i=!r||e&&e.currentIndex<Kk(r,s,o)?e:r,a=Kk(i,s,o),l=i.currentIndex;if(i===r)s--,r=r._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{o||(o=[]);const u=a-s,c=l-s;if(u!=c){for(let h=0;h<u;h++){const f=h<o.length?o[h]:o[h]=0,p=f+h;c<=p&&p<u&&(o[h]=f+1)}o[i.previousIndex]=c-u}}a!==l&&n(i,a,l)}}forEachPreviousItem(n){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)n(e)}forEachAddedItem(n){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)n(e)}forEachMovedItem(n){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)n(e)}forEachRemovedItem(n){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)n(e)}forEachIdentityChange(n){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)n(e)}diff(n){if(null==n&&(n=[]),!$c(n))throw new xe(900,!1);return this.check(n)?this:null}onDestroy(){}check(n){this._reset();let s,o,i,e=this._itHead,r=!1;if(Array.isArray(n)){this.length=n.length;for(let a=0;a<this.length;a++)o=n[a],i=this._trackByFn(a,o),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,o,i,a)),Object.is(e.item,o)||this._addIdentityChange(e,o)):(e=this._mismatch(e,o,i,a),r=!0),e=e._next}else s=0,function D4(t,n){if(Array.isArray(t))for(let e=0;e<t.length;e++)n(t[e]);else{const e=t[Ta()]();let r;for(;!(r=e.next()).done;)n(r.value)}}(n,a=>{i=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,a,i,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,i,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=n,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let n;for(n=this._previousItHead=this._itHead;null!==n;n=n._next)n._nextPrevious=n._next;for(n=this._additionsHead;null!==n;n=n._nextAdded)n.previousIndex=n.currentIndex;for(this._additionsHead=this._additionsTail=null,n=this._movesHead;null!==n;n=n._nextMoved)n.previousIndex=n.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(n,e,r,s){let o;return null===n?o=this._itTail:(o=n._prev,this._remove(n)),null!==(n=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(n.item,e)||this._addIdentityChange(n,e),this._reinsertAfter(n,o,s)):null!==(n=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(n.item,e)||this._addIdentityChange(n,e),this._moveAfter(n,o,s)):n=this._addAfter(new tG(e,r),o,s),n}_verifyReinsertion(n,e,r,s){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?n=this._reinsertAfter(o,n._prev,s):n.currentIndex!=s&&(n.currentIndex=s,this._addToMoves(n,s)),n}_truncate(n){for(;null!==n;){const e=n._next;this._addToRemovals(this._unlink(n)),n=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(n,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(n);const s=n._prevRemoved,o=n._nextRemoved;return null===s?this._removalsHead=o:s._nextRemoved=o,null===o?this._removalsTail=s:o._prevRemoved=s,this._insertAfter(n,e,r),this._addToMoves(n,r),n}_moveAfter(n,e,r){return this._unlink(n),this._insertAfter(n,e,r),this._addToMoves(n,r),n}_addAfter(n,e,r){return this._insertAfter(n,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=n:this._additionsTail._nextAdded=n,n}_insertAfter(n,e,r){const s=null===e?this._itHead:e._next;return n._next=s,n._prev=e,null===s?this._itTail=n:s._prev=n,null===e?this._itHead=n:e._next=n,null===this._linkedRecords&&(this._linkedRecords=new qk),this._linkedRecords.put(n),n.currentIndex=r,n}_remove(n){return this._addToRemovals(this._unlink(n))}_unlink(n){null!==this._linkedRecords&&this._linkedRecords.remove(n);const e=n._prev,r=n._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,n}_addToMoves(n,e){return n.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=n:this._movesTail._nextMoved=n),n}_addToRemovals(n){return null===this._unlinkedRecords&&(this._unlinkedRecords=new qk),this._unlinkedRecords.put(n),n.currentIndex=null,n._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=n,n._prevRemoved=null):(n._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=n),n}_addIdentityChange(n,e){return n.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=n:this._identityChangesTail._nextIdentityChange=n,n}}class tG{constructor(n,e){this.item=n,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class nG{constructor(){this._head=null,this._tail=null}add(n){null===this._head?(this._head=this._tail=n,n._nextDup=null,n._prevDup=null):(this._tail._nextDup=n,n._prevDup=this._tail,n._nextDup=null,this._tail=n)}get(n,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,n))return r;return null}remove(n){const e=n._prevDup,r=n._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class qk{constructor(){this.map=new Map}put(n){const e=n.trackById;let r=this.map.get(e);r||(r=new nG,this.map.set(e,r)),r.add(n)}get(n,e){const s=this.map.get(n);return s?s.get(n,e):null}remove(n){const e=n.trackById;return this.map.get(e).remove(n)&&this.map.delete(e),n}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function Kk(t,n,e){const r=t.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+n+s}function Yk(){return new Ap([new Gk])}let Ap=(()=>{class t{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new t(e)}static extend(e){return{provide:t,useFactory:r=>t.create(e,r||Yk()),deps:[[t,new xc,new vc]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new xe(901,!1)}}return t.\u0275prov=tt({token:t,providedIn:"root",factory:Yk}),t})();const aG=Ok(null,"core",[]);let lG=(()=>{class t{constructor(e){}}return t.\u0275fac=function(e){return new(e||t)($e(Ep))},t.\u0275mod=Ai({type:t}),t.\u0275inj=Ko({}),t})(),Rp=null;function Bi(){return Rp}class dG{}const Vr=new Me("DocumentToken");let ew=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:function(){return function hG(){return $e(Zk)}()},providedIn:"platform"}),t})();const fG=new Me("Location Initialized");let Zk=(()=>{class t extends ew{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Bi().getBaseHref(this._doc)}onPopState(e){const r=Bi().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=Bi().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,r,s){Qk()?this._history.pushState(e,r,s):this.location.hash=s}replaceState(e,r,s){Qk()?this._history.replaceState(e,r,s):this.location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)($e(Vr))},t.\u0275prov=tt({token:t,factory:function(){return function pG(){return new Zk($e(Vr))}()},providedIn:"platform"}),t})();function Qk(){return!!window.history.pushState}function tw(t,n){if(0==t.length)return n;if(0==n.length)return t;let e=0;return t.endsWith("/")&&e++,n.startsWith("/")&&e++,2==e?t+n.substring(1):1==e?t+n:t+"/"+n}function eA(t){const n=t.match(/#|\?|$/),e=n&&n.index||t.length;return t.slice(0,e-("/"===t[e-1]?1:0))+t.slice(e)}function ai(t){return t&&"?"!==t[0]?"?"+t:t}let Fa=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:function(){return $t(nA)},providedIn:"root"}),t})();const tA=new Me("appBaseHref");let nA=(()=>{class t extends Fa{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??$t(Vr).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return tw(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+ai(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,o){const i=this.prepareExternalUrl(s+ai(o));this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){const i=this.prepareExternalUrl(s+ai(o));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)($e(ew),$e(tA,8))},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),mG=(()=>{class t extends Fa{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=tw(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,o){let i=this.prepareExternalUrl(s+ai(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){let i=this.prepareExternalUrl(s+ai(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)($e(ew),$e(tA,8))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})(),nw=(()=>{class t{constructor(e){this._subject=new Nr,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._baseHref=eA(rA(r)),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+ai(r))}normalize(e){return t.stripTrailingSlash(function yG(t,n){return t&&n.startsWith(t)?n.substring(t.length):n}(this._baseHref,rA(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+ai(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+ai(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return t.normalizeQueryParams=ai,t.joinWithSlash=tw,t.stripTrailingSlash=eA,t.\u0275fac=function(e){return new(e||t)($e(Fa))},t.\u0275prov=tt({token:t,factory:function(){return function gG(){return new nw($e(Fa))}()},providedIn:"root"}),t})();function rA(t){return t.replace(/\/index.html$/,"")}function hA(t,n){n=encodeURIComponent(n);for(const e of t.split(";")){const r=e.indexOf("="),[s,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===n)return decodeURIComponent(o)}return null}class n6{constructor(n,e,r,s){this.$implicit=n,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let mA=(()=>{class t{constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,o,i)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new n6(s.item,this._ngForOf,-1,-1),null===i?void 0:i);else if(null==i)r.remove(null===o?void 0:o);else if(null!==o){const a=r.get(o);r.move(a,i),gA(a,s)}});for(let s=0,o=r.length;s<o;s++){const a=r.get(s).context;a.index=s,a.count=o,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{gA(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Ke(oo),Ke(si),Ke(Ap))},t.\u0275dir=Fr({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),t})();function gA(t,n){t.context.$implicit=n.item}let hw=(()=>{class t{constructor(e,r){this._viewContainer=e,this._context=new s6,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){yA("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){yA("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Ke(oo),Ke(si))},t.\u0275dir=Fr({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),t})();class s6{constructor(){this.$implicit=null,this.ngIf=null}}function yA(t,n){if(n&&!n.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${Xt(n)}'.`)}let $6=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Ai({type:t}),t.\u0275inj=Ko({}),t})();let P6=(()=>{class t{}return t.\u0275prov=tt({token:t,providedIn:"root",factory:()=>new L6($e(Vr),window)}),t})();class L6{constructor(n,e){this.document=n,this.window=e,this.offset=()=>[0,0]}setOffset(n){this.offset=Array.isArray(n)?()=>n:n}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(n){this.supportsScrolling()&&this.window.scrollTo(n[0],n[1])}scrollToAnchor(n){if(!this.supportsScrolling())return;const e=function B6(t,n){const e=t.getElementById(n)||t.getElementsByName(n)[0];if(e)return e;if("function"==typeof t.createTreeWalker&&t.body&&(t.body.createShadowRoot||t.body.attachShadow)){const r=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const o=s.shadowRoot;if(o){const i=o.getElementById(n)||o.querySelector(`[name="${n}"]`);if(i)return i}s=r.nextNode()}}return null}(this.document,n);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(n){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=n)}}scrollToElement(n){const e=n.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],s-o[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const n=wA(this.window.history)||wA(Object.getPrototypeOf(this.window.history));return!(!n||!n.writable&&!n.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function wA(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class CA{}class h8 extends dG{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class vw extends h8{static makeCurrent(){!function cG(t){Rp||(Rp=t)}(new vw)}onAndCancel(n,e,r){return n.addEventListener(e,r,!1),()=>{n.removeEventListener(e,r,!1)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.parentNode&&n.parentNode.removeChild(n)}createElement(n,e){return(e=e||this.getDefaultDocument()).createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return"window"===e?window:"document"===e?n:"body"===e?n.body:null}getBaseHref(n){const e=function f8(){return Xc=Xc||document.querySelector("base"),Xc?Xc.getAttribute("href"):null}();return null==e?null:function p8(t){Hp=Hp||document.createElement("a"),Hp.setAttribute("href",t);const n=Hp.pathname;return"/"===n.charAt(0)?n:`/${n}`}(e)}resetBaseElement(){Xc=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return hA(document.cookie,n)}}let Hp,Xc=null;const NA=new Me("TRANSITION_ID"),g8=[{provide:Dp,useFactory:function m8(t,n,e){return()=>{e.get(_p).donePromise.then(()=>{const r=Bi(),s=n.querySelectorAll(`style[ng-transition="${t}"]`);for(let o=0;o<s.length;o++)r.remove(s[o])})}},deps:[NA,Vr,to],multi:!0}];let b8=(()=>{class t{build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();const Wp=new Me("EventManagerPlugins");let jp=(()=>{class t{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>s.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let o=0;o<s.length;o++){const i=s[o];if(i.supports(e))return this._eventNameToPlugin.set(e,i),i}throw new Error(`No event manager plugin found for event ${e}`)}}return t.\u0275fac=function(e){return new(e||t)($e(Wp),$e(Pn))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();class TA{constructor(n){this._doc=n}addGlobalEventListener(n,e,r){const s=Bi().getGlobalEventTarget(this._doc,n);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let kA=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(e){const r=new Set;e.forEach(s=>{this._stylesSet.has(s)||(this._stylesSet.add(s),r.add(s))}),this.onStylesAdded(r)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})(),Yc=(()=>{class t extends kA{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,r,s){e.forEach(o=>{const i=this._doc.createElement("style");i.textContent=o,s.push(r.appendChild(i))})}addHost(e){const r=[];this._addStylesToHost(this._stylesSet,e,r),this._hostNodes.set(e,r)}removeHost(e){const r=this._hostNodes.get(e);r&&r.forEach(AA),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((r,s)=>{this._addStylesToHost(e,s,r)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(AA))}}return t.\u0275fac=function(e){return new(e||t)($e(Vr))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();function AA(t){Bi().remove(t)}const xw={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},ww=/%COMP%/g;function Gp(t,n,e){for(let r=0;r<n.length;r++){let s=n[r];Array.isArray(s)?Gp(t,s,e):(s=s.replace(ww,t),e.push(s))}return e}function FA(t){return n=>{if("__ngUnwrap__"===n)return t;!1===t(n)&&(n.preventDefault(),n.returnValue=!1)}}let Cw=(()=>{class t{constructor(e,r,s){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.rendererByCompId=new Map,this.defaultRenderer=new Iw(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;switch(r.encapsulation){case xo.Emulated:{let s=this.rendererByCompId.get(r.id);return s||(s=new D8(this.eventManager,this.sharedStylesHost,r,this.appId),this.rendererByCompId.set(r.id,s)),s.applyToHost(e),s}case 1:case xo.ShadowDom:return new _8(this.eventManager,this.sharedStylesHost,e,r);default:if(!this.rendererByCompId.has(r.id)){const s=Gp(r.id,r.styles,[]);this.sharedStylesHost.addStyles(s),this.rendererByCompId.set(r.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)($e(jp),$e(Yc),$e(Wc))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();class Iw{constructor(n){this.eventManager=n,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(n,e){return e?document.createElementNS(xw[e]||e,n):document.createElement(n)}createComment(n){return document.createComment(n)}createText(n){return document.createTextNode(n)}appendChild(n,e){(MA(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(MA(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){n&&n.removeChild(e)}selectRootElement(n,e){let r="string"==typeof n?document.querySelector(n):n;if(!r)throw new Error(`The selector "${n}" did not match any elements`);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,s){if(s){e=s+":"+e;const o=xw[s];o?n.setAttributeNS(o,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){const s=xw[r];s?n.removeAttributeNS(s,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,s){s&(Kr.DashCase|Kr.Important)?n.style.setProperty(e,r,s&Kr.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&Kr.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n[e]=r}setValue(n,e){n.nodeValue=e}listen(n,e,r){return"string"==typeof n?this.eventManager.addGlobalEventListener(n,e,FA(r)):this.eventManager.addEventListener(n,e,FA(r))}}function MA(t){return"TEMPLATE"===t.tagName&&void 0!==t.content}class D8 extends Iw{constructor(n,e,r,s){super(n),this.component=r;const o=Gp(s+"-"+r.id,r.styles,[]);e.addStyles(o),this.contentAttr=function w8(t){return"_ngcontent-%COMP%".replace(ww,t)}(s+"-"+r.id),this.hostAttr=function C8(t){return"_nghost-%COMP%".replace(ww,t)}(s+"-"+r.id)}applyToHost(n){super.setAttribute(n,this.hostAttr,"")}createElement(n,e){const r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}}class _8 extends Iw{constructor(n,e,r,s){super(n),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const o=Gp(s.id,s.styles,[]);for(let i=0;i<o.length;i++){const a=document.createElement("style");a.textContent=o[i],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(this.nodeOrShadowRoot(n),e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}}let S8=(()=>{class t extends TA{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return t.\u0275fac=function(e){return new(e||t)($e(Vr))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();const PA=["alt","control","meta","shift"],E8={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},N8={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let T8=(()=>{class t extends TA{constructor(e){super(e)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,r,s){const o=t.parseEventName(r),i=t.eventCallback(o.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Bi().onAndCancel(e,o.domEventName,i))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=t._normalizeKey(r.pop());let i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),PA.forEach(u=>{const c=r.indexOf(u);c>-1&&(r.splice(c,1),i+=u+".")}),i+=o,0!=r.length||0===o.length)return null;const l={};return l.domEventName=s,l.fullKey=i,l}static matchEventFullKeyCode(e,r){let s=E8[e.key]||e.key,o="";return r.indexOf("code.")>-1&&(s=e.code,o="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),PA.forEach(i=>{i!==s&&(0,N8[i])(e)&&(o+=i+".")}),o+=s,o===r)}static eventCallback(e,r,s){return o=>{t.matchEventFullKeyCode(o,e)&&s.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return t.\u0275fac=function(e){return new(e||t)($e(Vr))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();const $8=Ok(aG,"browser",[{provide:Lx,useValue:"browser"},{provide:_k,useValue:function k8(){vw.makeCurrent()},multi:!0},{provide:Vr,useFactory:function R8(){return function K3(t){yv=t}(document),document},deps:[]}]),zA=new Me(""),VA=[{provide:Sp,useClass:class y8{addToWindow(n){Qt.getAngularTestability=(r,s=!0)=>{const o=n.findTestabilityInTree(r,s);if(null==o)throw new Error("Could not find testability for element.");return o},Qt.getAllAngularTestabilities=()=>n.getAllTestabilities(),Qt.getAllAngularRootElements=()=>n.getAllRootElements(),Qt.frameworkStabilizers||(Qt.frameworkStabilizers=[]),Qt.frameworkStabilizers.push(r=>{const s=Qt.getAllAngularTestabilities();let o=s.length,i=!1;const a=function(l){i=i||l,o--,0==o&&r(i)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(n,e,r){return null==e?null:n.getTestability(e)??(r?Bi().isShadowRoot(e)?this.findTestabilityInTree(n,e.host,!0):this.findTestabilityInTree(n,e.parentElement,!0):null)}},deps:[]},{provide:Ak,useClass:Hx,deps:[Pn,Wx,Sp]},{provide:Hx,useClass:Hx,deps:[Pn,Wx,Sp]}],UA=[{provide:Sv,useValue:"root"},{provide:Fl,useFactory:function A8(){return new Fl},deps:[]},{provide:Wp,useClass:S8,multi:!0,deps:[Vr,Pn,Lx]},{provide:Wp,useClass:T8,multi:!0,deps:[Vr]},{provide:Cw,useClass:Cw,deps:[jp,Yc,Wc]},{provide:u1,useExisting:Cw},{provide:kA,useExisting:Yc},{provide:Yc,useClass:Yc,deps:[Vr]},{provide:jp,useClass:jp,deps:[Wp,Pn]},{provide:CA,useClass:b8,deps:[]},[]];let F8=(()=>{class t{constructor(e){}static withServerTransition(e){return{ngModule:t,providers:[{provide:Wc,useValue:e.appId},{provide:NA,useExisting:Wc},g8]}}}return t.\u0275fac=function(e){return new(e||t)($e(zA,12))},t.\u0275mod=Ai({type:t}),t.\u0275inj=Ko({providers:[...UA,...VA],imports:[$6,lG]}),t})(),HA=(()=>{class t{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return t.\u0275fac=function(e){return new(e||t)($e(Vr))},t.\u0275prov=tt({token:t,factory:function(e){let r=null;return r=e?new e:function M8(){return new HA($e(Vr))}(),r},providedIn:"root"}),t})();function ze(...t){return jn(t,rc(t))}typeof window<"u"&&window;class co extends Wo{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){const e=super._subscribe(n);return!e.closed&&n.next(this._value),e}getValue(){const{hasError:n,thrownError:e,_value:r}=this;if(n)throw e;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}}const qp=Ye(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"}),{isArray:W8}=Array,{getPrototypeOf:j8,prototype:G8,keys:q8}=Object;const{isArray:Y8}=Array;function GA(...t){const n=rc(t),e=function vB(t){return ae(cb(t))?t.pop():void 0}(t),{args:r,keys:s}=function K8(t){if(1===t.length){const n=t[0];if(W8(n))return{args:n,keys:null};if(function X8(t){return t&&"object"==typeof t&&j8(t)===G8}(n)){const e=q8(n);return{args:e.map(r=>n[r]),keys:e}}}return{args:t,keys:null}}(t);if(0===r.length)return jn([],n);const o=new Fn(function e5(t,n,e=ma){return r=>{qA(n,()=>{const{length:s}=t,o=new Array(s);let i=s,a=s;for(let l=0;l<s;l++)qA(n,()=>{const u=jn(t[l],n);let c=!1;u.subscribe(ir(r,d=>{o[l]=d,c||(c=!0,a--),a||r.next(e(o.slice()))},()=>{--i||r.complete()}))},r)},r)}}(r,n,s?i=>function Q8(t,n){return t.reduce((e,r,s)=>(e[r]=n[s],e),{})}(s,i):ma));return e?o.pipe(function Z8(t){return gt(n=>function J8(t,n){return Y8(n)?t(...n):t(n)}(t,n))}(e)):o}function qA(t,n,e){t?jo(e,t,n):n()}function Sw(...t){return function t5(){return fl(1)}()(jn(t,rc(t)))}function KA(t){return new Fn(n=>{vo(t()).subscribe(n)})}function Jc(t,n){const e=ae(t)?t:()=>t,r=s=>s.error(e());return new Fn(n?s=>n.schedule(r,0,s):r)}function Ew(){return or((t,n)=>{let e=null;t._refCount++;const r=ir(n,void 0,void 0,void 0,()=>{if(!t||t._refCount<=0||0<--t._refCount)return void(e=null);const s=t._connection,o=e;e=null,s&&(!o||s===o)&&s.unsubscribe(),n.unsubscribe()});t.subscribe(r),r.closed||(e=t.connect())})}class XA extends Fn{constructor(n,e){super(),this.source=n,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,G_(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){const n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new He;const e=this.getSubject();n.add(this.source.subscribe(ir(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=He.EMPTY)}return n}refCount(){return Ew()(this)}}function No(t,n){return or((e,r)=>{let s=null,o=0,i=!1;const a=()=>i&&!s&&r.complete();e.subscribe(ir(r,l=>{s?.unsubscribe();let u=0;const c=o++;vo(t(l,c)).subscribe(s=ir(r,d=>r.next(n?n(l,d,c,u++):d),()=>{s=null,a()}))},()=>{i=!0,a()}))})}function Zc(t){return t<=0?()=>Go:or((n,e)=>{let r=0;n.subscribe(ir(e,s=>{++r<=t&&(e.next(s),t<=r&&e.complete())}))})}function ui(t,n){return or((e,r)=>{let s=0;e.subscribe(ir(r,o=>t.call(n,o,s++)&&r.next(o)))})}function Kp(t){return or((n,e)=>{let r=!1;n.subscribe(ir(e,s=>{r=!0,e.next(s)},()=>{r||e.next(t),e.complete()}))})}function YA(t=r5){return or((n,e)=>{let r=!1;n.subscribe(ir(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(t())))})}function r5(){return new qp}function Vi(t,n){const e=arguments.length>=2;return r=>r.pipe(t?ui((s,o)=>t(s,o,r)):ma,Zc(1),e?Kp(n):YA(()=>new qp))}function Ui(t,n){return ae(n)?gr(t,n,1):gr(t,1)}function Tr(t,n,e){const r=ae(t)||n||e?{next:t,error:n,complete:e}:t;return r?or((s,o)=>{var i;null===(i=r.subscribe)||void 0===i||i.call(r);let a=!0;s.subscribe(ir(o,l=>{var u;null===(u=r.next)||void 0===u||u.call(r,l),o.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),o.complete()},l=>{var u;a=!1,null===(u=r.error)||void 0===u||u.call(r,l),o.error(l)},()=>{var l,u;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(u=r.finalize)||void 0===u||u.call(r)}))}):ma}function Hi(t){return or((n,e)=>{let o,r=null,s=!1;r=n.subscribe(ir(e,void 0,void 0,i=>{o=vo(t(i,Hi(t)(n))),r?(r.unsubscribe(),r=null,o.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,o.subscribe(e))})}function s5(t,n,e,r,s){return(o,i)=>{let a=e,l=n,u=0;o.subscribe(ir(i,c=>{const d=u++;l=a?t(l,c,d):(a=!0,c),r&&i.next(l)},s&&(()=>{a&&i.next(l),i.complete()})))}}function JA(t,n){return or(s5(t,n,arguments.length>=2,!0))}function Nw(t){return t<=0?()=>Go:or((n,e)=>{let r=[];n.subscribe(ir(e,s=>{r.push(s),t<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function ZA(t,n){const e=arguments.length>=2;return r=>r.pipe(t?ui((s,o)=>t(s,o,r)):ma,Nw(1),e?Kp(n):YA(()=>new qp))}function Tw(t){return or((n,e)=>{try{n.subscribe(e)}finally{e.add(t)}})}const yt="primary",Qc=Symbol("RouteTitle");class a5{constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Ql(t){return new a5(t)}function l5(t,n,e){const r=e.path.split("/");if(r.length>t.length||"full"===e.pathMatch&&(n.hasChildren()||r.length<t.length))return null;const s={};for(let o=0;o<r.length;o++){const i=r[o],a=t[o];if(i.startsWith(":"))s[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:t.slice(0,r.length),posParams:s}}function To(t,n){const e=t?Object.keys(t):void 0,r=n?Object.keys(n):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let o=0;o<e.length;o++)if(s=e[o],!QA(t[s],n[s]))return!1;return!0}function QA(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;const e=[...t].sort(),r=[...n].sort();return e.every((s,o)=>r[o]===s)}return t===n}function eR(t){return Array.prototype.concat.apply([],t)}function tR(t){return t.length>0?t[t.length-1]:null}function vr(t,n){for(const e in t)t.hasOwnProperty(e)&&n(t[e],e)}function Wi(t){return mN(t)?t:dp(t)?jn(Promise.resolve(t)):ze(t)}const Xp=!1,c5={exact:function sR(t,n,e){if(!Ma(t.segments,n.segments)||!Yp(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children)if(!t.children[r]||!sR(t.children[r],n.children[r],e))return!1;return!0},subset:oR},nR={exact:function d5(t,n){return To(t,n)},subset:function h5(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>QA(t[e],n[e]))},ignored:()=>!0};function rR(t,n,e){return c5[e.paths](t.root,n.root,e.matrixParams)&&nR[e.queryParams](t.queryParams,n.queryParams)&&!("exact"===e.fragment&&t.fragment!==n.fragment)}function oR(t,n,e){return iR(t,n,n.segments,e)}function iR(t,n,e,r){if(t.segments.length>e.length){const s=t.segments.slice(0,e.length);return!(!Ma(s,e)||n.hasChildren()||!Yp(s,e,r))}if(t.segments.length===e.length){if(!Ma(t.segments,e)||!Yp(t.segments,e,r))return!1;for(const s in n.children)if(!t.children[s]||!oR(t.children[s],n.children[s],r))return!1;return!0}{const s=e.slice(0,t.segments.length),o=e.slice(t.segments.length);return!!(Ma(t.segments,s)&&Yp(t.segments,s,r)&&t.children[yt])&&iR(t.children[yt],n,o,r)}}function Yp(t,n,e){return n.every((r,s)=>nR[e](t[s].parameters,r.parameters))}class Oa{constructor(n=new vt([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Ql(this.queryParams)),this._queryParamMap}toString(){return m5.serialize(this)}}class vt{constructor(n,e){this.segments=n,this.children=e,this.parent=null,vr(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Jp(this)}}class ed{constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Ql(this.parameters)),this._parameterMap}toString(){return cR(this)}}function Ma(t,n){return t.length===n.length&&t.every((e,r)=>e.path===n[r].path)}let aR=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:function(){return new kw},providedIn:"root"}),t})();class kw{parse(n){const e=new D5(n);return new Oa(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){const e=`/${td(n.root,!0)}`,r=function b5(t){const n=Object.keys(t).map(e=>{const r=t[e];return Array.isArray(r)?r.map(s=>`${Zp(e)}=${Zp(s)}`).join("&"):`${Zp(e)}=${Zp(r)}`}).filter(e=>!!e);return n.length?`?${n.join("&")}`:""}(n.queryParams);return`${e}${r}${"string"==typeof n.fragment?`#${function g5(t){return encodeURI(t)}(n.fragment)}`:""}`}}const m5=new kw;function Jp(t){return t.segments.map(n=>cR(n)).join("/")}function td(t,n){if(!t.hasChildren())return Jp(t);if(n){const e=t.children[yt]?td(t.children[yt],!1):"",r=[];return vr(t.children,(s,o)=>{o!==yt&&r.push(`${o}:${td(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function p5(t,n){let e=[];return vr(t.children,(r,s)=>{s===yt&&(e=e.concat(n(r,s)))}),vr(t.children,(r,s)=>{s!==yt&&(e=e.concat(n(r,s)))}),e}(t,(r,s)=>s===yt?[td(t.children[yt],!1)]:[`${s}:${td(r,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children[yt]?`${Jp(t)}/${e[0]}`:`${Jp(t)}/(${e.join("//")})`}}function lR(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Zp(t){return lR(t).replace(/%3B/gi,";")}function Aw(t){return lR(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Qp(t){return decodeURIComponent(t)}function uR(t){return Qp(t.replace(/\+/g,"%20"))}function cR(t){return`${Aw(t.path)}${function y5(t){return Object.keys(t).map(n=>`;${Aw(n)}=${Aw(t[n])}`).join("")}(t.parameters)}`}const v5=/^[^\/()?;=#]+/;function em(t){const n=t.match(v5);return n?n[0]:""}const x5=/^[^=?&#]+/,C5=/^[^&#]+/;class D5{constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new vt([],{}):new vt([],this.parseChildren())}parseQueryParams(){const n={};if(this.consumeOptional("?"))do{this.parseQueryParam(n)}while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(e).length>0)&&(r[yt]=new vt(n,e)),r}parseSegment(){const n=em(this.remaining);if(""===n&&this.peekStartsWith(";"))throw new xe(4009,Xp);return this.capture(n),new ed(Qp(n),this.parseMatrixParams())}parseMatrixParams(){const n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){const e=em(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=em(this.remaining);s&&(r=s,this.capture(r))}n[Qp(e)]=Qp(r)}parseQueryParam(n){const e=function w5(t){const n=t.match(x5);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=function I5(t){const n=t.match(C5);return n?n[0]:""}(this.remaining);i&&(r=i,this.capture(r))}const s=uR(e),o=uR(r);if(n.hasOwnProperty(s)){let i=n[s];Array.isArray(i)||(i=[i],n[s]=i),i.push(o)}else n[s]=o}parseParens(n){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=em(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new xe(4010,Xp);let o;r.indexOf(":")>-1?(o=r.slice(0,r.indexOf(":")),this.capture(o),this.capture(":")):n&&(o=yt);const i=this.parseChildren();e[o]=1===Object.keys(i).length?i[yt]:new vt([],i),this.consumeOptional("//")}return e}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return!!this.peekStartsWith(n)&&(this.remaining=this.remaining.substring(n.length),!0)}capture(n){if(!this.consumeOptional(n))throw new xe(4011,Xp)}}function Rw(t){return t.segments.length>0?new vt([],{[yt]:t}):t}function tm(t){const n={};for(const r of Object.keys(t.children)){const o=tm(t.children[r]);(o.segments.length>0||o.hasChildren())&&(n[r]=o)}return function _5(t){if(1===t.numberOfChildren&&t.children[yt]){const n=t.children[yt];return new vt(t.segments.concat(n.segments),n.children)}return t}(new vt(t.segments,n))}function Pa(t){return t instanceof Oa}function N5(t,n,e,r,s){if(0===e.length)return eu(n.root,n.root,n.root,r,s);const o=function fR(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new hR(!0,0,t);let n=0,e=!1;const r=t.reduce((s,o,i)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return vr(o.outlets,(l,u)=>{a[u]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(o.segmentPath)return[...s,o.segmentPath]}return"string"!=typeof o?[...s,o]:0===i?(o.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?n++:""!=a&&s.push(a))}),s):[...s,o]},[]);return new hR(e,n,r)}(e);return o.toRoot()?eu(n.root,n.root,new vt([],{}),r,s):function i(l){const u=function k5(t,n,e,r){if(t.isAbsolute)return new tu(n.root,!0,0);if(-1===r)return new tu(e,e===n.root,0);return function pR(t,n,e){let r=t,s=n,o=e;for(;o>s;){if(o-=s,r=r.parent,!r)throw new xe(4005,!1);s=r.segments.length}return new tu(r,!1,s-o)}(e,r+(nd(t.commands[0])?0:1),t.numberOfDoubleDots)}(o,n,t.snapshot?._urlSegment,l),c=u.processChildren?sd(u.segmentGroup,u.index,o.commands):Fw(u.segmentGroup,u.index,o.commands);return eu(n.root,u.segmentGroup,c,r,s)}(t.snapshot?._lastPathIndex)}function nd(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function rd(t){return"object"==typeof t&&null!=t&&t.outlets}function eu(t,n,e,r,s){let i,o={};r&&vr(r,(l,u)=>{o[u]=Array.isArray(l)?l.map(c=>`${c}`):`${l}`}),i=t===n?e:dR(t,n,e);const a=Rw(tm(i));return new Oa(a,o,s)}function dR(t,n,e){const r={};return vr(t.children,(s,o)=>{r[o]=s===n?e:dR(s,n,e)}),new vt(t.segments,r)}class hR{constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&nd(r[0]))throw new xe(4003,!1);const s=r.find(rd);if(s&&s!==tR(r))throw new xe(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class tu{constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}}function Fw(t,n,e){if(t||(t=new vt([],{})),0===t.segments.length&&t.hasChildren())return sd(t,n,e);const r=function R5(t,n,e){let r=0,s=n;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<t.segments.length;){if(r>=e.length)return o;const i=t.segments[s],a=e[r];if(rd(a))break;const l=`${a}`,u=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&u&&"object"==typeof u&&void 0===u.outlets){if(!gR(l,u,i))return o;r+=2}else{if(!gR(l,{},i))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(t,n,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const o=new vt(t.segments.slice(0,r.pathIndex),{});return o.children[yt]=new vt(t.segments.slice(r.pathIndex),t.children),sd(o,0,s)}return r.match&&0===s.length?new vt(t.segments,{}):r.match&&!t.hasChildren()?Ow(t,n,e):r.match?sd(t,0,s):Ow(t,n,e)}function sd(t,n,e){if(0===e.length)return new vt(t.segments,{});{const r=function A5(t){return rd(t[0])?t[0].outlets:{[yt]:t}}(e),s={};return vr(r,(o,i)=>{"string"==typeof o&&(o=[o]),null!==o&&(s[i]=Fw(t.children[i],n,o))}),vr(t.children,(o,i)=>{void 0===r[i]&&(s[i]=o)}),new vt(t.segments,s)}}function Ow(t,n,e){const r=t.segments.slice(0,n);let s=0;for(;s<e.length;){const o=e[s];if(rd(o)){const l=$5(o.outlets);return new vt(r,l)}if(0===s&&nd(e[0])){r.push(new ed(t.segments[n].path,mR(e[0]))),s++;continue}const i=rd(o)?o.outlets[yt]:`${o}`,a=s<e.length-1?e[s+1]:null;i&&a&&nd(a)?(r.push(new ed(i,mR(a))),s+=2):(r.push(new ed(i,{})),s++)}return new vt(r,{})}function $5(t){const n={};return vr(t,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(n[r]=Ow(new vt([],{}),0,e))}),n}function mR(t){const n={};return vr(t,(e,r)=>n[r]=`${e}`),n}function gR(t,n,e){return t==e.path&&To(n,e.parameters)}class ci{constructor(n,e){this.id=n,this.url=e}}class Mw extends ci{constructor(n,e,r="imperative",s=null){super(n,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class La extends ci{constructor(n,e,r){super(n,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class nm extends ci{constructor(n,e,r,s){super(n,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class yR extends ci{constructor(n,e,r,s){super(n,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class F5 extends ci{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class O5 extends ci{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class M5 extends ci{constructor(n,e,r,s,o){super(n,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=o,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class P5 extends ci{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class L5 extends ci{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class B5{constructor(n){this.route=n,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class z5{constructor(n){this.route=n,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class V5{constructor(n){this.snapshot=n,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class U5{constructor(n){this.snapshot=n,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class H5{constructor(n){this.snapshot=n,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class W5{constructor(n){this.snapshot=n,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class bR{constructor(n,e,r){this.routerEvent=n,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class vR{constructor(n){this._root=n}get root(){return this._root.value}parent(n){const e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){const e=Pw(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){const e=Pw(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){const e=Lw(n,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==n)}pathFromRoot(n){return Lw(n,this._root).map(e=>e.value)}}function Pw(t,n){if(t===n.value)return n;for(const e of n.children){const r=Pw(t,e);if(r)return r}return null}function Lw(t,n){if(t===n.value)return[n];for(const e of n.children){const r=Lw(t,e);if(r.length)return r.unshift(n),r}return[]}class di{constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}}function nu(t){const n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}class xR extends vR{constructor(n,e){super(n),this.snapshot=e,Bw(this,n)}toString(){return this.snapshot.toString()}}function wR(t,n){const e=function G5(t,n){const i=new rm([],{},{},"",{},yt,n,null,t.root,-1,{});return new IR("",new di(i,[]))}(t,n),r=new co([new ed("",{})]),s=new co({}),o=new co({}),i=new co({}),a=new co(""),l=new ru(r,s,i,a,o,yt,n,e.root);return l.snapshot=e.root,new xR(new di(l,[]),e)}class ru{constructor(n,e,r,s,o,i,a,l){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.title=this.data?.pipe(gt(u=>u[Qc]))??ze(void 0),this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(gt(n=>Ql(n)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(gt(n=>Ql(n)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function CR(t,n="emptyOnly"){const e=t.pathFromRoot;let r=0;if("always"!==n)for(r=e.length-1;r>=1;){const s=e[r],o=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(o.component)break;r--}}return function q5(t){return t.reduce((n,e)=>({params:{...n.params,...e.params},data:{...n.data,...e.data},resolve:{...e.data,...n.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class rm{constructor(n,e,r,s,o,i,a,l,u,c,d){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.routeConfig=l,this._urlSegment=u,this._lastPathIndex=c,this._resolve=d}get title(){return this.data?.[Qc]}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Ql(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Ql(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class IR extends vR{constructor(n,e){super(e),this.url=n,Bw(this,e)}toString(){return DR(this._root)}}function Bw(t,n){n.value._routerState=t,n.children.forEach(e=>Bw(t,e))}function DR(t){const n=t.children.length>0?` { ${t.children.map(DR).join(", ")} } `:"";return`${t.value}${n}`}function zw(t){if(t.snapshot){const n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,To(n.queryParams,e.queryParams)||t.queryParams.next(e.queryParams),n.fragment!==e.fragment&&t.fragment.next(e.fragment),To(n.params,e.params)||t.params.next(e.params),function u5(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!To(t[e],n[e]))return!1;return!0}(n.url,e.url)||t.url.next(e.url),To(n.data,e.data)||t.data.next(e.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function Vw(t,n){const e=To(t.params,n.params)&&function f5(t,n){return Ma(t,n)&&t.every((e,r)=>To(e.parameters,n[r].parameters))}(t.url,n.url);return e&&!(!t.parent!=!n.parent)&&(!t.parent||Vw(t.parent,n.parent))}function od(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=n.value;const s=function X5(t,n,e){return n.children.map(r=>{for(const s of e.children)if(t.shouldReuseRoute(r.value,s.value.snapshot))return od(t,r,s);return od(t,r)})}(t,n,e);return new di(r,s)}{if(t.shouldAttach(n.value)){const o=t.retrieve(n.value);if(null!==o){const i=o.route;return i.value._futureSnapshot=n.value,i.children=n.children.map(a=>od(t,a)),i}}const r=function Y5(t){return new ru(new co(t.url),new co(t.params),new co(t.queryParams),new co(t.fragment),new co(t.data),t.outlet,t.component,t)}(n.value),s=n.children.map(o=>od(t,o));return new di(r,s)}}const Uw="ngNavigationCancelingError";function _R(t,n){const{redirectTo:e,navigationBehaviorOptions:r}=Pa(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,s=SR(!1,0,n);return s.url=e,s.navigationBehaviorOptions=r,s}function SR(t,n,e){const r=new Error("NavigationCancelingError: "+(t||""));return r[Uw]=!0,r.cancellationCode=n,e&&(r.url=e),r}function ER(t){return NR(t)&&Pa(t.url)}function NR(t){return t&&t[Uw]}class J5{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new id,this.attachRef=null}}let id=(()=>{class t{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new J5,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const sm=!1;let Hw=(()=>{class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=yt,this.activateEvents=new Nr,this.deactivateEvents=new Nr,this.attachEvents=new Nr,this.detachEvents=new Nr,this.parentContexts=$t(id),this.location=$t(oo),this.changeDetector=$t(Kx),this.environmentInjector=$t(ei)}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new xe(4012,sm);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new xe(4012,sm);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new xe(4012,sm);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new xe(4013,sm);this._activatedRoute=e;const s=this.location,i=e._futureSnapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new Z5(e,a,s.injector);if(r&&function Q5(t){return!!t.resolveComponentFactory}(r)){const u=r.resolveComponentFactory(i);this.activated=s.createComponent(u,s.length,l)}else this.activated=s.createComponent(i,{index:s.length,injector:l,environmentInjector:r??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Fr({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[Ia]}),t})();class Z5{constructor(n,e,r){this.route=n,this.childContexts=e,this.parent=r}get(n,e){return n===ru?this.route:n===id?this.childContexts:this.parent.get(n,e)}}let Ww=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ya({type:t,selectors:[["ng-component"]],standalone:!0,features:[BT],decls:1,vars:0,template:function(e,r){1&e&&qn(0,"router-outlet")},dependencies:[Hw],encapsulation:2}),t})();function TR(t,n){return t.providers&&!t._injector&&(t._injector=bp(t.providers,n,`Route: ${t.path}`)),t._injector??n}function Gw(t){const n=t.children&&t.children.map(Gw),e=n?{...t,children:n}:{...t};return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==yt&&(e.component=Ww),e}function ks(t){return t.outlet||yt}function kR(t,n){const e=t.filter(r=>ks(r)===n);return e.push(...t.filter(r=>ks(r)!==n)),e}function ad(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let n=t.parent;n;n=n.parent){const e=n.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class sq{constructor(n,e,r,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(n){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),zw(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){const s=nu(e);n.children.forEach(o=>{const i=o.value.outlet;this.deactivateRoutes(o,s[i],r),delete s[i]}),vr(s,(o,i)=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(s===o)if(s.component){const i=r.getContext(s.outlet);i&&this.deactivateChildRoutes(n,e,i.children)}else this.deactivateChildRoutes(n,e,r);else o&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=nu(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);if(r&&r.outlet){const i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:i,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=nu(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(n,e,r){const s=nu(e);n.children.forEach(o=>{this.activateRoutes(o,s[o.value.outlet],r),this.forwardEvent(new W5(o.value.snapshot))}),n.children.length&&this.forwardEvent(new U5(n.value.snapshot))}activateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(zw(s),s===o)if(s.component){const i=r.getOrCreateContext(s.outlet);this.activateChildRoutes(n,e,i.children)}else this.activateChildRoutes(n,e,r);else if(s.component){const i=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),zw(a.route.value),this.activateChildRoutes(n,null,i.children)}else{const a=ad(s.snapshot),l=a?.get(Tc)??null;i.attachRef=null,i.route=s,i.resolver=l,i.injector=a,i.outlet&&i.outlet.activateWith(s,i.injector),this.activateChildRoutes(n,null,i.children)}}else this.activateChildRoutes(n,null,r)}}class AR{constructor(n){this.path=n,this.route=this.path[this.path.length-1]}}class om{constructor(n,e){this.component=n,this.route=e}}function oq(t,n,e){const r=t._root;return ld(r,n?n._root:null,e,[r.value])}function su(t,n){const e=Symbol(),r=n.get(t,e);return r===e?"function"!=typeof t||function OB(t){return null!==bf(t)}(t)?n.get(t):t:r}function ld(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=nu(n);return t.children.forEach(i=>{(function aq(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=t.value,i=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const l=function lq(t,n,e){if("function"==typeof e)return e(t,n);switch(e){case"pathParamsChange":return!Ma(t.url,n.url);case"pathParamsOrQueryParamsChange":return!Ma(t.url,n.url)||!To(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Vw(t,n)||!To(t.queryParams,n.queryParams);default:return!Vw(t,n)}}(i,o,o.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new AR(r)):(o.data=i.data,o._resolvedData=i._resolvedData),ld(t,n,o.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new om(a.outlet.component,i))}else i&&ud(n,a,s),s.canActivateChecks.push(new AR(r)),ld(t,null,o.component?a?a.children:null:e,r,s)})(i,o[i.value.outlet],e,r.concat([i.value]),s),delete o[i.value.outlet]}),vr(o,(i,a)=>ud(i,e.getContext(a),s)),s}function ud(t,n,e){const r=nu(t),s=t.value;vr(r,(o,i)=>{ud(o,s.component?n?n.children.getContext(i):null:n,e)}),e.canDeactivateChecks.push(new om(s.component&&n&&n.outlet&&n.outlet.isActivated?n.outlet.component:null,s))}function cd(t){return"function"==typeof t}function qw(t){return t instanceof qp||"EmptyError"===t?.name}const im=Symbol("INITIAL_VALUE");function ou(){return No(t=>GA(t.map(n=>n.pipe(Zc(1),function n5(...t){const n=rc(t);return or((e,r)=>{(n?Sw(t,e,n):Sw(t,e)).subscribe(r)})}(im)))).pipe(gt(n=>{for(const e of n)if(!0!==e){if(e===im)return im;if(!1===e||e instanceof Oa)return e}return!0}),ui(n=>n!==im),Zc(1)))}function RR(t){return function QL(...t){return H_(t)}(Tr(n=>{if(Pa(n))throw _R(0,n)}),gt(n=>!0===n))}const Kw={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function $R(t,n,e,r,s){const o=Xw(t,n,e);return o.matched?function _q(t,n,e,r){const s=n.canMatch;return s&&0!==s.length?ze(s.map(i=>{const a=su(i,t);return Wi(function pq(t){return t&&cd(t.canMatch)}(a)?a.canMatch(n,e):t.runInContext(()=>a(n,e)))})).pipe(ou(),RR()):ze(!0)}(r=TR(n,r),n,e).pipe(gt(i=>!0===i?o:{...Kw})):ze(o)}function Xw(t,n,e){if(""===n.path)return"full"===n.pathMatch&&(t.hasChildren()||e.length>0)?{...Kw}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(n.matcher||l5)(e,t,n);if(!s)return{...Kw};const o={};vr(s.posParams,(a,l)=>{o[l]=a.path});const i=s.consumed.length>0?{...o,...s.consumed[s.consumed.length-1].parameters}:o;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:i,positionalParamSegments:s.posParams??{}}}function am(t,n,e,r){if(e.length>0&&function Nq(t,n,e){return e.some(r=>lm(t,n,r)&&ks(r)!==yt)}(t,e,r)){const o=new vt(n,function Eq(t,n,e,r){const s={};s[yt]=r,r._sourceSegment=t,r._segmentIndexShift=n.length;for(const o of e)if(""===o.path&&ks(o)!==yt){const i=new vt([],{});i._sourceSegment=t,i._segmentIndexShift=n.length,s[ks(o)]=i}return s}(t,n,r,new vt(e,t.children)));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:[]}}if(0===e.length&&function Tq(t,n,e){return e.some(r=>lm(t,n,r))}(t,e,r)){const o=new vt(t.segments,function Sq(t,n,e,r,s){const o={};for(const i of r)if(lm(t,e,i)&&!s[ks(i)]){const a=new vt([],{});a._sourceSegment=t,a._segmentIndexShift=n.length,o[ks(i)]=a}return{...s,...o}}(t,n,e,r,t.children));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:e}}const s=new vt(t.segments,t.children);return s._sourceSegment=t,s._segmentIndexShift=n.length,{segmentGroup:s,slicedSegments:e}}function lm(t,n,e){return(!(t.hasChildren()||n.length>0)||"full"!==e.pathMatch)&&""===e.path}function FR(t,n,e,r){return!!(ks(t)===r||r!==yt&&lm(n,e,t))&&("**"===t.path||Xw(n,t,e).matched)}function OR(t,n,e){return 0===n.length&&!t.children[e]}const um=!1;class cm{constructor(n){this.segmentGroup=n||null}}class MR{constructor(n){this.urlTree=n}}function dd(t){return Jc(new cm(t))}function PR(t){return Jc(new MR(t))}class $q{constructor(n,e,r,s,o){this.injector=n,this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=o,this.allowRedirects=!0}apply(){const n=am(this.urlTree.root,[],[],this.config).segmentGroup,e=new vt(n.segments,n.children);return this.expandSegmentGroup(this.injector,this.config,e,yt).pipe(gt(o=>this.createUrlTree(tm(o),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Hi(o=>{if(o instanceof MR)return this.allowRedirects=!1,this.match(o.urlTree);throw o instanceof cm?this.noMatchError(o):o}))}match(n){return this.expandSegmentGroup(this.injector,this.config,n.root,yt).pipe(gt(s=>this.createUrlTree(tm(s),n.queryParams,n.fragment))).pipe(Hi(s=>{throw s instanceof cm?this.noMatchError(s):s}))}noMatchError(n){return new xe(4002,um)}createUrlTree(n,e,r){const s=Rw(n);return new Oa(s,e,r)}expandSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(n,e,r).pipe(gt(o=>new vt([],o))):this.expandSegment(n,r,e,r.segments,s,!0)}expandChildren(n,e,r){const s=[];for(const o of Object.keys(r.children))"primary"===o?s.unshift(o):s.push(o);return jn(s).pipe(Ui(o=>{const i=r.children[o],a=kR(e,o);return this.expandSegmentGroup(n,a,i,o).pipe(gt(l=>({segment:l,outlet:o})))}),JA((o,i)=>(o[i.outlet]=i.segment,o),{}),ZA())}expandSegment(n,e,r,s,o,i){return jn(r).pipe(Ui(a=>this.expandSegmentAgainstRoute(n,e,r,a,s,o,i).pipe(Hi(u=>{if(u instanceof cm)return ze(null);throw u}))),Vi(a=>!!a),Hi((a,l)=>{if(qw(a))return OR(e,s,o)?ze(new vt([],{})):dd(e);throw a}))}expandSegmentAgainstRoute(n,e,r,s,o,i,a){return FR(s,e,o,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(n,e,s,o,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i):dd(e):dd(e)}expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(n,r,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(n,e,r,s){const o=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?PR(o):this.lineralizeSegments(r,o).pipe(gr(i=>{const a=new vt(i,{});return this.expandSegment(n,a,e,i,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){const{matched:a,consumedSegments:l,remainingSegments:u,positionalParamSegments:c}=Xw(e,s,o);if(!a)return dd(e);const d=this.applyRedirectCommands(l,s.redirectTo,c);return s.redirectTo.startsWith("/")?PR(d):this.lineralizeSegments(s,d).pipe(gr(h=>this.expandSegment(n,e,r,h.concat(u),i,!1)))}matchSegmentAgainstRoute(n,e,r,s,o){return"**"===r.path?(n=TR(r,n),r.loadChildren?(r._loadedRoutes?ze({routes:r._loadedRoutes,injector:r._loadedInjector}):this.configLoader.loadChildren(n,r)).pipe(gt(a=>(r._loadedRoutes=a.routes,r._loadedInjector=a.injector,new vt(s,{})))):ze(new vt(s,{}))):$R(e,r,s,n).pipe(No(({matched:i,consumedSegments:a,remainingSegments:l})=>i?this.getChildConfig(n=r._injector??n,r,s).pipe(gr(c=>{const d=c.injector??n,h=c.routes,{segmentGroup:f,slicedSegments:p}=am(e,a,l,h),m=new vt(f.segments,f.children);if(0===p.length&&m.hasChildren())return this.expandChildren(d,h,m).pipe(gt(v=>new vt(a,v)));if(0===h.length&&0===p.length)return ze(new vt(a,{}));const g=ks(r)===o;return this.expandSegment(d,m,h,p,g?yt:o,!0).pipe(gt(b=>new vt(a.concat(b.segments),b.children)))})):dd(e)))}getChildConfig(n,e,r){return e.children?ze({routes:e.children,injector:n}):e.loadChildren?void 0!==e._loadedRoutes?ze({routes:e._loadedRoutes,injector:e._loadedInjector}):function Dq(t,n,e,r){const s=n.canLoad;return void 0===s||0===s.length?ze(!0):ze(s.map(i=>{const a=su(i,t);return Wi(function cq(t){return t&&cd(t.canLoad)}(a)?a.canLoad(n,e):t.runInContext(()=>a(n,e)))})).pipe(ou(),RR())}(n,e,r).pipe(gr(s=>s?this.configLoader.loadChildren(n,e).pipe(Tr(o=>{e._loadedRoutes=o.routes,e._loadedInjector=o.injector})):function Aq(t){return Jc(SR(um,3))}())):ze({routes:[],injector:n})}lineralizeSegments(n,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return ze(r);if(s.numberOfChildren>1||!s.children[yt])return Jc(new xe(4e3,um));s=s.children[yt]}}applyRedirectCommands(n,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),n,r)}applyRedirectCreateUrlTree(n,e,r,s){const o=this.createSegmentGroup(n,e.root,r,s);return new Oa(o,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){const r={};return vr(n,(s,o)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(n,e,r,s){const o=this.createSegments(n,e.segments,r,s);let i={};return vr(e.children,(a,l)=>{i[l]=this.createSegmentGroup(n,a,r,s)}),new vt(o,i)}createSegments(n,e,r,s){return e.map(o=>o.path.startsWith(":")?this.findPosParam(n,o,s):this.findOrReturn(o,r))}findPosParam(n,e,r){const s=r[e.path.substring(1)];if(!s)throw new xe(4001,um);return s}findOrReturn(n,e){let r=0;for(const s of e){if(s.path===n.path)return e.splice(r),s;r++}return n}}class Oq{}class Lq{constructor(n,e,r,s,o,i,a){this.injector=n,this.rootComponentType=e,this.config=r,this.urlTree=s,this.url=o,this.paramsInheritanceStrategy=i,this.urlSerializer=a}recognize(){const n=am(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,n,yt).pipe(gt(e=>{if(null===e)return null;const r=new rm([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},yt,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new di(r,e),o=new IR(this.url,s);return this.inheritParamsAndData(o._root),o}))}inheritParamsAndData(n){const e=n.value,r=CR(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),n.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(n,e,r):this.processSegment(n,e,r,r.segments,s)}processChildren(n,e,r){return jn(Object.keys(r.children)).pipe(Ui(s=>{const o=r.children[s],i=kR(e,s);return this.processSegmentGroup(n,i,o,s)}),JA((s,o)=>s&&o?(s.push(...o),s):null),function o5(t,n=!1){return or((e,r)=>{let s=0;e.subscribe(ir(r,o=>{const i=t(o,s++);(i||n)&&r.next(o),!i&&r.complete()}))})}(s=>null!==s),Kp(null),ZA(),gt(s=>{if(null===s)return null;const o=BR(s);return function Bq(t){t.sort((n,e)=>n.value.outlet===yt?-1:e.value.outlet===yt?1:n.value.outlet.localeCompare(e.value.outlet))}(o),o}))}processSegment(n,e,r,s,o){return jn(e).pipe(Ui(i=>this.processSegmentAgainstRoute(i._injector??n,i,r,s,o)),Vi(i=>!!i),Hi(i=>{if(qw(i))return OR(r,s,o)?ze([]):ze(null);throw i}))}processSegmentAgainstRoute(n,e,r,s,o){if(e.redirectTo||!FR(e,r,s,o))return ze(null);let i;if("**"===e.path){const a=s.length>0?tR(s).parameters:{},l=VR(r)+s.length;i=ze({snapshot:new rm(s,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,UR(e),ks(e),e.component??e._loadedComponent??null,e,zR(r),l,HR(e)),consumedSegments:[],remainingSegments:[]})}else i=$R(r,e,s,n).pipe(gt(({matched:a,consumedSegments:l,remainingSegments:u,parameters:c})=>{if(!a)return null;const d=VR(r)+l.length;return{snapshot:new rm(l,c,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,UR(e),ks(e),e.component??e._loadedComponent??null,e,zR(r),d,HR(e)),consumedSegments:l,remainingSegments:u}}));return i.pipe(No(a=>{if(null===a)return ze(null);const{snapshot:l,consumedSegments:u,remainingSegments:c}=a;n=e._injector??n;const d=e._loadedInjector??n,h=function zq(t){return t.children?t.children:t.loadChildren?t._loadedRoutes:[]}(e),{segmentGroup:f,slicedSegments:p}=am(r,u,c,h.filter(g=>void 0===g.redirectTo));if(0===p.length&&f.hasChildren())return this.processChildren(d,h,f).pipe(gt(g=>null===g?null:[new di(l,g)]));if(0===h.length&&0===p.length)return ze([new di(l,[])]);const m=ks(e)===o;return this.processSegment(d,h,f,p,m?yt:o).pipe(gt(g=>null===g?null:[new di(l,g)]))}))}}function Vq(t){const n=t.value.routeConfig;return n&&""===n.path&&void 0===n.redirectTo}function BR(t){const n=[],e=new Set;for(const r of t){if(!Vq(r)){n.push(r);continue}const s=n.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):n.push(r)}for(const r of e){const s=BR(r.children);n.push(new di(r.value,s))}return n.filter(r=>!e.has(r))}function zR(t){let n=t;for(;n._sourceSegment;)n=n._sourceSegment;return n}function VR(t){let n=t,e=n._segmentIndexShift??0;for(;n._sourceSegment;)n=n._sourceSegment,e+=n._segmentIndexShift??0;return e-1}function UR(t){return t.data||{}}function HR(t){return t.resolve||{}}function WR(t){return"string"==typeof t.title||null===t.title}function Yw(t){return No(n=>{const e=t(n);return e?jn(e).pipe(gt(()=>n)):ze(n)})}let jR=(()=>{class t{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(o=>o.outlet===yt);return r}getResolvedTitleForRoute(e){return e.data[Qc]}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=tt({token:t,factory:function(){return $t(GR)},providedIn:"root"}),t})(),GR=(()=>{class t extends jR{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return t.\u0275fac=function(e){return new(e||t)($e(HA))},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();class Xq{}class Yq{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}}class Jq extends Yq{}const dm=new Me("",{providedIn:"root",factory:()=>({})}),iu=new Me("ROUTES");let Jw=(()=>{class t{constructor(e,r){this.injector=e,this.compiler=r,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return ze(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=Wi(e.loadComponent()).pipe(gt(KR),Tr(o=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=o}),Tw(()=>{this.componentLoaders.delete(e)})),s=new XA(r,()=>new Wo).pipe(Ew());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return ze({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const o=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(gt(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let l,u,c=!1;Array.isArray(a)?u=a:(l=a.create(e).injector,u=eR(l.get(iu,[],qe.Self|qe.Optional)));return{routes:u.map(Gw),injector:l}}),Tw(()=>{this.childrenLoaders.delete(r)})),i=new XA(o,()=>new Wo).pipe(Ew());return this.childrenLoaders.set(r,i),i}loadModuleFactoryOrRoutes(e){return Wi(e()).pipe(gt(KR),gr(s=>s instanceof PT||Array.isArray(s)?ze(s):jn(this.compiler.compileModuleAsync(s))))}}return t.\u0275fac=function(e){return new(e||t)($e(to),$e(Bx))},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function KR(t){return function eK(t){return t&&"object"==typeof t&&"default"in t}(t)?t.default:t}class tK{}class nK{shouldProcessUrl(n){return!0}extract(n){return n}merge(n,e){return n}}function rK(t){throw t}function sK(t,n,e){return n.parse("/")}const oK={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},iK={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};function XR(){const t=$t(aR),n=$t(id),e=$t(nw),r=$t(to),s=$t(Bx),o=$t(iu,{optional:!0})??[],i=$t(dm,{optional:!0})??{},a=$t(GR),l=$t(jR,{optional:!0}),u=$t(tK,{optional:!0}),c=$t(Xq,{optional:!0}),d=new kr(null,t,n,e,r,s,eR(o));return u&&(d.urlHandlingStrategy=u),c&&(d.routeReuseStrategy=c),d.titleStrategy=l??a,function aK(t,n){t.errorHandler&&(n.errorHandler=t.errorHandler),t.malformedUriErrorHandler&&(n.malformedUriErrorHandler=t.malformedUriErrorHandler),t.onSameUrlNavigation&&(n.onSameUrlNavigation=t.onSameUrlNavigation),t.paramsInheritanceStrategy&&(n.paramsInheritanceStrategy=t.paramsInheritanceStrategy),t.urlUpdateStrategy&&(n.urlUpdateStrategy=t.urlUpdateStrategy),t.canceledNavigationResolution&&(n.canceledNavigationResolution=t.canceledNavigationResolution)}(i,d),d}let kr=(()=>{class t{constructor(e,r,s,o,i,a,l){this.rootComponentType=e,this.urlSerializer=r,this.rootContexts=s,this.location=o,this.config=l,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new Wo,this.errorHandler=rK,this.malformedUriErrorHandler=sK,this.navigated=!1,this.lastSuccessfulId=-1,this.afterPreactivation=()=>ze(void 0),this.urlHandlingStrategy=new nK,this.routeReuseStrategy=new Jq,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.canceledNavigationResolution="replace",this.configLoader=i.get(Jw),this.configLoader.onLoadEndListener=h=>this.triggerEvent(new z5(h)),this.configLoader.onLoadStartListener=h=>this.triggerEvent(new B5(h)),this.ngModule=i.get(Ra),this.console=i.get(Nj);const d=i.get(Pn);this.isNgZoneEnabled=d instanceof Pn&&Pn.isInAngularZone(),this.resetConfig(l),this.currentUrlTree=new Oa,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=wR(this.currentUrlTree,this.rootComponentType),this.transitions=new co({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){return this.location.getState()?.\u0275routerPageId}setupNavigations(e){const r=this.events;return e.pipe(ui(s=>0!==s.id),gt(s=>({...s,extractedUrl:this.urlHandlingStrategy.extract(s.rawUrl)})),No(s=>{let o=!1,i=!1;return ze(s).pipe(Tr(a=>{this.currentNavigation={id:a.id,initialUrl:a.rawUrl,extractedUrl:a.extractedUrl,trigger:a.source,extras:a.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),No(a=>{const l=this.browserUrlTree.toString(),u=!this.navigated||a.extractedUrl.toString()!==l||l!==this.currentUrlTree.toString();if(("reload"===this.onSameUrlNavigation||u)&&this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl))return YR(a.source)&&(this.browserUrlTree=a.extractedUrl),ze(a).pipe(No(d=>{const h=this.transitions.getValue();return r.next(new Mw(d.id,this.serializeUrl(d.extractedUrl),d.source,d.restoredState)),h!==this.transitions.getValue()?Go:Promise.resolve(d)}),function Fq(t,n,e,r){return No(s=>function Rq(t,n,e,r,s){return new $q(t,n,e,r,s).apply()}(t,n,e,s.extractedUrl,r).pipe(gt(o=>({...s,urlAfterRedirects:o}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),Tr(d=>{this.currentNavigation={...this.currentNavigation,finalUrl:d.urlAfterRedirects},s.urlAfterRedirects=d.urlAfterRedirects}),function Hq(t,n,e,r,s){return gr(o=>function Pq(t,n,e,r,s,o,i="emptyOnly"){return new Lq(t,n,e,r,s,i,o).recognize().pipe(No(a=>null===a?function Mq(t){return new Fn(n=>n.error(t))}(new Oq):ze(a)))}(t,n,e,o.urlAfterRedirects,r.serialize(o.urlAfterRedirects),r,s).pipe(gt(i=>({...o,targetSnapshot:i}))))}(this.ngModule.injector,this.rootComponentType,this.config,this.urlSerializer,this.paramsInheritanceStrategy),Tr(d=>{if(s.targetSnapshot=d.targetSnapshot,"eager"===this.urlUpdateStrategy){if(!d.extras.skipLocationChange){const f=this.urlHandlingStrategy.merge(d.urlAfterRedirects,d.rawUrl);this.setBrowserUrl(f,d)}this.browserUrlTree=d.urlAfterRedirects}const h=new F5(d.id,this.serializeUrl(d.extractedUrl),this.serializeUrl(d.urlAfterRedirects),d.targetSnapshot);r.next(h)}));if(u&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:h,extractedUrl:f,source:p,restoredState:m,extras:g}=a,y=new Mw(h,this.serializeUrl(f),p,m);r.next(y);const b=wR(f,this.rootComponentType).snapshot;return ze(s={...a,targetSnapshot:b,urlAfterRedirects:f,extras:{...g,skipLocationChange:!1,replaceUrl:!1}})}return this.rawUrlTree=a.rawUrl,a.resolve(null),Go}),Tr(a=>{const l=new O5(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.triggerEvent(l)}),gt(a=>s={...a,guards:oq(a.targetSnapshot,a.currentSnapshot,this.rootContexts)}),function gq(t,n){return gr(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=e;return 0===i.length&&0===o.length?ze({...e,guardsResult:!0}):function yq(t,n,e,r){return jn(t).pipe(gr(s=>function Iq(t,n,e,r,s){const o=n&&n.routeConfig?n.routeConfig.canDeactivate:null;return o&&0!==o.length?ze(o.map(a=>{const l=ad(n)??s,u=su(a,l);return Wi(function fq(t){return t&&cd(t.canDeactivate)}(u)?u.canDeactivate(t,n,e,r):l.runInContext(()=>u(t,n,e,r))).pipe(Vi())})).pipe(ou()):ze(!0)}(s.component,s.route,e,n,r)),Vi(s=>!0!==s,!0))}(i,r,s,t).pipe(gr(a=>a&&function uq(t){return"boolean"==typeof t}(a)?function bq(t,n,e,r){return jn(n).pipe(Ui(s=>Sw(function xq(t,n){return null!==t&&n&&n(new V5(t)),ze(!0)}(s.route.parent,r),function vq(t,n){return null!==t&&n&&n(new H5(t)),ze(!0)}(s.route,r),function Cq(t,n,e){const r=n[n.length-1],o=n.slice(0,n.length-1).reverse().map(i=>function iq(t){const n=t.routeConfig?t.routeConfig.canActivateChild:null;return n&&0!==n.length?{node:t,guards:n}:null}(i)).filter(i=>null!==i).map(i=>KA(()=>ze(i.guards.map(l=>{const u=ad(i.node)??e,c=su(l,u);return Wi(function hq(t){return t&&cd(t.canActivateChild)}(c)?c.canActivateChild(r,t):u.runInContext(()=>c(r,t))).pipe(Vi())})).pipe(ou())));return ze(o).pipe(ou())}(t,s.path,e),function wq(t,n,e){const r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||0===r.length)return ze(!0);const s=r.map(o=>KA(()=>{const i=ad(n)??e,a=su(o,i);return Wi(function dq(t){return t&&cd(t.canActivate)}(a)?a.canActivate(n,t):i.runInContext(()=>a(n,t))).pipe(Vi())}));return ze(s).pipe(ou())}(t,s.route,e))),Vi(s=>!0!==s,!0))}(r,o,t,n):ze(a)),gt(a=>({...e,guardsResult:a})))})}(this.ngModule.injector,a=>this.triggerEvent(a)),Tr(a=>{if(s.guardsResult=a.guardsResult,Pa(a.guardsResult))throw _R(0,a.guardsResult);const l=new M5(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot,!!a.guardsResult);this.triggerEvent(l)}),ui(a=>!!a.guardsResult||(this.restoreHistory(a),this.cancelNavigationTransition(a,"",3),!1)),Yw(a=>{if(a.guards.canActivateChecks.length)return ze(a).pipe(Tr(l=>{const u=new P5(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(u)}),No(l=>{let u=!1;return ze(l).pipe(function Wq(t,n){return gr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return ze(e);let o=0;return jn(s).pipe(Ui(i=>function jq(t,n,e,r){const s=t.routeConfig,o=t._resolve;return void 0!==s?.title&&!WR(s)&&(o[Qc]=s.title),function Gq(t,n,e,r){const s=function qq(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}(t);if(0===s.length)return ze({});const o={};return jn(s).pipe(gr(i=>function Kq(t,n,e,r){const s=ad(n)??r,o=su(t,s);return Wi(o.resolve?o.resolve(n,e):s.runInContext(()=>o(n,e)))}(t[i],n,e,r).pipe(Vi(),Tr(a=>{o[i]=a}))),Nw(1),function i5(t){return gt(()=>t)}(o),Hi(i=>qw(i)?Go:Jc(i)))}(o,t,n,r).pipe(gt(i=>(t._resolvedData=i,t.data=CR(t,e).resolve,s&&WR(s)&&(t.data[Qc]=s.title),null)))}(i.route,r,t,n)),Tr(()=>o++),Nw(1),gr(i=>o===s.length?ze(e):Go))})}(this.paramsInheritanceStrategy,this.ngModule.injector),Tr({next:()=>u=!0,complete:()=>{u||(this.restoreHistory(l),this.cancelNavigationTransition(l,"",2))}}))}),Tr(l=>{const u=new L5(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(u)}))}),Yw(a=>{const l=u=>{const c=[];u.routeConfig?.loadComponent&&!u.routeConfig._loadedComponent&&c.push(this.configLoader.loadComponent(u.routeConfig).pipe(Tr(d=>{u.component=d}),gt(()=>{})));for(const d of u.children)c.push(...l(d));return c};return GA(l(a.targetSnapshot.root)).pipe(Kp(),Zc(1))}),Yw(()=>this.afterPreactivation()),gt(a=>{const l=function K5(t,n,e){const r=od(t,n._root,e?e._root:void 0);return new xR(r,n)}(this.routeReuseStrategy,a.targetSnapshot,a.currentRouterState);return s={...a,targetRouterState:l}}),Tr(a=>{this.currentUrlTree=a.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(a.urlAfterRedirects,a.rawUrl),this.routerState=a.targetRouterState,"deferred"===this.urlUpdateStrategy&&(a.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,a),this.browserUrlTree=a.urlAfterRedirects)}),((t,n,e)=>gt(r=>(new sq(n,r.targetRouterState,r.currentRouterState,e).activate(t),r)))(this.rootContexts,this.routeReuseStrategy,a=>this.triggerEvent(a)),Tr({next(){o=!0},complete(){o=!0}}),Tw(()=>{o||i||this.cancelNavigationTransition(s,"",1),this.currentNavigation?.id===s.id&&(this.currentNavigation=null)}),Hi(a=>{if(i=!0,NR(a)){ER(a)||(this.navigated=!0,this.restoreHistory(s,!0));const l=new nm(s.id,this.serializeUrl(s.extractedUrl),a.message,a.cancellationCode);if(r.next(l),ER(a)){const u=this.urlHandlingStrategy.merge(a.url,this.rawUrlTree),c={skipLocationChange:s.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||YR(s.source)};this.scheduleNavigation(u,"imperative",null,c,{resolve:s.resolve,reject:s.reject,promise:s.promise})}else s.resolve(!1)}else{this.restoreHistory(s,!0);const l=new yR(s.id,this.serializeUrl(s.extractedUrl),a,s.targetSnapshot??void 0);r.next(l);try{s.resolve(this.errorHandler(a))}catch(u){s.reject(u)}}return Go}))}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}setTransition(e){this.transitions.next({...this.transitions.value,...e})}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{const s={replaceUrl:!0},o=e.state?.navigationId?e.state:null;if(o){const a={...o};delete a.navigationId,delete a.\u0275routerPageId,0!==Object.keys(a).length&&(s.state=a)}const i=this.parseUrl(e.url);this.scheduleNavigation(i,r,o,s)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){this.config=e.map(Gw),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:o,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,u=s||this.routerState.root,c=l?this.currentUrlTree.fragment:i;let d=null;switch(a){case"merge":d={...this.currentUrlTree.queryParams,...o};break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=o||null}return null!==d&&(d=this.removeEmptyProps(d)),N5(u,this.currentUrlTree,e,d,c??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=Pa(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(o,"imperative",null,r)}navigate(e,r={skipLocationChange:!1}){return function lK(t){for(let n=0;n<t.length;n++){if(null==t[n])throw new xe(4008,false)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...oK}:!1===r?{...iK}:r,Pa(e))return rR(this.currentUrlTree,e,s);const o=this.parseUrl(e);return rR(this.currentUrlTree,o,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const o=e[s];return null!=o&&(r[s]=o),r},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new La(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,this.titleStrategy?.updateTitle(this.routerState.snapshot),e.resolve(!0)},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}scheduleNavigation(e,r,s,o,i){if(this.disposed)return Promise.resolve(!1);let a,l,u;i?(a=i.resolve,l=i.reject,u=i.promise):u=new Promise((h,f)=>{a=h,l=f});const c=++this.navigationId;let d;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(s=this.location.getState()),d=s&&s.\u0275routerPageId?s.\u0275routerPageId:o.replaceUrl||o.skipLocationChange?this.browserPageId??0:(this.browserPageId??0)+1):d=0,this.setTransition({id:c,targetPageId:d,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:o,resolve:a,reject:l,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(h=>Promise.reject(h))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),o={...r.extras.state,...this.generateNgRouterState(r.id,r.targetPageId)};this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",o):this.location.go(s,"",o)}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==this.currentNavigation?.finalUrl||0===s?this.currentUrlTree===this.currentNavigation?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(s)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,r,s){const o=new nm(e.id,this.serializeUrl(e.extractedUrl),r,s);this.triggerEvent(o),e.resolve(!1)}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return t.\u0275fac=function(e){Pv()},t.\u0275prov=tt({token:t,factory:function(){return XR()},providedIn:"root"}),t})();function YR(t){return"imperative"!==t}class JR{}let dK=(()=>{class t{constructor(e,r,s,o,i){this.router=e,this.injector=s,this.preloadingStrategy=o,this.loader=i}setUpPreloading(){this.subscription=this.router.events.pipe(ui(e=>e instanceof La),Ui(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const o of r){o.providers&&!o._injector&&(o._injector=bp(o.providers,e,`Route: ${o.path}`));const i=o._injector??e,a=o._loadedInjector??i;o.loadChildren&&!o._loadedRoutes&&void 0===o.canLoad||o.loadComponent&&!o._loadedComponent?s.push(this.preloadConfig(i,o)):(o.children||o._loadedRoutes)&&s.push(this.processRoutes(a,o.children??o._loadedRoutes))}return jn(s).pipe(fl())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):ze(null);const o=s.pipe(gr(i=>null===i?ze(void 0):(r._loadedRoutes=i.routes,r._loadedInjector=i.injector,this.processRoutes(i.injector??e,i.routes))));return r.loadComponent&&!r._loadedComponent?jn([o,this.loader.loadComponent(r)]).pipe(fl()):o})}}return t.\u0275fac=function(e){return new(e||t)($e(kr),$e(Bx),$e(ei),$e(JR),$e(Jw))},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Qw=new Me("");let ZR=(()=>{class t{constructor(e,r,s,o={}){this.router=e,this.viewportScroller=r,this.zone=s,this.options=o,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},o.scrollPositionRestoration=o.scrollPositionRestoration||"disabled",o.anchorScrolling=o.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof Mw?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof La&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof bR&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.router.triggerEvent(new bR(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){Pv()},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();function lu(t,n){return{\u0275kind:t,\u0275providers:n}}function e$(){const t=$t(to);return n=>{const e=t.get(Ep);if(n!==e.components[0])return;const r=t.get(kr),s=t.get(t$);1===t.get(t0)&&r.initialNavigation(),t.get(n$,null,qe.Optional)?.setUpPreloading(),t.get(Qw,null,qe.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.next(),s.complete()}}const t$=new Me("",{factory:()=>new Wo}),t0=new Me("",{providedIn:"root",factory:()=>1});const n$=new Me("");function gK(t){return lu(0,[{provide:n$,useExisting:dK},{provide:JR,useExisting:t}])}const r$=new Me("ROUTER_FORROOT_GUARD"),yK=[nw,{provide:aR,useClass:kw},{provide:kr,useFactory:XR},id,{provide:ru,useFactory:function QR(t){return t.routerState.root},deps:[kr]},Jw,[]];function bK(){return new $k("Router",kr)}let s$=(()=>{class t{constructor(e){}static forRoot(e,r){return{ngModule:t,providers:[yK,[],{provide:iu,multi:!0,useValue:e},{provide:r$,useFactory:CK,deps:[[kr,new vc,new xc]]},{provide:dm,useValue:r||{}},r?.useHash?{provide:Fa,useClass:mG}:{provide:Fa,useClass:nA},{provide:Qw,useFactory:()=>{const t=$t(kr),n=$t(P6),e=$t(Pn),r=$t(dm);return r.scrollOffset&&n.setOffset(r.scrollOffset),new ZR(t,n,e,r)}},r?.preloadingStrategy?gK(r.preloadingStrategy).\u0275providers:[],{provide:$k,multi:!0,useFactory:bK},r?.initialNavigation?IK(r):[],[{provide:o$,useFactory:e$},{provide:Sk,multi:!0,useExisting:o$}]]}}static forChild(e){return{ngModule:t,providers:[{provide:iu,multi:!0,useValue:e}]}}}return t.\u0275fac=function(e){return new(e||t)($e(r$,8))},t.\u0275mod=Ai({type:t}),t.\u0275inj=Ko({imports:[Ww]}),t})();function CK(t){return"guarded"}function IK(t){return["disabled"===t.initialNavigation?lu(3,[{provide:Dp,multi:!0,useFactory:()=>{const n=$t(kr);return()=>{n.setUpLocationChangeListener()}}},{provide:t0,useValue:2}]).\u0275providers:[],"enabledBlocking"===t.initialNavigation?lu(2,[{provide:t0,useValue:0},{provide:Dp,multi:!0,deps:[to],useFactory:n=>{const e=n.get(fG,Promise.resolve());let r=!1;return()=>e.then(()=>new Promise(o=>{const i=n.get(kr),a=n.get(t$);(function s(o){n.get(kr).events.pipe(ui(a=>a instanceof La||a instanceof nm||a instanceof yR),gt(a=>a instanceof La||a instanceof nm&&(0===a.code||1===a.code)&&null),ui(a=>null!==a),Zc(1)).subscribe(()=>{o()})})(()=>{o(!0),r=!0}),i.afterPreactivation=()=>(o(!0),r||a.closed?ze(void 0):a),i.initialNavigation()}))}}]).\u0275providers:[]]}const o$=new Me("");class _K{constructor(n){this.revealed=!1,this.favorited=!1,this.setup=n.setup,this.delivery=n.delivery,this.id=n.id}}class fm{}class n0{}class hi{constructor(n){this.normalizedNames=new Map,this.lazyUpdate=null,n?this.lazyInit="string"==typeof n?()=>{this.headers=new Map,n.split("\n").forEach(e=>{const r=e.indexOf(":");if(r>0){const s=e.slice(0,r),o=s.toLowerCase(),i=e.slice(r+1).trim();this.maybeSetNormalizedName(s,o),this.headers.has(o)?this.headers.get(o).push(i):this.headers.set(o,[i])}})}:()=>{this.headers=new Map,Object.keys(n).forEach(e=>{let r=n[e];const s=e.toLowerCase();"string"==typeof r&&(r=[r]),r.length>0&&(this.headers.set(s,r),this.maybeSetNormalizedName(e,s))})}:this.headers=new Map}has(n){return this.init(),this.headers.has(n.toLowerCase())}get(n){this.init();const e=this.headers.get(n.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(n){return this.init(),this.headers.get(n.toLowerCase())||null}append(n,e){return this.clone({name:n,value:e,op:"a"})}set(n,e){return this.clone({name:n,value:e,op:"s"})}delete(n,e){return this.clone({name:n,value:e,op:"d"})}maybeSetNormalizedName(n,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,n)}init(){this.lazyInit&&(this.lazyInit instanceof hi?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(n=>this.applyUpdate(n)),this.lazyUpdate=null))}copyFrom(n){n.init(),Array.from(n.headers.keys()).forEach(e=>{this.headers.set(e,n.headers.get(e)),this.normalizedNames.set(e,n.normalizedNames.get(e))})}clone(n){const e=new hi;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof hi?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([n]),e}applyUpdate(n){const e=n.name.toLowerCase();switch(n.op){case"a":case"s":let r=n.value;if("string"==typeof r&&(r=[r]),0===r.length)return;this.maybeSetNormalizedName(n.name,e);const s=("a"===n.op?this.headers.get(e):void 0)||[];s.push(...r),this.headers.set(e,s);break;case"d":const o=n.value;if(o){let i=this.headers.get(e);if(!i)return;i=i.filter(a=>-1===o.indexOf(a)),0===i.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,i)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(n){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>n(this.normalizedNames.get(e),this.headers.get(e)))}}class SK{encodeKey(n){return i$(n)}encodeValue(n){return i$(n)}decodeKey(n){return decodeURIComponent(n)}decodeValue(n){return decodeURIComponent(n)}}const NK=/%(\d[a-f0-9])/gi,TK={40:"@","3A":":",24:"$","2C":",","3B":";","3D":"=","3F":"?","2F":"/"};function i$(t){return encodeURIComponent(t).replace(NK,(n,e)=>TK[e]??n)}function pm(t){return`${t}`}class ji{constructor(n={}){if(this.updates=null,this.cloneFrom=null,this.encoder=n.encoder||new SK,n.fromString){if(n.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function EK(t,n){const e=new Map;return t.length>0&&t.replace(/^\?/,"").split("&").forEach(s=>{const o=s.indexOf("="),[i,a]=-1==o?[n.decodeKey(s),""]:[n.decodeKey(s.slice(0,o)),n.decodeValue(s.slice(o+1))],l=e.get(i)||[];l.push(a),e.set(i,l)}),e}(n.fromString,this.encoder)}else n.fromObject?(this.map=new Map,Object.keys(n.fromObject).forEach(e=>{const r=n.fromObject[e],s=Array.isArray(r)?r.map(pm):[pm(r)];this.map.set(e,s)})):this.map=null}has(n){return this.init(),this.map.has(n)}get(n){this.init();const e=this.map.get(n);return e?e[0]:null}getAll(n){return this.init(),this.map.get(n)||null}keys(){return this.init(),Array.from(this.map.keys())}append(n,e){return this.clone({param:n,value:e,op:"a"})}appendAll(n){const e=[];return Object.keys(n).forEach(r=>{const s=n[r];Array.isArray(s)?s.forEach(o=>{e.push({param:r,value:o,op:"a"})}):e.push({param:r,value:s,op:"a"})}),this.clone(e)}set(n,e){return this.clone({param:n,value:e,op:"s"})}delete(n,e){return this.clone({param:n,value:e,op:"d"})}toString(){return this.init(),this.keys().map(n=>{const e=this.encoder.encodeKey(n);return this.map.get(n).map(r=>e+"="+this.encoder.encodeValue(r)).join("&")}).filter(n=>""!==n).join("&")}clone(n){const e=new ji({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(n),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(n=>this.map.set(n,this.cloneFrom.map.get(n))),this.updates.forEach(n=>{switch(n.op){case"a":case"s":const e=("a"===n.op?this.map.get(n.param):void 0)||[];e.push(pm(n.value)),this.map.set(n.param,e);break;case"d":if(void 0===n.value){this.map.delete(n.param);break}{let r=this.map.get(n.param)||[];const s=r.indexOf(pm(n.value));-1!==s&&r.splice(s,1),r.length>0?this.map.set(n.param,r):this.map.delete(n.param)}}}),this.cloneFrom=this.updates=null)}}class kK{constructor(){this.map=new Map}set(n,e){return this.map.set(n,e),this}get(n){return this.map.has(n)||this.map.set(n,n.defaultValue()),this.map.get(n)}delete(n){return this.map.delete(n),this}has(n){return this.map.has(n)}keys(){return this.map.keys()}}function a$(t){return typeof ArrayBuffer<"u"&&t instanceof ArrayBuffer}function l$(t){return typeof Blob<"u"&&t instanceof Blob}function u$(t){return typeof FormData<"u"&&t instanceof FormData}class fd{constructor(n,e,r,s){let o;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=n.toUpperCase(),function AK(t){switch(t){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==r?r:null,o=s):o=r,o&&(this.reportProgress=!!o.reportProgress,this.withCredentials=!!o.withCredentials,o.responseType&&(this.responseType=o.responseType),o.headers&&(this.headers=o.headers),o.context&&(this.context=o.context),o.params&&(this.params=o.params)),this.headers||(this.headers=new hi),this.context||(this.context=new kK),this.params){const i=this.params.toString();if(0===i.length)this.urlWithParams=e;else{const a=e.indexOf("?");this.urlWithParams=e+(-1===a?"?":a<e.length-1?"&":"")+i}}else this.params=new ji,this.urlWithParams=e}serializeBody(){return null===this.body?null:a$(this.body)||l$(this.body)||u$(this.body)||function RK(t){return typeof URLSearchParams<"u"&&t instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof ji?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||u$(this.body)?null:l$(this.body)?this.body.type||null:a$(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof ji?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(n={}){const e=n.method||this.method,r=n.url||this.url,s=n.responseType||this.responseType,o=void 0!==n.body?n.body:this.body,i=void 0!==n.withCredentials?n.withCredentials:this.withCredentials,a=void 0!==n.reportProgress?n.reportProgress:this.reportProgress;let l=n.headers||this.headers,u=n.params||this.params;const c=n.context??this.context;return void 0!==n.setHeaders&&(l=Object.keys(n.setHeaders).reduce((d,h)=>d.set(h,n.setHeaders[h]),l)),n.setParams&&(u=Object.keys(n.setParams).reduce((d,h)=>d.set(h,n.setParams[h]),u)),new fd(e,r,o,{params:u,headers:l,context:c,reportProgress:a,responseType:s,withCredentials:i})}}var zn=(()=>((zn=zn||{})[zn.Sent=0]="Sent",zn[zn.UploadProgress=1]="UploadProgress",zn[zn.ResponseHeader=2]="ResponseHeader",zn[zn.DownloadProgress=3]="DownloadProgress",zn[zn.Response=4]="Response",zn[zn.User=5]="User",zn))();class r0{constructor(n,e=200,r="OK"){this.headers=n.headers||new hi,this.status=void 0!==n.status?n.status:e,this.statusText=n.statusText||r,this.url=n.url||null,this.ok=this.status>=200&&this.status<300}}class s0 extends r0{constructor(n={}){super(n),this.type=zn.ResponseHeader}clone(n={}){return new s0({headers:n.headers||this.headers,status:void 0!==n.status?n.status:this.status,statusText:n.statusText||this.statusText,url:n.url||this.url||void 0})}}class mm extends r0{constructor(n={}){super(n),this.type=zn.Response,this.body=void 0!==n.body?n.body:null}clone(n={}){return new mm({body:void 0!==n.body?n.body:this.body,headers:n.headers||this.headers,status:void 0!==n.status?n.status:this.status,statusText:n.statusText||this.statusText,url:n.url||this.url||void 0})}}class c$ extends r0{constructor(n){super(n,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?`Http failure during parsing for ${n.url||"(unknown url)"}`:`Http failure response for ${n.url||"(unknown url)"}: ${n.status} ${n.statusText}`,this.error=n.error||null}}function o0(t,n){return{body:n,headers:t.headers,context:t.context,observe:t.observe,params:t.params,reportProgress:t.reportProgress,responseType:t.responseType,withCredentials:t.withCredentials}}let d$=(()=>{class t{constructor(e){this.handler=e}request(e,r,s={}){let o;if(e instanceof fd)o=e;else{let l,u;l=s.headers instanceof hi?s.headers:new hi(s.headers),s.params&&(u=s.params instanceof ji?s.params:new ji({fromObject:s.params})),o=new fd(e,r,void 0!==s.body?s.body:null,{headers:l,context:s.context,params:u,reportProgress:s.reportProgress,responseType:s.responseType||"json",withCredentials:s.withCredentials})}const i=ze(o).pipe(Ui(l=>this.handler.handle(l)));if(e instanceof fd||"events"===s.observe)return i;const a=i.pipe(ui(l=>l instanceof mm));switch(s.observe||"body"){case"body":switch(o.responseType){case"arraybuffer":return a.pipe(gt(l=>{if(null!==l.body&&!(l.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return l.body}));case"blob":return a.pipe(gt(l=>{if(null!==l.body&&!(l.body instanceof Blob))throw new Error("Response is not a Blob.");return l.body}));case"text":return a.pipe(gt(l=>{if(null!==l.body&&"string"!=typeof l.body)throw new Error("Response is not a string.");return l.body}));default:return a.pipe(gt(l=>l.body))}case"response":return a;default:throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)}}delete(e,r={}){return this.request("DELETE",e,r)}get(e,r={}){return this.request("GET",e,r)}head(e,r={}){return this.request("HEAD",e,r)}jsonp(e,r){return this.request("JSONP",e,{params:(new ji).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,r={}){return this.request("OPTIONS",e,r)}patch(e,r,s={}){return this.request("PATCH",e,o0(s,r))}post(e,r,s={}){return this.request("POST",e,o0(s,r))}put(e,r,s={}){return this.request("PUT",e,o0(s,r))}}return t.\u0275fac=function(e){return new(e||t)($e(fm))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();function h$(t,n){return n(t)}function $K(t,n){return(e,r)=>n.intercept(e,{handle:s=>t(s,r)})}const OK=new Me("HTTP_INTERCEPTORS"),pd=new Me("HTTP_INTERCEPTOR_FNS");function MK(){let t=null;return(n,e)=>(null===t&&(t=($t(OK,{optional:!0})??[]).reduceRight($K,h$)),t(n,e))}let f$=(()=>{class t extends fm{constructor(e,r){super(),this.backend=e,this.injector=r,this.chain=null}handle(e){if(null===this.chain){const r=Array.from(new Set(this.injector.get(pd)));this.chain=r.reduceRight((s,o)=>function FK(t,n,e){return(r,s)=>e.runInContext(()=>n(r,o=>t(o,s)))}(s,o,this.injector),h$)}return this.chain(e,r=>this.backend.handle(r))}}return t.\u0275fac=function(e){return new(e||t)($e(n0),$e(ei))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();const zK=/^\)\]\}',?\n/;let m$=(()=>{class t{constructor(e){this.xhrFactory=e}handle(e){if("JSONP"===e.method)throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");return new Fn(r=>{const s=this.xhrFactory.build();if(s.open(e.method,e.urlWithParams),e.withCredentials&&(s.withCredentials=!0),e.headers.forEach((f,p)=>s.setRequestHeader(f,p.join(","))),e.headers.has("Accept")||s.setRequestHeader("Accept","application/json, text/plain, */*"),!e.headers.has("Content-Type")){const f=e.detectContentTypeHeader();null!==f&&s.setRequestHeader("Content-Type",f)}if(e.responseType){const f=e.responseType.toLowerCase();s.responseType="json"!==f?f:"text"}const o=e.serializeBody();let i=null;const a=()=>{if(null!==i)return i;const f=s.statusText||"OK",p=new hi(s.getAllResponseHeaders()),m=function VK(t){return"responseURL"in t&&t.responseURL?t.responseURL:/^X-Request-URL:/m.test(t.getAllResponseHeaders())?t.getResponseHeader("X-Request-URL"):null}(s)||e.url;return i=new s0({headers:p,status:s.status,statusText:f,url:m}),i},l=()=>{let{headers:f,status:p,statusText:m,url:g}=a(),y=null;204!==p&&(y=typeof s.response>"u"?s.responseText:s.response),0===p&&(p=y?200:0);let b=p>=200&&p<300;if("json"===e.responseType&&"string"==typeof y){const v=y;y=y.replace(zK,"");try{y=""!==y?JSON.parse(y):null}catch(x){y=v,b&&(b=!1,y={error:x,text:y})}}b?(r.next(new mm({body:y,headers:f,status:p,statusText:m,url:g||void 0})),r.complete()):r.error(new c$({error:y,headers:f,status:p,statusText:m,url:g||void 0}))},u=f=>{const{url:p}=a(),m=new c$({error:f,status:s.status||0,statusText:s.statusText||"Unknown Error",url:p||void 0});r.error(m)};let c=!1;const d=f=>{c||(r.next(a()),c=!0);let p={type:zn.DownloadProgress,loaded:f.loaded};f.lengthComputable&&(p.total=f.total),"text"===e.responseType&&!!s.responseText&&(p.partialText=s.responseText),r.next(p)},h=f=>{let p={type:zn.UploadProgress,loaded:f.loaded};f.lengthComputable&&(p.total=f.total),r.next(p)};return s.addEventListener("load",l),s.addEventListener("error",u),s.addEventListener("timeout",u),s.addEventListener("abort",u),e.reportProgress&&(s.addEventListener("progress",d),null!==o&&s.upload&&s.upload.addEventListener("progress",h)),s.send(o),r.next({type:zn.Sent}),()=>{s.removeEventListener("error",u),s.removeEventListener("abort",u),s.removeEventListener("load",l),s.removeEventListener("timeout",u),e.reportProgress&&(s.removeEventListener("progress",d),null!==o&&s.upload&&s.upload.removeEventListener("progress",h)),s.readyState!==s.DONE&&s.abort()}})}}return t.\u0275fac=function(e){return new(e||t)($e(CA))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();const a0=new Me("XSRF_ENABLED"),g$="XSRF-TOKEN",y$=new Me("XSRF_COOKIE_NAME",{providedIn:"root",factory:()=>g$}),b$="X-XSRF-TOKEN",v$=new Me("XSRF_HEADER_NAME",{providedIn:"root",factory:()=>b$});class x${}let UK=(()=>{class t{constructor(e,r,s){this.doc=e,this.platform=r,this.cookieName=s,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const e=this.doc.cookie||"";return e!==this.lastCookieString&&(this.parseCount++,this.lastToken=hA(e,this.cookieName),this.lastCookieString=e),this.lastToken}}return t.\u0275fac=function(e){return new(e||t)($e(Vr),$e(Lx),$e(y$))},t.\u0275prov=tt({token:t,factory:t.\u0275fac}),t})();function HK(t,n){const e=t.url.toLowerCase();if(!$t(a0)||"GET"===t.method||"HEAD"===t.method||e.startsWith("http://")||e.startsWith("https://"))return n(t);const r=$t(x$).getToken(),s=$t(v$);return null!=r&&!t.headers.has(s)&&(t=t.clone({headers:t.headers.set(s,r)})),n(t)}var Nn=(()=>((Nn=Nn||{})[Nn.Interceptors=0]="Interceptors",Nn[Nn.LegacyInterceptors=1]="LegacyInterceptors",Nn[Nn.CustomXsrfConfiguration=2]="CustomXsrfConfiguration",Nn[Nn.NoXsrfProtection=3]="NoXsrfProtection",Nn[Nn.JsonpSupport=4]="JsonpSupport",Nn[Nn.RequestsMadeViaParent=5]="RequestsMadeViaParent",Nn))();function uu(t,n){return{\u0275kind:t,\u0275providers:n}}function WK(...t){const n=[d$,m$,f$,{provide:fm,useExisting:f$},{provide:n0,useExisting:m$},{provide:pd,useValue:HK,multi:!0},{provide:a0,useValue:!0},{provide:x$,useClass:UK}];for(const e of t)n.push(...e.\u0275providers);return function yV(t){return{\u0275providers:t}}(n)}const w$=new Me("LEGACY_INTERCEPTOR_FN");function GK({cookieName:t,headerName:n}){const e=[];return void 0!==t&&e.push({provide:y$,useValue:t}),void 0!==n&&e.push({provide:v$,useValue:n}),uu(Nn.CustomXsrfConfiguration,e)}let qK=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Ai({type:t}),t.\u0275inj=Ko({providers:[WK(uu(Nn.LegacyInterceptors,[{provide:w$,useFactory:MK},{provide:pd,useExisting:w$,multi:!0}]),GK({cookieName:g$,headerName:b$}))]}),t})(),KK=(()=>{class t{constructor(e){this.http=e,this.jokes=[],this.requestURL="https://v2.jokeapi.dev/joke/Programming?type=twopart&amount=10",this.idx=0,this.status=""}generateJokes(){this.status="Generating jokess from API...",this.http.get(this.requestURL).toPromise().then(r=>{for(var s of r.jokes)this.jokes.push(new _K(s))}).then(()=>{this.status="Successfully generated jokes!",-1==this.idx&&(this.idx=0)})}discardJokes(){this.jokes.length=0,this.idx=-1,this.status="Discarded all jokes!"}moveIdx(e){console.log("Call to moveidc"),console.log(this.idx),-1!=this.idx&&(this.idx+=e,this.idx>this.jokes.length-1?this.idx=this.idx%this.jokes.length:this.idx<0&&(this.idx+=this.jokes.length),console.log(this.idx))}moveCurrentJoke(){var e=this.getCurrentJoke();return e&&this.moveIdx(1),e}getCurrentJoke(){return null!=this.jokes[this.idx]?this.jokes[this.idx]:null}revealCurrentJoke(){null!=this.jokes[this.idx]&&(this.jokes[this.idx].revealed=!0)}favoriteCurrentJoke(){null!=this.jokes[this.idx]&&(this.jokes[this.idx].favorited=!0)}unfavoriteCurrentJoke(){null!=this.jokes[this.idx]&&(this.jokes[this.idx].favorited=!1)}unfavoriteJoke(e){this.jokes.forEach((r,s)=>{r.id==e&&(r.favorited=!1)})}get CurrentJokeSetup(){return null!=this.jokes[this.idx]?this.jokes[this.idx].setup:"No joke is currently loaded"}get CurrentJokeDelivery(){return null!=this.jokes[this.idx]&&this.jokes[this.idx].revealed?this.jokes[this.idx].delivery:""}get length(){return this.jokes.length}get activeIndex(){return 0==this.jokes.length?-1:this.idx}get statusString(){return this.status}get isFavorite(){return null!=this.jokes[this.idx]&&this.jokes[this.idx].favorited}}return t.\u0275fac=function(e){return new(e||t)($e(d$))},t.\u0275prov=tt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function XK(t,n){if(1&t){const e=ql();Je(0,"div")(1,"h1"),_t(2),Ze(),Je(3,"h2"),_t(4),Ze(),Je(5,"button",3),br("click",function(){const o=Zs(e).$implicit;return Qs(Er(2).favorite(o))}),_t(6,"Remove"),Ze(),qn(7,"br"),Ze()}if(2&t){const e=n.$implicit;Sn(2),Eo(e.setup),Sn(2),Eo(e.delivery)}}function YK(t,n){if(1&t&&(Je(0,"div",6)(1,"h3"),_t(2,"Your Favorites"),Ze(),Je(3,"div",7),Es(4,XK,8,2,"div",8),Ze()()),2&t){const e=Er();Sn(4),hs("ngForOf",e.favoriteValues)}}function JK(t,n){if(1&t){const e=ql();Je(0,"div",29)(1,"button",30),br("click",function(){return Zs(e),Qs(Er(2).prev())}),qn(2,"img",31)(3,"img",16)(4,"img",31),_t(5," Prev "),Ze(),Je(6,"h2"),_t(7),Ze(),Je(8,"button",32),br("click",function(){return Zs(e),Qs(Er(2).next())}),_t(9," Next "),qn(10,"img",33)(11,"img",16)(12,"img",33),Ze()()}if(2&t){const e=Er(2);Sn(7),Eo(e.indexString())}}function ZK(t,n){if(1&t){const e=ql();Je(0,"button",34),br("click",function(){return Zs(e),Qs(Er(2).reveal())}),_t(1," Reveal "),qn(2,"img",25),Ze()}}function QK(t,n){if(1&t&&(Je(0,"p",18),_t(1),Ze()),2&t){const e=Er(2);Sn(1),Eo(e.delivery)}}function eX(t,n){if(1&t&&(Je(0,"p",35),_t(1),Ze()),2&t){const e=Er(2);Sn(1),Eo(e.status)}}function tX(t,n){1&t&&qn(0,"img",36)}function nX(t,n){1&t&&qn(0,"img",37)}function rX(t,n){if(1&t){const e=ql();Je(0,"div"),Es(1,JK,13,1,"div",9),Je(2,"div",10)(3,"div",11)(4,"button",12),br("click",function(){return Zs(e),Qs(Er().discardAll())}),_t(5," Discard All "),Je(6,"div",13),qn(7,"img",14)(8,"img",14),Ze()(),Je(9,"button",15),br("click",function(){return Zs(e),Qs(Er().generateJokes())}),_t(10," Generate "),Je(11,"div",13),qn(12,"img",16)(13,"img",16),Ze()()(),Je(14,"div",17)(15,"p",18),_t(16),Ze(),Es(17,ZK,3,0,"button",19),Es(18,QK,2,1,"p",20),Je(19,"p",21),_t(20),Ze(),Es(21,eX,2,1,"p",22),Ze(),Je(22,"div",11)(23,"button",23),br("mousedown",function(){return Zs(e),Qs(Er().zoom())})("mouseup",function(){return Zs(e),Qs(Er().unzoom())}),qn(24,"img",24),Je(25,"div",13),qn(26,"img",25)(27,"img",25),Ze()(),Je(28,"button",26),br("click",function(){return Zs(e),Qs(Er().favorite())}),Es(29,tX,1,0,"img",27),Es(30,nX,1,0,"img",28),Je(31,"div"),qn(32,"img",14),Ze()()()()()}if(2&t){const e=Er();Sn(1),hs("ngIf","search"==e.mode),Sn(15),Eo(e.setup),Sn(1),hs("ngIf",!e.delivery&&-1!=e.jokeService.activeIndex),Sn(1),hs("ngIf",e.delivery),Sn(2),Eo(e.feedbackString),Sn(1),hs("ngIf",!e.feedbackString),Sn(8),hs("ngIf",!e.favorited),Sn(1),hs("ngIf",e.favorited)}}let C$=(()=>{class t{constructor(e){this.jokeService=e,this.mode="search",this.favorites=new Map,this.favoriteValues=[],this.feedbackString="",e.generateJokes()}favorite(e=this.jokeService.getCurrentJoke()){if(null!=e)return this.favorites.has(e.id)?(this.favorites.delete(e.id),this.favoriteValues=this.favoriteValues.filter(r=>r.id!=e?.id),this.jokeService.unfavoriteJoke(e.id),void(this.feedbackString="Removed joke from favorites")):(this.favorites.set(e.id,e),this.favoriteValues.push(e),this.jokeService.favoriteCurrentJoke(),void(this.feedbackString="Added current joke to you favorites!!"));this.feedbackString="There is no joke to favorite"}indexString(){return`${this.jokeService.activeIndex+1}/${this.jokeService.length}`}next(){this.jokeService.moveIdx(1),this.feedbackString=" "}prev(){this.jokeService.moveIdx(-1),this.feedbackString=" "}discardAll(){this.jokeService.discardJokes(),this.feedbackString=""}generateJokes(){this.jokeService.generateJokes(),this.feedbackString=""}reveal(){this.jokeService.revealCurrentJoke()}zoom(){var e=document.getElementsByClassName("joke");e[0].classList.add("zoomed"),e[1].classList.add("zoomed")}unzoom(){var e=document.getElementsByClassName("joke");e[0].classList.remove("zoomed"),e[1].classList.remove("zoomed")}get setup(){return this.jokeService.CurrentJokeSetup}get delivery(){return this.jokeService.CurrentJokeDelivery}get status(){return this.jokeService.statusString}get favorited(){return this.jokeService.isFavorite}}return t.\u0275fac=function(e){return new(e||t)(Ke(KK))},t.\u0275cmp=ya({type:t,selectors:[["app-jokes-generating-interface"]],decls:17,vars:2,consts:[[1,"container"],[1,"title"],[1,"mode"],[3,"click"],["class","favorites",4,"ngIf"],[4,"ngIf"],[1,"favorites"],[1,"list"],[4,"ngFor","ngForOf"],["class","swipe",4,"ngIf"],[1,"columns"],[1,"button_column"],["id","discardButton",3,"click"],[1,"image_group"],["src","./assets/images/pointed_hand.png"],["id","generateButton",3,"click"],["src","./assets/images/open_hand.png"],[1,"content"],[1,"joke"],["id","#revealButton",3,"click",4,"ngIf"],["class","joke",4,"ngIf"],["id","feedback"],["id","status",4,"ngIf"],["id","zoom",3,"mousedown","mouseup"],["src","./assets/images/zoom-in.png"],["src","./assets/images/closed-hand.png"],["id","favoriteButton",3,"click"],["src","../../../assets/images/star_empty.png",4,"ngIf"],["src","../../../assets/images/star_filled.png",4,"ngIf"],[1,"swipe"],["id","#leftButton",3,"click"],["src","./assets/images/left.png"],["id","#rightButton",3,"click"],["src","./assets/images/right.png"],["id","#revealButton",3,"click"],["id","status"],["src","../../../assets/images/star_empty.png"],["src","../../../assets/images/star_filled.png"]],template:function(e,r){1&e&&(Je(0,"div",0)(1,"div",1)(2,"h1"),_t(3,"Joke Browser"),Ze(),Je(4,"h2"),_t(5,"by Hung Bui "),Ze(),Je(6,"h3"),_t(7,"Jokes generated from "),Je(8,"a"),_t(9,"https://sv443.net/jokeapi/v2/"),Ze()()(),Je(10,"div",2)(11,"button",3),br("click",function(){return r.mode="search"}),_t(12,"View Jokes"),Ze(),Je(13,"button",3),br("click",function(){return r.mode="favorites"}),_t(14,"View Favorites"),Ze()(),Es(15,YK,5,1,"div",4),Es(16,rX,33,8,"div",5),Ze()),2&e&&(Sn(15),hs("ngIf","favorites"==r.mode),Sn(1),hs("ngIf","search"==r.mode))},dependencies:[mA,hw],styles:["*[_ngcontent-%COMP%]{font-family:Oswald,sans-serif;color:#fff}div[_ngcontent-%COMP%]{margin:0;background-color:#181818}button[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{height:2rem;width:2rem}button[_ngcontent-%COMP%]{font-size:2rem;background-color:#f55914;color:#fff;border:0px;margin:5px}#discardButton[_ngcontent-%COMP%]{background-color:#b92b27}#generateButton[_ngcontent-%COMP%]{background-color:#02b875}#favoriteButton[_ngcontent-%COMP%]{background-color:#0077b5}#feedback[_ngcontent-%COMP%], #status[_ngcontent-%COMP%]{color:#02b875}#zoom[_ngcontent-%COMP%]{background-color:#9452ae}button[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{filter:brightness(0) invert(1)}button[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{background-color:inherit}.mode[_ngcontent-%COMP%]{display:flex}.mode[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{width:50%;flex:50%;background-color:#2b2b2b}.container[_ngcontent-%COMP%]{text-align:center;margin-left:5%;margin-right:5%}.title[_ngcontent-%COMP%]{text-align:center;color:#fff;background-color:#101011}.title[_ngcontent-%COMP%]   *[_ngcontent-%COMP%]{margin:0}.title[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:5rem}.title[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:2rem}.title[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{font-size:1rem}.image_group[_ngcontent-%COMP%]{display:flex;justify-content:center;background-color:inherit}.image_group[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:2rem;height:2rem}.swipe[_ngcontent-%COMP%]{display:flex;flex-direction:row;width:100%;justify-content:space-between;background-color:#0f0f0f}.swipe[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background-color:#fff;color:#000}.swipe[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{filter:brightness(0) invert(0)}.columns[_ngcontent-%COMP%]{display:flex;justify-content:space-between}.content[_ngcontent-%COMP%]{width:80%;display:flex;flex-direction:column;justify-content:space-between}.content[_ngcontent-%COMP%]   *[_ngcontent-%COMP%]{text-align:center}.content[_ngcontent-%COMP%]   .joke[_ngcontent-%COMP%]{font-size:2rem;color:#fff}.content[_ngcontent-%COMP%]   .joke.zoomed[_ngcontent-%COMP%]{font-size:2.5rem}.button_column[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;background-color:#0f0f0f}.favorites[_ngcontent-%COMP%]   .list[_ngcontent-%COMP%]{height:440px;overflow-y:auto}.favorites[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%], .favorites[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:1.2rem}.favorites[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{font-size:2rem}.favorites[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background-color:#b92b27;font-size:1.2rem}"]}),t})();function I$(t,n,e,r,s,o,i){try{var a=t[o](i),l=a.value}catch(u){return void e(u)}a.done?n(l):Promise.resolve(l).then(r,s)}function Q(t){return function(){var n=this,e=arguments;return new Promise(function(r,s){var o=t.apply(n,e);function i(l){I$(o,r,s,i,a,"next",l)}function a(l){I$(o,r,s,i,a,"throw",l)}i(void 0)})}}class D${constructor(n,e){this.backend=n,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(n){return this.data.has(n)||this.dataMover.moveData(this.backend,n),this.data.get(n)}set(n,e){this.dataIdsCount++,this.data.set(n,e)}has(n){return this.data.has(n)}delete(n){return this.dataIdsCount--,this.data.delete(n)}numDataIds(){return this.dataIdsCount}}class l0{refCount(n){return As("refCount")}incRef(n){return As("incRef")}timerAvailable(){return!0}time(n){return As("time")}read(n){return As("read")}readSync(n){return As("readSync")}numDataIds(){return As("numDataIds")}disposeData(n,e){return As("disposeData")}write(n,e,r){return As("write")}move(n,e,r,s,o){return As("move")}memory(){return As("memory")}floatPrecision(){return As("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return As("dispose")}}function As(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function _$(t){let n=t.length,e=0,r=0;for(;n>0;)r=Math.random()*n|0,n--,e=t[n],t[n]=t[r],t[r]=e}function Ba(t,n,e){return Math.max(t,Math.min(n,e))}function S$(t){return t%2==0?t:t+1}function S(t,n){if(!t)throw new Error("string"==typeof n?n:n())}function fs(t,n,e=""){S(zt(t,n),()=>e+` Shapes ${t} and ${n} must match`)}function u0(t){S(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function cu(t,n=[],e=!1){if(null==n&&(n=[]),Array.isArray(t)||ko(t)&&!e)for(let r=0;r<t.length;++r)cu(t[r],n,e);else n.push(t);return n}function te(t){if(0===t.length)return 1;let n=t[0];for(let e=1;e<t.length;e++)n*=t[e];return n}function zt(t,n){if(t===n)return!0;if(null==t||null==n||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function Jn(t){return t%1==0}function c0(t){const n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function du(t,n){return n<=t.length?t:t+" ".repeat(n-t.length)}function E$(t,n=(r=>0),e){return new Promise((r,s)=>{let o=0;const i=()=>{if(t())return void r();o++;const a=n(o);null!=e&&o>=e?s():setTimeout(i,a)};i()})}function N$(t,n){let e=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)e*=t[o];else if(-1===t[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(-1===r){if(n>0&&n!==e)throw Error(`Size(${n}) must match the product of shape ${t}`);return t}if(0===e)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(n%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${e}`);const s=t.slice();return s[r]=n/e,s}function mt(t,n){const e=n.length;return S((t=null==t?n.map((r,s)=>s):[].concat(t)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${t}`),S(t.every(r=>Jn(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?e+r:r)}function za(t,n){const e=[],r=[],s=null!=n&&Array.isArray(n)&&0===n.length,o=null==n||s?null:mt(n,t).sort();let i=0;for(let a=0;a<t.length;++a){if(null!=o){if(o[i]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===t[a]&&(e.push(t[a]),r.push(a)),o[i]<=a&&i++}1!==t[a]&&(e.push(t[a]),r.push(a))}return{newShape:e,keptDims:r}}function lr(t,n){let e=null;if(null==t||"float32"===t)e=new Float32Array(n);else if("int32"===t)e=new Int32Array(n);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);e=new Uint8Array(n)}return e}function hu(t,n){let e=null;if(null==t||"float32"===t)e=new Float32Array(n);else if("int32"===t)e=new Int32Array(n);else if("bool"===t)e=new Uint8Array(n);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);e=new Array(n)}return e}function T$(t,n){return!("complex64"===n||"float32"===n&&"complex64"!==t||"int32"===n&&"float32"!==t&&"complex64"!==t||"bool"===n&&"bool"===t)}function ko(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function d0(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function md(t){return"string"==typeof t||t instanceof String}function h0(t){return"number"==typeof t}function gd(t){return Array.isArray(t)?gd(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":h0(t)?"float32":md(t)?"string":function cX(t){return"boolean"==typeof t}(t)?"bool":"float32"}function f0(t){return!!(t&&t.constructor&&t.call&&t.apply)}function p0(t,n){for(let e=n;e<t;++e)if(t%e==0)return e;return t}function Ve(t){const n=t.length;if(n<2)return[];const e=new Array(n-1);e[n-2]=t[n-1];for(let r=n-3;r>=0;--r)e[r]=e[r+1]*t[r+1];return e}function k$(t,n,e){const r=new Array;if(1===n.length){const s=n[0];for(let o=0;o<s;o++)r[o]=e[t+o]}else{const s=n[0],o=n.slice(1),i=o.reduce((a,l)=>a*l);for(let a=0;a<s;a++)r[a]=k$(t+a*i,o,e)}return r}function Rs(t,n){if(0===t.length)return n[0];const e=t.reduce((r,s)=>r*s);if(0===e)return[];if(e!==n.length)throw new Error(`[${t}] does not match the input size ${n.length}.`);return k$(0,t,n)}function A$(t,n){const e=xr(t,n);for(let r=0;r<e.length;r++)e[r]=1;return e}function xr(t,n){if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n)return new Uint8Array(t);throw new Error(`Unknown data type ${n}`)}function R$(t,n){const e=t.reduce((r,s)=>r*s,1);if(null==n||"float32"===n)return Rs(t,new Float32Array(e));if("int32"===n)return Rs(t,new Int32Array(e));if("bool"===n)return Rs(t,new Uint8Array(e));throw new Error(`Unknown data type ${n}`)}function $$(t){t.forEach(n=>{S(Number.isInteger(n)&&n>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Ao(t,n,e){if(0===n)return 0;if(1===n)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=e[s]*t[s];return r}function yd(t,n,e){if(0===n)return[];if(1===n)return[t];const r=new Array(n);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/e[s]),t-=r[s]*e[s];return r[r.length-1]=t,r}function bd(t){return t&&t.then&&"function"==typeof t.then}const F$="tfjsflags";class dX{constructor(n){this.global=n,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(n,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=n,this.platform=e}registerFlag(n,e,r){if(this.flagRegistry[n]={evaluationFn:e,setHook:r},null!=this.urlFlags[n]){const s=this.urlFlags[n];console.warn(`Setting feature override from URL ${n}: ${s}.`),this.set(n,s)}}getAsync(n){var e=this;return Q(function*(){return n in e.flags||(e.flags[n]=yield e.evaluateFlag(n)),e.flags[n]})()}get(n){if(n in this.flags)return this.flags[n];const e=this.evaluateFlag(n);if(bd(e))throw new Error(`Flag ${n} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[n]=e,this.flags[n]}getNumber(n){return this.get(n)}getBool(n){return this.get(n)}getFlags(){return this.flags}get features(){return this.flags}set(n,e){if(null==this.flagRegistry[n])throw new Error(`Cannot set flag ${n} as it has not been registered.`);this.flags[n]=e,null!=this.flagRegistry[n].setHook&&this.flagRegistry[n].setHook(e)}evaluateFlag(n){if(null==this.flagRegistry[n])throw new Error(`Cannot evaluate flag '${n}': no evaluation function found.`);return this.flagRegistry[n].evaluationFn()}setFlags(n){this.flags=Object.assign({},n)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const n=function hX(t){const n={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function fX(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}(n,r[0],r[1]),r.join("="))),n}(this.global.location.search);F$ in n&&n[F$].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function pX(t,n){if("true"===(n=n.toLowerCase())||"false"===n)return"true"===n;if(""+ +n===n)return+n;throw new Error(`Could not parse value flag value ${n} for flag ${t}.`)}(s,o)})}}function ne(){return O$}let m0,O$=null;function M$(){if(null==m0){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");t=self}m0=t}return m0}function g0(t,n){const e=function gX(){const t=M$();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(e.has(t))return e.get(t);{const r=n();return e.set(t,r),e.get(t)}}const gm="Abs",vd="Acos",xd="Acosh",fu="Add",ym="AddN",bm="ArgMax",vm="ArgMin",wd="Asin",Cd="Asinh",Id="Atan",Dd="Atanh",_d="Atan2",xm="AvgPool",v0="AvgPoolGrad",wm="AvgPool3D",x0="AvgPool3DGrad",Cm="BatchMatMul",Im="BatchToSpaceND",w0="Bincount",Sd="Cast",Ed="Ceil",Nd="ClipByValue",C0="Complex",Dm="ComplexAbs",_m="Concat",Sm="Conv2D",I0="Conv2DBackpropFilter",Em="Conv2DBackpropInput",Nm="Conv3D",D0="Conv3DBackpropFilterV2",_0="Conv3DBackpropInputV2",Td="Cos",kd="Cosh",Tm="Cumsum",S0="CropAndResize",E0="DenseBincount",N0="DepthToSpace",km="DepthwiseConv2dNative",T0="DepthwiseConv2dNativeBackpropFilter",k0="DepthwiseConv2dNativeBackpropInput",Am="Dilation2D",A0="Dilation2DBackpropInput",R0="Dilation2DBackpropFilter",Ad="RealDiv",Rd="Elu",$0="EluGrad",$d="Erf",Rm="Equal",Fd="Exp",$m="ExpandDims",Od="Expm1",O0="Fill",M0="FlipLeftRight",Md="Floor",Pd="FloorDiv",Fm="FusedBatchNorm",Om="GatherV2",P0="GatherNd",Mm="Greater",Ld="GreaterEqual",Bd="Identity",L0="IFFT",B0="Imag",zd="IsFinite",Vd="IsInf",Ud="IsNan",Pm="LeakyRelu",Lm="Less",Bm="LessEqual",z0="LinSpace",Hd="Log",Wd="Log1p",zm="LogicalAnd",Vm="LogicalNot",Um="LogicalOr",Hm="LRN",V0="LRNGrad",Wm="Max",jd="Maximum",jm="MaxPool",U0="MaxPoolGrad",Gm="MaxPool3D",H0="MaxPool3DGrad",W0="MaxPoolWithArgmax",qm="Mean",Km="Min",Gd="Minimum",Xm="MirrorPad",qd="Mod",j0="Multinomial",Kd="Multiply",Ym="Neg",Jm="NotEqual",G0="NonMaxSuppressionV3",q0="NonMaxSuppressionV4",K0="NonMaxSuppressionV5",Zm="OnesLike",Qm="OneHot",eg="Pack",tg="PadV2",Xd="Pow",ng="Prelu",X0="Prod",Y0="Range",J0="Real",Yd="Reciprocal",Jd="Relu",rg="Reshape",sg="ResizeNearestNeighbor",Z0="ResizeNearestNeighborGrad",og="ResizeBilinear",Q0="ResizeBilinearGrad",Zd="Relu6",ig="Reverse",Qd="Round",eh="Rsqrt",eC="ScatterNd",ag="Select",th="Selu",lg="Slice",nh="Sin",rh="Sinh",sh="Sign",oh="Sigmoid",ih="Softplus",ah="Sqrt",ug="Sum",cg="SpaceToBatchND",dg="SplitV",hg="Softmax",lh="SquaredDifference",tC="Square",uh="Sub",nC="SparseToDense",rC="StridedSlice",ch="Tan",dh="Tanh",hh="Tile",sC="TopK",oC="Transform",fg="Transpose",iC="Unique",pg="Unpack",mg="UnsortedSegmentSum",gg="ZerosLike",fh="Step",aC="FromPixels",lC="RotateWithOffset",yg="_FusedMatMul",bg="FusedConv2D",vg="FusedDepthwiseConv2D",pu=g0("kernelRegistry",()=>new Map),ph=g0("gradRegistry",()=>new Map);function uC(t,n){const e=hC(t,n);return pu.get(e)}function L$(t){return ph.get(t)}function cC(t){const n=pu.entries(),e=[];for(;;){const{done:r,value:s}=n.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&e.push(i)}return e}function dC(t){const{kernelName:n,backendName:e}=t,r=hC(n,e);pu.has(r)&&console.warn(`The kernel '${n}' for backend '${e}' is already registered`),pu.set(r,t)}function vX(t){const{kernelName:n}=t;ph.has(n)&&ne().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${n}'`),ph.set(n,t)}function hC(t,n){return`${n}_${t}`}function Gi(t,n){return"string"===n?mh(t):Va([t],n)}function Va(t,n){if("string"===n)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=cu(t)),ne().getBool("DEBUG")&&function aX(t,n){for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${n} being uploaded contains ${r}.`)}}(t,n),function xX(t,n){return t instanceof Float32Array&&"float32"===n||t instanceof Int32Array&&"int32"===n||t instanceof Uint8Array&&"bool"===n}(t,n))return t;if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n){const e=new Uint8Array(t.length);for(let r=0;r<e.length;++r)0!==Math.round(t[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${n}`)}function Ur(){return ne().platform.now()}function mh(t,n="utf-8"){return n=n||"utf-8",ne().platform.encode(t,n)}function mu(t,n="utf-8"){return n=n||"utf-8",ne().platform.decode(t,n)}class wX{constructor(n,e){this.backendTimer=n,this.logger=e,null==e&&(this.logger=new IX)}profileKernel(n,e,r){let s;const o=()=>{s=r()};let i;const a=Ur();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:Ur()-a})}if(ne().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{CX(d,c.dtype,n)})}return{kernelName:n,outputs:s,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(n){const{kernelName:e,outputs:r,timeMs:s,inputs:o,extraInfo:i}=n;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],o,l[2])})})}}function CX(t,n,e){if("float32"!==n)return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class IX{logKernelProfile(n,e,r,s,o,i){const a="number"==typeof s?du(`${s}ms`,9):s.error,l=du(n,25),u=e.rank,c=e.size,d=du(e.shape.toString(),14);let h="";for(const f in o){const p=o[f];if(null!=p){const m=p.shape||e.shape,g=m.length;h+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function SX(t,n,e,r){const s=Ve(n),o=function EX(t,n,e,r){const s=te(n),o=r[r.length-1],i=new Array(o).fill(0),a=n.length,l="complex64"===e?bh(t):t;if(a>1)for(let u=0;u<s/o;u++){const c=u*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],yh(l[c+d],0,e).length)}return i}(t,n,e,s),i=n.length,a=xg(t,n,e,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${n}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function yh(t,n,e){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:md(t)?`'${t}'`:"bool"===e?z$(t):parseFloat(t.toFixed(7)).toString(),du(r,n)}function z$(t){return 0===t?"false":"true"}function xg(t,n,e,r,s,o=!0){const i="complex64"===e?2:1,a=n[0],l=n.length;if(0===l)return"complex64"===e?[yh(bh(t)[0],0,e)]:"bool"===e?[z$(t[0])]:[t[0].toString()];if(1===l){if(a>20){let y=Array.from(t.slice(0,3*i)),b=Array.from(t.slice((a-3)*i,a*i));return"complex64"===e&&(y=bh(y),b=bh(b)),["["+y.map((v,x)=>yh(v,s[x],e)).join(", ")+", ..., "+b.map((v,x)=>yh(v,s[a-3+x],e)).join(", ")+"]"]}return["["+("complex64"===e?bh(t):Array.from(t)).map((g,y)=>yh(g,s[y],e)).join(", ")+"]"]}const u=n.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...xg(t.slice(g,g+d),u,e,c,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...xg(t.slice(g,g+d),u,e,c,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...xg(t.slice(g,g+d),u,e,c,s,m===a-1))}const f=2===l?",":"";h[0]="["+h[0]+f;for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+f;let p=",\n";for(let m=2;m<l;m++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":p),h}function bh(t){const n=[];for(let e=0;e<t.length;e+=2)n.push([t[e],t[e+1]]);return n}class Zn{constructor(n,e,r){if(this.dtype=e,this.shape=n.slice(),this.size=te(n),null!=r){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||hu(e,this.size),this.strides=Ve(n)}set(n,...e){0===e.length&&(e=[0]),S(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=n}get(...n){0===n.length&&(n=[0]);let e=0;for(const s of n){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${n}.   Buffer shape=${this.shape}`);e++}let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=this.strides[s]*n[s];return this.values[r]}locToIndex(n){if(0===this.rank)return 0;if(1===this.rank)return n[0];let e=n[n.length-1];for(let r=0;r<n.length-1;++r)e+=this.strides[r]*n[r];return e}indexToLoc(n){if(0===this.rank)return[];if(1===this.rank)return[n];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(n/this.strides[r]),n-=e[r]*this.strides[r];return e[e.length-1]=n,e}get rank(){return this.shape.length}toTensor(){return Ro().makeTensor(this.values,this.shape,this.dtype)}}let Ro=null,gu=null,V$=null;class un{constructor(n,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=n.slice(),this.dtype=e||"float32",this.size=te(n),this.strides=Ve(n),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var n=this;return Q(function*(){const e=yield n.data();return gu.buffer(n.shape,n.dtype,e)})()}bufferSync(){return gu.buffer(this.shape,this.dtype,this.dataSync())}array(){var n=this;return Q(function*(){const e=yield n.data();return Rs(n.shape,e)})()}arraySync(){return Rs(this.shape,this.dataSync())}data(){var n=this;return Q(function*(){n.throwIfDisposed();const e=Ro().read(n.dataId);if("string"===n.dtype){const r=yield e;try{return r.map(s=>mu(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataSync(){this.throwIfDisposed();const n=Ro().readSync(this.dataId);if("string"===this.dtype)try{return n.map(e=>mu(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return n}bytes(){var n=this;return Q(function*(){n.throwIfDisposed();const e=yield Ro().read(n.dataId);return"string"===n.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(Ro().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(n=!1){return gu.print(this,n)}clone(){return this.throwIfDisposed(),gu.clone(this)}toString(n=!1){return SX(this.dataSync(),this.shape,this.dtype,n)}cast(n){return this.throwIfDisposed(),gu.cast(this,n)}variable(n=!0,e,r){return this.throwIfDisposed(),Ro().makeVariable(this,n,e,r)}}function J(){return g0("Tensor",()=>un)}Object.defineProperty(un,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),J();class wg extends un{constructor(n,e,r,s){super(n.shape,n.dtype,n.dataId,s),this.trainable=e,this.name=r}assign(n){if(n.dtype!==this.dtype)throw new Error(`dtype of the new value (${n.dtype}) and previous value (${this.dtype}) must match`);if(!zt(n.shape,this.shape))throw new Error(`shape of the new value (${n.shape}) and previous value (${this.shape}) must match`);Ro().disposeTensor(this),this.dataId=n.dataId,Ro().incRef(this,null)}dispose(){Ro().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(wg,Symbol.hasInstance,{value:t=>t instanceof un&&null!=t.assign&&t.assign instanceof Function});var Cg=(()=>{return(t=Cg||(Cg={})).float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64",Cg;var t})(),Ig=(()=>{return(t=Ig||(Ig={})).float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64",Ig;var t})(),Dg=(()=>{return(t=Dg||(Dg={})).float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64",Dg;var t})(),_g=(()=>{return(t=_g||(_g={})).float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64",_g;var t})();const AX={float32:Dg,int32:Cg,bool:Ig,complex64:_g};function ps(t,n){if("string"===t||"string"===n){if("string"===t&&"string"===n)return"string";throw new Error(`Can not upcast ${t} with ${n}`)}return AX[t][n]}function pC(t){return ps(t,"int32")}function mn(t,n){if(t.dtype===n.dtype)return[t,n];const e=ps(t.dtype,n.dtype);return[t.cast(e),n.cast(e)]}function U$(t){const n=[];return H$(t,n,new Set),n}function H$(t,n,e){if(null==t)return;if(t instanceof un)return void n.push(t);if(!function RX(t){return Array.isArray(t)||"object"==typeof t}(t))return;const r=t;for(const s in r){const o=r[s];e.has(o)||(e.add(o),H$(o,n,e))}}function mC(t){return null!=t.kernelName}class W${constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(n=>n.name)))}}}dispose(){for(const n in this.registeredVariables)this.registeredVariables[n].dispose()}}let $X=(()=>{class t{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new W$}ready(){var e=this;return Q(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return Q(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(e);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new wX(r.backendInstance),!0})()}setupRegisteredKernels(){cC(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){cC(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof l0||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,i=s.then(a=>!(o<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(s){return console.warn(`Initialization of backend ${e} failed`),console.warn(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),o=s.backend,i=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),s.backend=e,e.move(r,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,s){e();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return t.nextTensorId++}nextVariableId(){return t.nextVariableId++}clone(e){const r=F.runKernel(Bd,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>F.runKernel(Sd,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==uC(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const o=this.backend.numDataIds();let i=0;s.forEach(u=>{i+="complex64"===u.dtype?3:1});const l=o-r-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=mC(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(mC(e)){const{kernelName:m,inputs:g,attrs:y}=e,b=uC(m,this.backendName);S(null!=b,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const v=this.backend.numDataIds();u=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,v,x);const w=x.map(_=>{if(null!=_.rank)return _;const{dataId:D,shape:A,dtype:R}=_;return this.makeTensorFromDataId(D,A,R)});if(o){const _=this.getTensorsForGradient(m,g,w);s=this.saveTensorsForBackwardMode(_)}return w}}else{const{forwardFunc:m}=e,g=y=>{!o||(s=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>m(this.backend,g));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b),b}}const{inputs:d,attrs:h}=e,f=mC(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),r=p.outputs):r=l()}),o&&this.addTapeNode(c,d,r,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const o=L$(e);if(null!=o){const i=o.inputsToSave||[],a=o.outputsToSave||[];let l;o.saveAllInputs?(S(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);const u=s.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(e,r,s,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let i=e;"string"===(s=s||"float32")&&md(e[0])&&(i=e.map(u=>mh(u)));const a=o.write(i,r,s),l=new un(r,s,a,this.nextTensorId());if(this.trackTensor(l,o),"string"===s){const u=this.state.tensorInfo.get(a),c=function uX(t){if(null==t)return 0;let n=0;return t.forEach(e=>n+=e.length),n}(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,s,o){const i=new un(r,s=s||"float32",e,this.nextTensorId());return this.trackTensor(i,o),i}makeVariable(e,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const i=new wg(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*d0(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof wg||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*d0(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return Q(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const i of r.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,o,i,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:i},u=L$(e);null!=u&&(o=u.gradFunc),null!=o&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const f=s[h],p=xr(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),o(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=U$(e),s=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(e,r,s,o=!1){if(S(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(i instanceof un,()=>"The result y returned by f() must be a tensor.");const a=function DX(t,n,e){const r={},s={};for(let l=0;l<n.length;l++)r[n[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const d in c){const h=c[d];let f=!1;for(let p=0;p<n.length;p++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),f=!0,s[u.id]=!0;break}if(f)break}}const o={};o[e.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const u=t[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const f=u.inputs[h];r[f.id]&&(c[h]=f)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,r,i);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??function FX(t){const n=A$(te(t),"float32");return F.makeTensor(n,t,"float32")}(i.shape),function _X(t,n,e,r){for(let s=n.length-1;s>=0;s--){const o=n[s],i=[];if(o.outputs.forEach(l=>{const u=t[l.id];i.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!zt(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==t[c.id])t[c.id]=u;else{const d=t[c.id];t[c.id]=r(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),OX);const u=r.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return S(f0(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;S(r.every(l=>l instanceof un),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((l,u)=>{o[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(s=e(...r,u),S(s.value instanceof un,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(f0(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,u)=>{const c=s.gradFunc(l,u),d=Array.isArray(c)?c:[c];S(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(d.every(f=>f instanceof un),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}time(e){var r=this;return Q(function*(){const s=Ur(),o=yield r.backend.time(e);return o.wallMs=Ur()-s,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new W$;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return t.nextTensorId=0,t.nextVariableId=0,t})();function j$(){const t=M$();if(null==t._tfengine){const n=new dX(t);t._tfengine=new $X(n)}return function mX(t){O$=t}(t._tfengine.ENV),function NX(t){Ro=t}(()=>t._tfengine),t._tfengine}const F=j$();function OX(t,n){return F.runKernel(fu,{a:t,b:n})}function G$(){if(function MX(){return typeof navigator<"u"&&null!=navigator}()){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function q$(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const ho=ne();function vh(t,n){let e=t;if(ko(t))return"string"===n?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(e)||ko(e)&&"string"!==n;)r.push(e.length),e=e[0];return Array.isArray(t)&&ne().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&K$(t,r,[]),r}function K$(t,n,e){if(e=e||[],!Array.isArray(t)&&!ko(t))return void S(0===n.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);S(n.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${t.length} elements`),S(t.length===n[0],()=>`Element arr[${e.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);const r=n.slice(1);for(let s=0;s<t.length;++s)K$(t[s],r,e.concat(s))}function X$(t,n,e,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==n||"numeric"===t&&"string"===n)throw new Error(`Argument '${e}' passed to '${r}' must be ${t} tensor, but got ${n} tensor`)}}function T(t,n,e,r="numeric"){if(t instanceof un)return X$(r,t.dtype,n,e),t;let s=gd(t);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),X$(r,s,n,e),null==t||!ko(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${n}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const o=vh(t,s);!ko(t)&&!Array.isArray(t)&&(t=[t]);const a="string"!==s?Va(t,s):cu(t,[],!0);return F.makeTensor(a,o,s)}function Y$(t,n,e,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${n} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>T(o,`${n}[${i}]`,e,r))}function M(t){const n=Object.keys(t);if(1!==n.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${n.length} keys.`);let e=n[0];const r=t[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+="__op";const s=(...o)=>{F.startScope(e);try{const i=r(...o);return bd(i)&&console.error("Cannot return a Promise inside of tidy."),F.endScope(i),i}catch(i){throw F.endScope(null),i}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}ho.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ho.registerFlag("IS_BROWSER",()=>q$()),ho.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),ho.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ho.registerFlag("PROD",()=>!1),ho.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ho.getBool("DEBUG")),ho.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ho.registerFlag("IS_TEST",()=>!1),ho.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ho.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const Ua=M({complex_:function LX(t,n){const e=T(t,"real","complex"),r=T(n,"imag","complex");return fs(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),F.runKernel(C0,{real:e,imag:r})}});function xh(t,n,e,r){if(null==r&&(r=gd(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!ko(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=n){$$(n);const s=te(n),o=te(e);S(s===o,()=>`Based on the provided shape, [${n}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<e.length;++i){const a=e[i],l=i!==e.length-1||a!==te(n.slice(i));S(e[i]===n[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${n}). `)}}return!ko(t)&&!Array.isArray(t)&&(t=[t]),n=n||e,t="string"!==r?Va(t,r):cu(t,[],!0),F.makeTensor(t,n,r)}function Ha(t,n,e){return xh(t,n,vh(t,e),e)}const gC={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function J$(t,n){return yC.apply(this,arguments)}function yC(){return yC=Q(function*(t,n){const e=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(t)?t[i].tensor:t[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=Q(function*(h){const f=yield l.bytes(),p=f.reduce((y,b)=>y+b.length,0)+4*f.length,m=new Uint8Array(p);let g=0;for(let y=0;y<f.length;y++){const b=f[y],v=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(v,g),g+=4,m.set(b,g),g+=b.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=n&&(u.group=n),e.push(u)}return{data:BX(yield Promise.all(r)),specs:e}}),yC.apply(this,arguments)}function BX(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let n=0;const e=[];t.forEach(o=>{if(n+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(n);let s=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const bC=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Q$(t){return bC?Buffer.byteLength(t):new Blob([t]).size}function vC(t){if(1===t.length)return t[0];let n=0;t.forEach(s=>{n+=s.byteLength});const e=new Uint8Array(n);let r=0;return t.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function Eg(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Q$(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Q$(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function jX(){const t=function UX(){const t=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},n=new Uint32Array(2048);n[0]=0;for(let e=1;e<1024;e++)n[e]=t(e);for(let e=1024;e<2048;e++)n[e]=939524096+(e-1024<<13);return n}(),n=function HX(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let n=1;n<31;n++)t[n]=n<<23;for(let n=33;n<63;n++)t[n]=2147483648+(n-32<<23);return t}(),e=function WX(){const t=new Uint32Array(64);for(let n=0;n<64;n++)t[n]=1024;return t[0]=t[32]=0,t}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i];o[i]=t[e[a>>10]+(1023&a)]+n[a>>10]}return new Float32Array(s)}}class cn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==cn.instance&&(cn.instance=new cn),cn.instance}static registerSaveRouter(n){cn.getInstance().saveRouters.push(n)}static registerLoadRouter(n){cn.getInstance().loadRouters.push(n)}static getSaveHandlers(n){return cn.getHandlers(n,"save")}static getLoadHandlers(n,e){return cn.getHandlers(n,"load",e)}static getHandlers(n,e,r){const s=[];return("load"===e?cn.getInstance().loadRouters:cn.getInstance().saveRouters).forEach(i=>{const a=i(n,r);null!==a&&s.push(a)}),s}}const t2=t=>cn.getSaveHandlers(t),Ng="tensorflowjs",Wa="models_store",qi="model_info_store";function CC(){if(!ne().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,n=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==n)throw new Error("The current browser does not appear to support IndexedDB.");return n}function IC(t){const n=t.result;n.createObjectStore(Wa,{keyPath:"modelPath"}),n.createObjectStore(qi,{keyPath:"modelPath"})}let yu=(()=>{class t{constructor(e){if(this.indexedDB=CC(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return Q(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return Q(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,o)=>{const i=this.indexedDB.open(Ng,1);i.onupgradeneeded=()=>IC(i),i.onsuccess=()=>{const a=i.result;if(null==r){const l=a.transaction(Wa,"readonly"),c=l.objectStore(Wa).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),o(c.error)),l.oncomplete=()=>a.close()}else{const l=Eg(r),u=a.transaction(qi,"readwrite");let c=u.objectStore(qi);const d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;d.onsuccess=()=>{h=a.transaction(Wa,"readwrite");const p=h.objectStore(Wa).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l});p.onsuccess=()=>s({modelArtifactsInfo:l}),p.onerror=m=>{c=u.objectStore(qi);const g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),o(p.error)),g.onerror=y=>(a.close(),o(p.error))}},d.onerror=f=>(a.close(),o(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}return t.URL_SCHEME="indexeddb://",t})();const n2=t=>ne().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(yu.URL_SCHEME)?function qX(t){return new yu(t)}(t.slice(yu.URL_SCHEME.length)):null;cn.registerSaveRouter(n2),cn.registerLoadRouter(n2);class XX{constructor(){this.indexedDB=CC()}listModels(){var n=this;return Q(function*(){return new Promise((e,r)=>{const s=n.indexedDB.open(Ng,1);s.onupgradeneeded=()=>IC(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(qi,"readonly"),l=i.objectStore(qi).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(n){var e=this;return Q(function*(){return n=function KX(t){return t.startsWith(yu.URL_SCHEME)?t.slice(yu.URL_SCHEME.length):t}(n),new Promise((r,s)=>{const o=e.indexedDB.open(Ng,1);o.onupgradeneeded=()=>IC(o),o.onsuccess=()=>{const i=o.result,a=i.transaction(qi,"readwrite"),l=a.objectStore(qi),u=l.get(n);let c;u.onsuccess=()=>{if(null==u.result)return i.close(),s(new Error(`Cannot find model with path '${n}' in IndexedDB.`));{const d=l.delete(n),h=()=>{c=i.transaction(Wa,"readwrite");const p=c.objectStore(Wa).delete(n);p.onsuccess=()=>r(u.result.modelArtifactsInfo),p.onerror=m=>s(u.error)};d.onsuccess=h,d.onerror=f=>(h(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{null==c?i.close():c.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})})()}}const $o="/",ja="tensorflowjs_models",r2="info",YX="model_topology",JX="weight_specs",ZX="weight_data",QX="model_metadata";function s2(t){return{info:[ja,t,r2].join($o),topology:[ja,t,YX].join($o),weightSpecs:[ja,t,JX].join($o),weightData:[ja,t,ZX].join($o),modelMetadata:[ja,t,QX].join($o)}}function o2(t){const n=t.split($o);if(n.length<3)throw new Error(`Invalid key format: ${t}`);return n.slice(1,n.length-1).join($o)}let bu=(()=>{class t{constructor(e){if(!ne().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=s2(this.modelPath)}save(e){var r=this;return Q(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),i=Eg(e);try{r.LS.setItem(r.keys.info,JSON.stringify(i)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function zX(t){if(bC)return Buffer.from(t).toString("base64");const n=new Uint8Array(t);let e="";for(let r=0,s=n.length;r<s;r++)e+=String.fromCharCode(n[r]);return btoa(e)}(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),r.LS.setItem(r.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:i}}catch{throw r.LS.removeItem(r.keys.info),r.LS.removeItem(r.keys.topology),r.LS.removeItem(r.keys.weightSpecs),r.LS.removeItem(r.keys.weightData),r.LS.removeItem(r.keys.modelMetadata),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var e=this;return Q(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=o;const i=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=i;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);s.format=u.format,s.generatedBy=u.generatedBy,s.convertedBy=u.convertedBy,null!=u.signature&&(s.signature=u.signature),null!=u.userDefinedMetadata&&(s.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(s.modelInitializer=u.modelInitializer)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function VX(t){if(bC){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const n=atob(t),e=new Uint8Array(n.length);for(let r=0;r<n.length;++r)e.set([n.charCodeAt(r)],r);return e.buffer}(l),s})()}}return t.URL_SCHEME="localstorage://",t})();const i2=t=>ne().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(bu.URL_SCHEME)?function t7(t){return new bu(t)}(t.slice(bu.URL_SCHEME.length)):null;cn.registerSaveRouter(i2),cn.registerLoadRouter(i2);class n7{constructor(){S(ne().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var n=this;return Q(function*(){const e={},r=ja+$o,s=$o+r2;for(let o=0;o<n.LS.length;++o){const i=n.LS.key(o);i.startsWith(r)&&i.endsWith(s)&&(e[o2(i)]=JSON.parse(n.LS.getItem(i)))}return e})()}removeModel(n){var e=this;return Q(function*(){const r=s2(n=function e7(t){return t.startsWith(bu.URL_SCHEME)?t.slice(bu.URL_SCHEME.length):t}(n));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${n}'`);const s=JSON.parse(e.LS.getItem(r.info));return e.LS.removeItem(r.info),e.LS.removeItem(r.topology),e.LS.removeItem(r.weightSpecs),e.LS.removeItem(r.weightData),s})()}}class Yr{constructor(){this.managers={}}static getInstance(){return null==Yr.instance&&(Yr.instance=new Yr),Yr.instance}static registerManager(n,e){S(null!=n,()=>"scheme must not be undefined or null."),n.endsWith("://")&&(n=n.slice(0,n.indexOf("://"))),S(n.length>0,()=>"scheme must not be an empty string.");const r=Yr.getInstance();S(null==r.managers[n],()=>`A model store manager is already registered for scheme '${n}'.`),r.managers[n]=e}static getManager(n){const e=this.getInstance().managers[n];if(null==e)throw new Error(`Cannot find model manager for scheme '${n}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}class r7{fetch(n,e){return fetch(n,e)}now(){return performance.now()}encode(n,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(n)}decode(n,e){return new TextDecoder(e).decode(n)}}if(ne().get("IS_BROWSER")){ne().setPlatform("browser",new r7);try{Yr.registerManager(bu.URL_SCHEME,new n7)}catch{}try{Yr.registerManager(yu.URL_SCHEME,new XX)}catch{}}let xu;function xt(t,n="float32",e){return n=n||"float32",$$(t),new Zn(t,n,e)}ne().get("IS_NODE")&&ne().setPlatform("node",new class o7{constructor(){this.util=B(628),this.textEncoder=new this.util.TextEncoder}fetch(n,e){return null!=ne().global.fetch?ne().global.fetch(n,e):(null==xu&&(xu=B(410)),xu(n,e))}now(){const n=process.hrtime();return 1e3*n[0]+n[1]/1e6}encode(n,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(n)}decode(n,e){return 0===n.length?"":new this.util.TextDecoder(e).decode(n)}});const Ae=M({cast_:function i7(t,n){const e=T(t,"x","cast");if(!function lX(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if("string"===n&&"string"!==e.dtype||"string"!==n&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return F.runKernel(Sd,{x:e},{dtype:n})}}),Ga=M({clone_:function a7(t){const e={x:T(t,"x","clone","string_or_numeric")};return F.runKernel(Bd,e)}});function l2(t){return new Promise(n=>setTimeout(n)).then(t)}j$(),function TX(t){gu=t}({buffer:xt,cast:Ae,clone:Ga,print:function l7(t,n=!1){console.log(t.toString(n))}});let TC=(()=>{class t{constructor(e){if(!ne().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return Q(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]};null!=e.signature&&(i.signature=e.signature),null!=e.userDefinedMetadata&&(i.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(i.modelInitializer=e.modelInitializer);const a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=r.jsonAnchor??document.createElement("a");if(l.download=r.modelTopologyFileName,l.href=a,yield l2(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const u=r.weightDataAnchor??document.createElement("a");u.download=r.weightDataFileName,u.href=s,yield l2(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Eg(e)}}})()}}return t.URL_SCHEME="downloads://",t})();function u2(t,n,e,r){(function i(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(t),function a(l,u){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),S(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=e??0,r=r??1);let s=0;return Promise.all(t.map(l=>(l.then(u=>{const c=e+ ++s/t.length*(r-e);return n(c),u}),l)))}function c2(t,n){return kC.apply(this,arguments)}function kC(){return(kC=Q(function*(t,n){null==n&&(n={});const e=n.fetchFunc??ne().platform.fetch,r=t.map(d=>e(d,n.requestInit,{isBinary:!0})),a=(null==n.onProgress?yield Promise.all(r):yield u2(r,n.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==n.onProgress?yield Promise.all(a):yield u2(a,n.onProgress,.5,1)})).apply(this,arguments)}cn.registerSaveRouter(t=>ne().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(TC.URL_SCHEME)?function p7(t="model"){return new TC(t)}(t.slice(TC.URL_SCHEME.length)):null);let d2=(()=>{class t{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(S("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=ne().platform.fetch,S(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return Q(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const i={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:e.weightSpecs}]};null!=e.signature&&(i.signature=e.signature),null!=e.userDefinedMetadata&&(i.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(i.modelInitializer=e.modelInitializer),s.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:Eg(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return Q(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let y=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?y+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":y+=" Please make sure the server is serving valid JSON for this request.",new Error(y)}const o=s.modelTopology,i=s.weightsManifest,a=s.generatedBy,l=s.convertedBy,u=s.format,c=s.signature,d=s.userDefinedMetadata;if(null==o&&null==i)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);let h,f;null!=i&&([h,f]=yield e.loadWeights(i));const p={modelTopology:o,weightSpecs:h,weightData:f,generatedBy:a,convertedBy:l,format:u};null!=c&&(p.signature=c),null!=d&&(p.userDefinedMetadata=d);const m=s.modelInitializer;return m&&(p.modelInitializer=m),p})()}loadWeights(e){var r=this;return Q(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,i]=function b7(t){const n=t.lastIndexOf("/"),e=t.lastIndexOf("?");return[t.substring(0,n)+"/",e>n?t.substring(e):""]}(s),a=r.weightPathPrefix||o,l=[];for(const h of e)l.push(...h.weights);const u=[],c=[];for(const h of e)for(const f of h.paths)null!=r.weightUrlConverter?c.push(r.weightUrlConverter(f)):u.push(a+f+i);return r.weightUrlConverter&&u.push(...yield Promise.all(c)),[l,vC(yield c2(u,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return t.URL_SCHEME_REGEX=/^https?:\/\//,t})();function h2(t){return null!=t.match(d2.URL_SCHEME_REGEX)}const f2=(t,n)=>{if(typeof fetch>"u"&&(null==n||null==n.fetchFunc))return null;{let e=!0;if(e=Array.isArray(t)?t.every(r=>h2(r)):h2(t),e)return p2(t,n)}return null};function p2(t,n){return new d2(t,n)}function m2(t,n){return p2(t,n)}let wu;cn.registerSaveRouter(f2),cn.registerLoadRouter(f2);const _7=M({fromPixels_:function g2(t,n=3){if(n>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(null!=t.getContext)i=!0;else{if(!(typeof ImageBitmap<"u"&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);a=!0}if(s&&s&&t.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(null!=uC(aC,F.backendName))return F.runKernel(aC,{pixels:t},{numChannels:n});const[u,c]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d,h;if(i?d=t.getContext("2d").getImageData(0,0,u,c).data:r||e?d=t.data:(o||s||a)&&(null==wu&&(wu=document.createElement("canvas").getContext("2d")),wu.canvas.width=u,wu.canvas.height=c,wu.drawImage(t,0,0,u,c),d=wu.getImageData(0,0,u,c).data),4===n)h=new Int32Array(d);else{const p=u*c;h=new Int32Array(p*n);for(let m=0;m<p;m++)for(let g=0;g<n;++g)h[m*n+g]=d[4*m+g]}return function x7(t,n,e){if(u0(t),null!=n&&3!==n.length)throw new Error("tensor3d() requires shape to have three numbers");const r=vh(t,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return xh(t,n,r,e)}(h,[c,u,n],"int32")}});function OC(t,n,e){const r=t.shape.length;S(r===n.length,()=>`Error in slice${r}D: Length of begin ${n} must match the rank of the array (${r}).`),S(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(n[s]+e[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${n[s]+e[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function kg(t){const n=[];let e=0;for(;t>0;)1&t&&n.push(e),t/=2,e++;return n}function y2(t,n,e){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((n[s]-t[s])/e[s]);return r}function b2(t,n,e,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<e;o++)0===o?s[n]=1:(s.splice(n,0,1),s.pop());return s}function v2(t,n,e){return e<=t?e:e-(n-1)}function x2(t,n){const e=[];for(let r=0;r<t;r++)e.push(n+r);return e}function w2(t,n,e,r,s,o,i,a,l){const u=t.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(n.length&&e>0){const f=n[0],p=e+1;c=C2(i,f,p,r,t),d=I2(a,f,p,s,t),h=b2(o,f,p,t)}else for(let f=0;f<u;f++)c[f]=_2(i,r,o,t,f,l),d[f]=S2(a,s,o,t,f,l),h[f]=D2(o,f,l);return{begin:c,end:d,strides:h}}function C2(t,n,e,r,s){const o=[...s],i=x2(e,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=v2(n,e,a);let u=r[l];t&1<<l&&(u=0),o[a]=u}return o}function I2(t,n,e,r,s){const o=[...s],i=x2(e,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=v2(n,e,a);let u=r[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++){const l=s[a];o[a]<0&&(o[a]+=l),o[a]=Ba(0,o[a],s[a])}return o}function D2(t,n,e){let r=t[n];return(e&1<<n||null==r)&&(r=1),r}function _2(t,n,e,r,s,o){let i=n[s];(t&1<<s||o&1<<s||null==i)&&(i=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Ba(0,i,l-1),i}function S2(t,n,e,r,s,o){let i=n[s];const a=e[s]||1;(t&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=a>0?Ba(0,i,l):Ba(-1,i,l-1),i}function MC(t,n,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(n[s]>0||e[s]!==t[s])return!1;return!0}function PC(t,n){let e=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)e+=t[r]*n[r];return e}function Ag(t,n,e){let r;const s=t.shape.length;let o;return r="number"==typeof n?[n,...new Array(s-1).fill(0)]:n.length<s?n.concat(new Array(s-n.length).fill(0)):n.slice(),r.forEach(i=>{S(-1!==i,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,o=o.map((i,a)=>i>=0?i:(S(-1===i,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,o]}function LC(t,n,e,r,s,o,i,a,l){let u=n.slice(),c=e.slice(),d=r;null==r&&(d=new Array(u.length));const h=kg(i);if(h.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const f=t.length-u.length,p=kg(a),m=t.slice();p.forEach(D=>{u[D]=0,c[D]=1,m.splice(D,0,1)});const{begin:g,end:y,strides:b}=w2(m,h,f,u,c,d,s,o,i);u=g,c=y,d=b;const v=kg(l);v.forEach(D=>{c[D]=u[D]+1,d[D]=1});const x=y2(u,c,d),w=x.filter((D,A)=>-1===v.indexOf(A));return{nonStrided:d.every(D=>1===D),$begin:u,$end:c,$strides:d,size:x,newShape:m,outShape:w}}class Cu{getClassName(){return this.constructor.className}static fromConfig(n,e){return new n(e)}}class $s{constructor(){this.classNameMap={}}static getMap(){return null==$s.instance&&($s.instance=new $s),$s.instance}static register(n){$s.getMap().classNameMap[n.className]=[n,n.fromConfig]}}function le(t){S(null!=t.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),S(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),$s.register(t)}function Ki(){return F}function BC(){return F.memory()}function U(t,n){return F.tidy(t,n)}function ut(t){U$(t).forEach(e=>e.dispose())}function ur(t){return F.keep(t)}function E2(t){return F.setBackend(t)}function N2(t,n,e=1){return F.registerBackend(t,n,e)}function fi(t){return F.customGrad(t)}function Oe(t,n){if((ko(t)&&"string"!==n||Array.isArray(t))&&"complex64"!==n)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===n&&ko(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return xh(t,[],[],n)}!function kX(t){V$=t}(function E7(t){ne().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});class Xi extends Cu{minimize(n,e=!1,r){const{value:s,grads:o}=this.computeGradients(n,r);if(null!=r){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return ut(o),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(n,e){return function k7(t,n){S(f0(t),()=>"The f passed in variableGrads(f) must be a function"),S(null==n||Array.isArray(n)&&n.every(u=>u instanceof wg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=n;if(!e){n=[];for(const u in F.registeredVariables)n.push(F.registeredVariables[u])}const r=e?n.filter(u=>!u.trainable):null,s=n.length;S((n=n.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=F.gradients(t,n,null,!0);S(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return n.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:i,grads:l}}(n,e)}dispose(){null!=this.iterations_&&ut(this.iterations_)}saveIterations(){var n=this;return Q(function*(){return null==n.iterations_&&(n.iterations_=0),{name:"iter",tensor:Oe(n.iterations_,"int32")}})()}getWeights(){return Q(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(n){var e=this;return Q(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(n){var e=this;return Q(function*(){return e.iterations_=(yield n[0].tensor.data())[0],n.slice(1)})()}}Object.defineProperty(Xi,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const Qn=M({abs_:function A7(t){const n=T(t,"x","abs");return F.runKernel("complex64"===n.dtype?Dm:gm,{x:n})}}),me=M({add_:function R7(t,n){let e=T(t,"a","add"),r=T(n,"b","add");return[e,r]=mn(e,r),F.runKernel(fu,{a:e,b:r})}}),zC=M({all_:function $7(t,n=null,e=!1){const s={x:T(t,"x","all","bool")};return F.runKernel("All",s,{axis:n,keepDims:e})}}),$g=M({any_:function F7(t,n=null,e=!1){const s={x:T(t,"x","any","bool")};return F.runKernel("Any",s,{axis:n,keepDims:e})}}),Fg=M({argMax_:function O7(t,n=0){const r={x:T(t,"x","argMax")};return F.runKernel(bm,r,{axis:n})}});function wh(t,n,e,r,s="NHWC",o){return er(t,[...n,t[3]],e,o,r,null,null,mi(s))}function Fs(t,n,e,r,s,o,i="channelsLast"){const[a,l]=Og(n);let u;if("channelsLast"===i)u=[a,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,t[1],t[1]]}return er(t,u,e,r,s,o,!1,i)}function pi(t,n,e,r,s,o,i="NDHWC"){const[a,l,u]=UC(n);let c,d;if("NDHWC"===i)d="channelsLast",c=[a,l,u,t[4],t[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[a,l,u,t[1],t[1]]}return Yi(t,c,e,r,s,!1,d,o)}function er(t,n,e,r,s,o,i=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=t}const[h,f,,p]=n,[m,g]=Og(e),[y,b]=Og(r),v=Iu(h,y),x=Iu(f,b),{padInfo:w,outHeight:_,outWidth:D}=function L7(t,n,e,r,s,o,i,a,l){let u,c,d;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const f=function M7(t,n,e,r,s){null==r&&(r=VC(t,n,e));const i=t[1];return[qa((t[0]-n+2*r)/e+1,s),qa((i-n+2*r)/e+1,s)]}([n,e],o,r,t,a);c=f[0],d=f[1]}else if("same"===t){c=Math.ceil(n/r),d=Math.ceil(e/s);const h=Math.max(0,(c-1)*r+o-n),f=Math.max(0,(d-1)*s+i-e),p=Math.floor(h/2),m=h-p,g=Math.floor(f/2);u={top:p,bottom:m,left:g,right:f-g,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((n-o+1)/r),d=Math.ceil((e-i+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const h="channelsLast"===l?t[1][0]:t[2][0],f="channelsLast"===l?t[1][1]:t[2][1],p="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:h,bottom:f,left:p,right:m,type:0===h&&0===f&&0===p&&0===m?"VALID":"EXPLICIT"},c=qa((n-o+h+f)/r+1,a),d=qa((e-i+p+m)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,m,g,v,x,o,a),A=i?p*d:p;let R;return"channelsFirst"===a?R=[l,A,_,D]:"channelsLast"===a&&(R=[l,_,D,A]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:_,outWidth:D,outChannels:A,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:f,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:t,outShape:R,filterShape:n}}function Yi(t,n,e,r,s,o=!1,i="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=t}const[f,p,m,,g]=n,[y,b,v]=UC(e),[x,w,_]=UC(r),D=Iu(f,x),A=Iu(p,w),R=Iu(m,_),{padInfo:O,outDepth:j,outHeight:K,outWidth:G}=function B7(t,n,e,r,s,o,i,a,l,u,c){let d,h,f,p;if("number"==typeof t){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const g=function P7(t,n,e,r,s,o){null==s&&(s=VC(t,n,r));const a=t[1],l=t[2];return[qa((t[0]-n+2*s)/r+1,o),qa((a-n+2*s)/r+1,o),qa((l-n+2*s)/r+1,o),e]}([n,e,r,1],a,1,s,t,c);h=g[0],f=g[1],p=g[2]}else if("same"===t){h=Math.ceil(n/s),f=Math.ceil(e/o),p=Math.ceil(r/i);const m=(h-1)*s+a-n,g=(f-1)*o+l-e,y=(p-1)*i+u-r,b=Math.floor(m/2),v=m-b,x=Math.floor(g/2),w=g-x,_=Math.floor(y/2);d={top:x,bottom:w,left:_,right:y-_,front:b,back:v,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((n-a+1)/s),f=Math.ceil((e-l+1)/o),p=Math.ceil((r-u+1)/i)}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(s,u,c,d,y,b,v,D,A,R,a),Z=o?g*h:g;let q;return"channelsFirst"===i?q=[l,Z,j,K,G]:"channelsLast"===i&&(q=[l,j,K,G,Z]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:j,outHeight:K,outWidth:G,outChannels:Z,padInfo:O,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:D,effectiveFilterHeight:A,effectiveFilterWidth:R,dilationDepth:x,dilationHeight:w,dilationWidth:_,inShape:t,outShape:q,filterShape:n}}function VC(t,n,e,r=1){const s=Iu(n,r);return Math.floor((t[0]*(e-1)-e+s)/2)}function Og(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function UC(t){return"number"==typeof t?[t,t,t]:t}function Iu(t,n){return n<=1?t:t+(t-1)*(n-1)}function qa(t,n){if(!n)return Math.trunc(t);switch(n){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${n}`)}}function Ji(t){const[n,e,r]=Og(t);return 1===n&&1===e&&1===r}function cr(t,n){return Ji(t)||Ji(n)}function mi(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const W=M({reshape_:function z7(t,n){const r={x:T(t,"x","reshape","string_or_numeric")};return F.runKernel(rg,r,{shape:n})}}),Mg=M({avgPool_:function V7(t,n,e,r,s){const o=T(t,"x","avgPool","float32");S(cr(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=o,l=!1;3===o.rank&&(l=!0,a=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),null!=s&&S(Jn(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let d=F.runKernel(xm,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s});return d=Ae(d,o.dtype),l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),T2=M({avgPool3d_:function U7(t,n,e,r,s,o="NDHWC"){const i=T(t,"x","avgPool3d","float32");let a=i,l=!1;4===i.rank&&(l=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),null!=s&&S(Jn(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let d=F.runKernel(wm,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return d=Ae(d,a.dtype),l?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});function H7(t){let n;return n=0===t.rank||1===t.rank?W(t,[1,1,1,t.size]):2===t.rank?W(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?W(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,n}const Du=M({batchNorm_:function W7(t,n,e,r,s,o){null==o&&(o=.001);const i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm");let u,c;null!=s&&(u=T(s,"scale","batchNorm")),null!=r&&(c=T(r,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:H7(i),scale:u,offset:c,mean:a,variance:l},p=F.runKernel(Fm,h,{varianceEpsilon:o});return W(p,i.shape)}}),G7=M({batchNorm2d_:function j7(t,n,e,r,s,o){const i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm");let u,c;return null!=s&&(u=T(s,"scale","batchNorm")),null!=r&&(c=T(r,"offset","batchNorm")),S(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&S(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Du(i,a,l,c,u,o)}}),K7=M({batchNorm3d_:function q7(t,n,e,r,s,o){const i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm");let u,c;return null!=s&&(u=T(s,"scale","batchNorm")),null!=r&&(c=T(r,"offset","batchNorm")),S(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&S(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Du(i,a,l,c,u,o)}}),Y7=M({batchNorm4d_:function X7(t,n,e,r,s,o){const i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm");let u,c;return null!=s&&(u=T(s,"scale","batchNorm")),null!=r&&(c=T(r,"offset","batchNorm")),S(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&S(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Du(i,a,l,c,u,o)}}),Jr=M({clipByValue_:function J7(t,n,e){const r=T(t,"x","clipByValue");return S(n<=e,()=>`Error in clip: min (${n}) must be less than or equal to max (${e}).`),F.runKernel(Nd,{x:r},{clipValueMin:n,clipValueMax:e})}}),Tn=M({concat_:function Z7(t,n=0){S(t.length>=1,()=>"Pass at least one tensor to concat");const e=Y$(t,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?Ga(e[0]):F.runKernel(_m,e,{axis:n})}}),e9=M({concat1d_:function Q7(t){return Tn(t,0)}}),n9=M({concat2d_:function t9(t,n){return Tn(t,n)}}),s9=M({concat3d_:function r9(t,n){return Tn(t,n)}}),i9=M({concat4d_:function o9(t,n){return Tn(t,n)}}),Zi=M({conv2d_:function a9(t,n,e,r,s="NHWC",o=[1,1],i){const a=T(t,"x","conv2d"),l=T(n,"filter","conv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=i&&S(Jn(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(cr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const p=F.runKernel(Sm,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),HC=M({conv1d_:function l9(t,n,e,r,s="NWC",o=1,i){const a=T(t,"x","conv1d"),l=T(n,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=W(a,[1,a.shape[0],a.shape[1]])),S(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=i&&S(Jn(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),S(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(cr(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),S("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=W(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=W(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Zi(h,d,[1,e],r,"NHWC",[1,o],i);return W(g,c?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),WC=M({conv2DBackpropInput_:function u9(t,n,e,r,s,o="NHWC",i){S(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let a=t,l=n,u=!1;3===n.rank&&(u=!0,l=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]),a=[1,t[0],t[1],t[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===o?a[3]:a[1],d="NHWC"===o?l.shape[3]:l.shape[1];S(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),S(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),null!=i&&S(Jn(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`);const p=F.runKernel(Em,{dy:l,filter:e},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return u?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),jC=M({conv2dTranspose_:function c9(t,n,e,r,s,o){const i=T(t,"x","conv2dTranspose"),a=T(n,"filter","conv2dTranspose");return WC(e,i,a,r,s,"NHWC",o)}}),k2=M({conv3d_:function d9(t,n,e,r,s="NDHWC",o=[1,1,1]){const i=T(t,"x","conv3d"),a=T(n,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(cr(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),S("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const h=F.runKernel(Nm,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:o});return u?W(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),Ch=M({depthwiseConv2d_:function h9(t,n,e,r,s="NHWC",o=[1,1],i){const a=T(t,"x","depthwiseConv2d"),l=T(n,"filter","depthwiseConv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),S(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=i&&S(Jn(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const f=F.runKernel(km,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),GC=M({floorDiv_:function f9(t,n){let e=T(t,"a","floorDiv"),r=T(n,"b","floorDiv");return[e,r]=mn(e,r),F.runKernel(Pd,{a:e,b:r})}}),Le=M({div_:function p9(t,n){let e=T(t,"a","div"),r=T(n,"b","div");return[e,r]=mn(e,r),"int32"===e.dtype&&"int32"===r.dtype?GC(e,r):F.runKernel(Ad,{a:e,b:r},{})}}),Ih=M({elu_:function m9(t){const e={x:T(t,"x","elu")};return F.runKernel(Rd,e)}});function Dh(t,n){const e=t.length,r=[];for(let s=0;s<e;s++){const o=e-1-s,i=t[o]||1;(n[n.length-1-s]||1)>1&&1===i&&r.unshift(o)}return r}function Vn(t,n){const e=[];for(let r=0;r<n.length;r++){const s=t[t.length-r-1],o=n.length-r-1,i=n[o];(null==s||1===s&&i>1)&&e.unshift(o)}return e}function wt(t,n){const e=[],r=Math.max(t.length,n.length);for(let s=0;s<r;s++){let o=t[t.length-s-1];null==o&&(o=1);let i=n[n.length-s-1];if(null==i&&(i=1),1===o)e.unshift(i);else if(1===i)e.unshift(o);else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${n}.`);e.unshift(o)}}return e}const Ka=M({equal_:function g9(t,n){let e=T(t,"a","equal"),r=T(n,"b","equal");return[e,r]=mn(e,r),wt(e.shape,r.shape),F.runKernel(Rm,{a:e,b:r})}}),Os=M({expandDims_:function y9(t,n=0){const e=T(t,"x","expandDims","string_or_numeric");return S(n<=e.rank,()=>"Axis must be <= rank of the tensor"),F.runKernel($m,{input:e},{dim:n})}}),Xa=M({tile_:function b9(t,n){const e=T(t,"x","tile","string_or_numeric");return S(e.rank===n.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${n}.`),F.runKernel(hh,{x:e},{reps:n})}}),A2=M({eye_:function v9(t,n,e,r="float32"){null==n&&(n=t);const s=xt([t,n],r),o=t<=n?t:n;for(let a=0;a<o;++a)s.set(1,a,a);const i=W(s.toTensor(),[t,n]);if(null==e)return i;if(1===e.length)return Xa(Os(i,0),[e[0],1,1]);if(2===e.length)return Xa(Os(Os(i,0),0),[e[0],e[1],1,1]);if(3===e.length)return Xa(Os(Os(Os(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}});function Pg(t,n,e){return F.runKernel(O0,{},{shape:t,value:n,dtype:e})}const _h=M({floor_:function x9(t){const e={x:T(t,"x","floor")};return F.runKernel(Md,e)}}),Sh=M({gather_:function w9(t,n,e=0,r=0){const s=T(t,"x","gather"),o=T(n,"indices","gather","int32");return F.runKernel(Om,{x:s,indices:o},{axis:e,batchDims:r})}}),Fo=M({greater_:function C9(t,n){let e=T(t,"a","greater"),r=T(n,"b","greater");return[e,r]=mn(e,r),wt(e.shape,r.shape),F.runKernel(Mm,{a:e,b:r})}}),Ya=M({greaterEqual_:function I9(t,n){let e=T(t,"a","greaterEqual"),r=T(n,"b","greaterEqual");return[e,r]=mn(e,r),wt(e.shape,r.shape),F.runKernel(Ld,{a:e,b:r})}}),Lg=M({leakyRelu_:function D9(t,n=.2){const r={x:T(t,"x","leakyRelu")};return F.runKernel(Pm,r,{alpha:n})}}),ms=M({log_:function _9(t){const e={x:T(t,"x","log")};return F.runKernel(Hd,e)}}),Ms=M({exp_:function S9(t){const e={x:T(t,"x","exp")};return F.runKernel(Fd,e)}}),Ps=M({max_:function E9(t,n=null,e=!1){const s={x:T(t,"x","max")};return F.runKernel(Wm,s,{reductionIndices:n,keepDims:e})}}),V=M({mul_:function N9(t,n){let e=T(t,"a","mul"),r=T(n,"b","mul");return[e,r]=mn(e,r),F.runKernel(Kd,{a:e,b:r})}}),Fe=M({sub_:function T9(t,n){let e=T(t,"a","sub"),r=T(n,"b","sub");return[e,r]=mn(e,r),F.runKernel(uh,{a:e,b:r})}}),Pe=M({sum_:function k9(t,n=null,e=!1){let r=T(t,"x","sum");return"bool"===r.dtype&&(r=Ae(r,"int32")),F.runKernel(ug,{x:r},{axis:n,keepDims:e})}}),qC=M({logSoftmax_:function A9(t,n=-1){const e=T(t,"logits","logSoftmax");if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${n}`);return fi((s,o)=>{const a=Ps(s,n,!0),l=Fe(s,a),u=Fe(Ae(l,"float32"),ms(Pe(Ms(l),n,!0)));return o([u]),{value:u,gradFunc:(d,h)=>{const[f]=h,m=Ms(f);return Fe(d,V(Pe(d,n,!0),m))}}})(e)}}),Oo=M({logicalAnd_:function R9(t,n){const e=T(t,"a","logicalAnd","bool"),r=T(n,"b","logicalAnd","bool");return wt(e.shape,r.shape),F.runKernel(zm,{a:e,b:r})}}),Bg=M({maxPool_:function $9(t,n,e,r,s){const o=T(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(cr(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),null!=s&&S(Jn(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const d=F.runKernel(jm,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s});return l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),R2=M({maxPool3d_:function F9(t,n=[1,1,1],e,r,s,o="NDHWC"){const i=T(t,"x","maxPool3d");let a=i,l=!1;4===i.rank&&(l=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),null!=s&&S(Jn(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const d=F.runKernel(Gm,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return l?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),gi=M({maximum_:function O9(t,n){let e=T(t,"a","maximum"),r=T(n,"b","maximum");return[e,r]=mn(e,r),"bool"===e.dtype&&(e=Ae(e,"int32"),r=Ae(r,"int32")),wt(e.shape,r.shape),F.runKernel(jd,{a:e,b:r})}}),gn=M({mean_:function M9(t,n=null,e=!1){const s={x:T(t,"x","mean")};return F.runKernel(qm,s,{axis:n,keepDims:e})}}),Eh=M({min_:function P9(t,n=null,e=!1){const s={x:T(t,"x","min")};return F.runKernel(Km,s,{axis:n,keepDims:e})}}),Nh=M({minimum_:function L9(t,n){let e=T(t,"a","minimum"),r=T(n,"b","minimum");return[e,r]=mn(e,r),"bool"===e.dtype&&(e=Ae(e,"int32"),r=Ae(r,"int32")),wt(e.shape,r.shape),F.runKernel(Gd,{a:e,b:r})}});function KC(t,n){for(let e=0;e<t.length;++e)if(t[t.length-e-1]!==n-1-e)return!1;return!0}function $2(t,n,e){const r=t.length+n.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(t[o++]):s.push(n[i++]);return s}function tr(t,n){const e=[],r=t.length;for(let o=0;o<r;o++)-1===n.indexOf(o)&&e.push(t[o]);return[e,n.map(o=>t[o])]}function xn(t,n){return $2(t,n.map(r=>1),n)}function dr(t,n,e){S(KC(n,e),()=>`${t} supports only inner-most axes for now. Got axes ${n} and rank-${e} input.`)}function wn(t,n){if(KC(t,n))return null;const e=[];for(let r=0;r<n;++r)-1===t.indexOf(r)&&e.push(r);return t.forEach(r=>e.push(r)),e}function _u(t){return t.map((n,e)=>[e,n]).sort((n,e)=>n[1]-e[1]).map(n=>n[0])}function kn(t,n){const e=[];for(let r=n-t;r<n;++r)e.push(r);return e}const Wt=M({square_:function B9(t){const n=T(t,"x","square");return F.runKernel("Square",{x:n},{})}}),XC=M({moments_:function z9(t,n=null,e=!1){const r=mt(n,(t=T(t,"x","moments")).shape),s=gn(t,r,e);let o=s.shape;e||(o=xn(s.shape,r));const i=Wt(Fe(Ae(t,"float32"),W(s,o)));return{mean:s,variance:gn(i,r,e)}}}),yn=M({neg_:function V9(t){const e={x:T(t,"x","neg")};return F.runKernel(Ym,e)}}),Su=M({notEqual_:function U9(t,n){let e=T(t,"a","notEqual"),r=T(n,"b","notEqual");return[e,r]=mn(e,r),wt(e.shape,r.shape),F.runKernel(Jm,{a:e,b:r})}}),YC=M({oneHot_:function H9(t,n,e=1,r=0){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);const o={indices:T(t,"indices","oneHot","int32")};return F.runKernel(Qm,o,{depth:n,onValue:e,offValue:r})}});function An(t,n="float32"){if("complex64"===n){const r=An(t,"float32"),s=An(t,"float32");return Ua(r,s)}const e=xr(te(t),n);return F.makeTensor(e,t,n)}function yi(t,n="float32"){if("complex64"===n){const r=yi(t,"float32"),s=An(t,"float32");return Ua(r,s)}const e=A$(te(t),n);return F.makeTensor(e,t,n)}const gs=M({onesLike_:function W9(t){const e={x:T(t,"x","onesLike")};return F.runKernel(Zm,e)}}),zg=M({pad_:function j9(t,n,e=0){const r=T(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return F.runKernel(tg,{x:r},{paddings:n,constantValue:e})}}),Vg=M({prelu_:function G9(t,n){const e=T(t,"x","prelu"),r=T(n,"alpha","prelu");return F.runKernel(ng,{x:e,alpha:r})}});var F2=B(349);class JC{constructor(n,e,r,s,o){this.mean=n,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=o||Math.random();this.random=F2.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let n,e,r=!1;for(;!r;){let s,o,i;do{s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);n=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(n))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(n)}convertValue(n){return null==this.dtype||"float32"===this.dtype?n:Math.round(n)}isValidTruncated(n){return n<=this.upper&&n>=this.lower}}class q9{constructor(n=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=n,this.range=e-n,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${n} - ${e} <= 1 and dtype is not float`);this.random=F2.alea(s)}convertValue(n){return this.canReturnFloat()?n:Math.round(n)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Z9=M({randomNormal_:function J9(t,n=0,e=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new JC(n,e,r,!1,s),i=xt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),Th=M({randomUniform_:function Q9(t,n=0,e=1,r="float32",s){const o=xt(t,r),i=new q9(n,e,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),bi=M({relu_:function eY(t){const e={x:T(t,"x","relu")};return F.runKernel(Jd,e)}}),vi=M({reverse_:function tY(t,n){const r={x:T(t,"x","reverse")};return F.runKernel(ig,r,{dims:n})}}),QC=M({selu_:function nY(t){const e={x:T(t,"x","selu")};return F.runKernel(th,e)}}),O2=M({separableConv2d_:function rY(t,n,e,r,s,o=[1,1],i="NHWC"){const a=T(t,"x","separableConv2d"),l=T(n,"depthwiseFilter","separableConv2d"),u=T(e,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),S(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],f=l.shape[3];S(u.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${u.shape[2]}.`);const p=Ch(c,l,r,s,i,o),g=Zi(p,u,1,"valid",i);return d?W(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),Eu=M({sigmoid_:function sY(t){const e={x:T(t,"x","sigmoid")};return F.runKernel(oh,e)}}),Ot=M({slice_:function oY(t,n,e){const r=T(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return F.runKernel(lg,{x:r},{begin:n,size:e})}}),eI=M({slice1d_:function iY(t,n,e){const r=T(t,"x","slice1d");return S(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ot(r,[n],[e])}}),M2=M({slice2d_:function aY(t,n,e){const r=T(t,"x","slice2d");return S(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ot(r,n,e)}}),tI=M({slice3d_:function lY(t,n,e){const r=T(t,"x","slice3d");return S(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ot(r,n,e)}}),Ug=M({slice4d_:function uY(t,n,e){const r=T(t,"x","slice4d");return S(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ot(r,n,e)}}),Hg=M({softmax_:function cY(t,n=-1){const e=T(t,"logits","softmax","float32");if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${n}`);return F.runKernel(hg,{logits:e},{dim:n})}}),kh=M({softplus_:function dY(t){const e={x:T(t,"x","softplus")};return F.runKernel(ih,e)}}),ys=M({split_:function hY(t,n,e=0){const s={x:T(t,"x","split")};return F.runKernel(dg,s,{numOrSizeSplits:n,axis:e})}}),wr=M({sqrt_:function fY(t){const e={x:T(t,"x","sqrt")};return F.runKernel(ah,e)}}),Nu=M({squeeze_:function pY(t,n){const e=T(t,"x","squeeze");return W(e,za(e.shape,n).newShape)}}),Ls=M({stack_:function mY(t,n=0){const e=Y$(t,"tensors","stack","string_or_numeric");return S(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&S(n<=e[0].rank,()=>"Axis must be <= rank of the tensor"),F.runKernel(eg,e,{axis:n})}}),nI=M({tanh_:function gY(t){const e={x:T(t,"x","tanh")};return F.runKernel(dh,e)}});function Bs(t,n){u0(t);const e=vh(t,n);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return xh(t,null,e,n)}function Ah(t,n,e){if(u0(t),null!=n&&2!==n.length)throw new Error("tensor2d() requires shape to have two numbers");const r=vh(t,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return xh(t,n,r,e)}const rI=M({truncatedNormal_:function yY(t,n=0,e=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new JC(n,e,r,!0,s),i=xt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),fo=M({unstack_:function bY(t,n=0){const e=T(t,"x","unstack","string_or_numeric");return S(n>=-e.shape.length&&n<e.shape.length,()=>`Axis = ${n} is not in [-${e.shape.length}, ${e.shape.length})`),F.runKernel(pg,{value:e},{axis:n})}}),Wg=M({broadcastTo_:function xY(t,n){let e=T(t,"broadcastTo","x");const r=e.shape;if(n.some(u=>!(u>0)||u%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${n}].`);if(n.length<e.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${e.rank}.`);if(n.length>e.rank){const u=e.shape.slice();for(;u.length<n.length;)u.unshift(1);e=W(e,u)}const s=e.shape,o=Array.from(n);for(let u=n.length-1;u>=0;u--)if(s[u]===n[u])o[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${n}].`);return 0===o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?Ga(e):F.runKernel(hh,{x:e},{reps:o})}}),bs=M({where_:function wY(t,n,e){const r=T(n,"a","where"),s=T(e,"b","where"),o=T(t,"condition","where","bool"),i=wt(r.shape,s.shape),a=Wg(r,i),l=Wg(s,i);return 1===o.rank&&S(o.shape[0]===r.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),1!==o.rank&&fs(o.shape,l.shape,"Error in where: "),F.runKernel(ag,{condition:o,t:a,e:l})}}),St=M({zerosLike_:function CY(t){const e={x:T(t,"x","zerosLike")};return F.runKernel(gg,e)}}),Ht=M({transpose_:function IY(t,n){const e=T(t,"x","transpose");return null==n&&(n=e.shape.map((o,i)=>i).reverse()),S(e.rank===n.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${n}.`),n.forEach(o=>{S(o>=0&&o<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${n}`)}),e.rank<=1?e.clone():F.runKernel(fg,{x:e},{perm:n})}}),SY=M({dropout_:function _Y(t,n,e,r){const s=T(t,"x","dropout");if(S("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(n>=0&&n<1,()=>`rate must be a float in the range [0, 1), but got ${n}.`),0===n)return t instanceof un?s.clone():s;const o=function DY(t,n){if(null==n)return t.shape.slice();if(zt(t.shape,n))return n;if(t.shape.length===n.length){const e=[];for(let r=0;r<t.shape.length;r++)e.push(null==n[r]&&null!=t.shape[r]?t.shape[r]:n[r]);return e}return n}(s,e),i=1-n,a=Le(_h(me(Th(o,0,1,"float32",r),i)),i);return V(s,a)}}),sI=M({imag_:function EY(t){const e={input:T(t,"input","imag")};return F.runKernel(B0,e)}}),jg=M({real_:function NY(t){const e={input:T(t,"input","real")};return F.runKernel(J0,e)}}),Gg=M({fft_:function TY(t){return S("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),F.runKernel("FFT",{input:t})}}),qg=M({rfft_:function kY(t,n){S("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let e=t.shape[t.shape.length-1];const r=t.size/e;let s;if(null!=n&&n<e){const p=t.shape.map(g=>0),m=t.shape.map(g=>g);m[t.shape.length-1]=n,s=Ot(t,p,m),e=n}else if(null!=n&&n>e){const p=t.shape.map(m=>m);p[t.shape.length-1]=n-e,s=Tn([t,An(p)],t.shape.length-1),e=n}else s=t;const o=St(s),i=W(Ua(s,o),[r,e]),a=Gg(i),l=Math.floor(e/2)+1,u=jg(a),c=sI(a),d=ys(u,[l,e-l],u.shape.length-1),h=ys(c,[l,e-l],c.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,W(Ua(d[0],h[0]),f)}}),Rh=M({ifft_:function AY(t){return S("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),F.runKernel(L0,{input:t})}}),oI=M({irfft_:function RY(t){const n=t.shape[t.shape.length-1],e=t.size/n;let r;if(n<=2){const s=W(t,[e,n]);r=Rh(s)}else{const s=[e,2*(n-1)],o=W(jg(t),[e,n]),i=W(sI(t),[e,n]),a=vi(Ot(o,[0,1],[e,n-2]),1),l=V(vi(Ot(i,[0,1],[e,n-2]),1),Oe(-1)),u=Tn([o,a],1),c=Tn([i,l],1),d=W(Ua(u,c),[s[0],s[1]]);r=Rh(d)}if(r=jg(r),3===t.rank&&0!==t.shape[0]){const s=r,o=t.shape[0];r=W(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),iI=M({conv2DBackpropFilter_:function $Y(t,n,e,r,s,o="NHWC",i){let a=t;3===t.rank&&(a=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;3===l.rank&&(l=W(n,[1,n.shape[0],n.shape[1],n.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?l.shape[3]:l.shape[1];return S(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),S(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),null!=i&&S(Jn(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`),F.runKernel(I0,{x:a,dy:l},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:e})}}),aI=M({relu6_:function FY(t){const e={x:T(t,"x","relu6")};return F.runKernel(Zd,e)}}),$h=M({step_:function OY(t,n=0){const r={x:T(t,"x","step")};return F.runKernel(fh,r,{alpha:n})}});function Kg(t,n,e){if(null==e||"linear"===e)return t;if("relu"===e)return V(t,$h(n));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Xg(t,n){let e=n;const r=Vn(t.shape,n.shape);return r.length>0&&(e=Pe(e,r)),W(e,t.shape)}function Yg(t,n,e,r){if("linear"===n)return t;if("relu"===n)return bi(t);if("elu"===n)return Ih(t);if("relu6"===n)return aI(t);if("prelu"===n)return Vg(t,e);if("leakyrelu"===n)return Lg(t,r);throw new Error(`Unknown fused activation ${n}.`)}const Jg=(t,n)=>!(t>0)||"linear"===n,P2=M({fusedConv2d_:function MY({x:t,filter:n,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===Jg(F.state.gradientDepth,l=l||"linear")){let w=Zi(t,n,e,r,s,o,i);return null!=a&&(w=me(w,a)),Yg(w,l,u,c)}const d=T(t,"x","conv2d"),h=T(n,"filter","conv2d");let f=d,p=!1;3===d.rank&&(p=!0,f=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),null!=i&&S(Jn(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),S(f.shape[3]===h.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${h.shape[2]}.`),S(cr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),S("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const m=er(f.shape,h.shape,e,o,r,i);let g,y;null!=a&&(g=T(a,"bias","fused conv2d"),[g]=mn(g,d),wt(m.outShape,g.shape)),null!=u&&(y=T(u,"prelu weights","fused conv2d"));const b=(w,_)=>{const[D,A,R,O]=_,j=Kg(w,R,l);S(Ji(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const Z=[WC(A.shape,j,D,e,r),iI(A,j,D.shape,e,r)];if(null!=O){const q=Xg(O,j);Z.push(q)}return Z},v={x:f,filter:h,bias:g,preluActivationWeights:y},x={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?fi((_,D,A)=>{let R=F.runKernel(bg,v,x);return A([D,_,R]),p&&(R=W(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,h):fi((_,D,A,R)=>{let O=F.runKernel(bg,v,x);return R([D,_,O,A]),p&&(O=W(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:b}})(f,h,g)}}),L2=M({depthwiseConv2dNativeBackpropFilter_:function PY(t,n,e,r,s,o=[1,1],i){let a=t;3===t.rank&&(a=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;return 3===l.rank&&(l=W(n,[1,n.shape[0],n.shape[1],n.shape[2]])),F.runKernel(T0,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:e})}}),B2=M({depthwiseConv2dNativeBackpropInput_:function LY(t,n,e,r,s,o=[1,1],i){let a=n,l=!1;3===n.rank&&(l=!0,a=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]));const d=F.runKernel(k0,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:t});return l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),zY=M({fusedDepthwiseConv2d_:function BY({x:t,filter:n,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===Jg(F.state.gradientDepth,l)){let w=Ch(t,n,e,r,s,o,i);return null!=a&&(w=me(w,a)),Yg(w,l,u,c)}const d=T(t,"x","depthwiseConv2d"),h=T(n,"filter","depthwiseConv2d");let f=d,p=!1;3===d.rank&&(p=!0,f=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),S(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==o&&(o=[1,1]),S(cr(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),null!=i&&S(Jn(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${i} but got pad ${r}.`);const m=er(f.shape,h.shape,e,o,r,i,!0);let g,y;null!=a&&(g=T(a,"bias","fused conv2d"),[g]=mn(g,d),wt(m.outShape,g.shape)),null!=u&&(y=T(u,"prelu weights","fused depthwiseConv2d"));const b=(w,_)=>{S(Ji(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[D,A,R,O]=_,j=Kg(w,R,l),K=B2(A.shape,j,D,e,r,o,i),G=L2(A,j,D.shape,e,r,o,i);return null!=O?[K,G,Xg(g,j)]:[K,G]},v={x:f,filter:h,bias:g,preluActivationWeights:y},x={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?fi((_,D,A)=>{let R=F.runKernel(vg,v,x);return A([D,_,R]),p&&(R=W(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,h):fi((_,D,A,R)=>{let O=F.runKernel(vg,v,x);return R([D,_,O,A]),p&&(O=W(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:b}})(f,h,g)}}),At=M({matMul_:function VY(t,n,e=!1,r=!1){let s=T(t,"a","matMul"),o=T(n,"b","matMul");return[s,o]=mn(s,o),F.runKernel(Cm,{a:s,b:o},{transposeA:e,transposeB:r})}}),lI=M({fusedMatMul_:function UY({a:t,b:n,transposeA:e=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(!1===Jg(F.state.gradientDepth,o)){let O=At(t,n,e,r);return null!=s&&(O=me(O,s)),Yg(O,o,i,a)}let l=T(t,"a","fused matMul"),u=T(n,"b","fused matMul");[l,u]=mn(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],p=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=te(p),y=te(m);S(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),S(zt(p,m),()=>`Error in fused matMul: outer dimensions (${p}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),S(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);const b=l.shape.slice(0,-2).concat([h,f]),v=W(l,e?[g,c,h]:[g,h,c]),x=W(u,r?[y,f,d]:[y,d,f]);let w,_;null!=s&&(w=T(s,"bias","fused matMul"),[w]=mn(w,l),wt(b,w.shape)),null!=i&&(_=T(i,"prelu weights","fused matMul"));const D=(O,j)=>{const[K,G,Z,q]=j,Y=Kg(W(O,Z.shape),Z,o);let re,ee;return e||r?!e&&r?(re=At(Y,G,!1,!1),ee=At(Y,K,!0,!1)):e&&!r?(re=At(G,Y,!1,!0),ee=At(K,Y,!1,!1)):(re=At(G,Y,!0,!0),ee=At(Y,K,!0,!0)):(re=At(Y,G,!1,!0),ee=At(K,Y,!0,!1)),null!=s?[re,ee,Xg(q,Y)]:[re,ee]},A={a:v,b:x,bias:w,preluActivationWeights:_},R={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?fi((j,K,G)=>{const Z=F.runKernel(yg,A,R);return G([j,K,Z]),{value:W(Z,b),gradFunc:D}})(v,x):fi((j,K,G,Z)=>{const q=F.runKernel(yg,A,R);return Z([j,K,q,G]),{value:W(q,b),gradFunc:D}})(v,x,w)}});function z2(t,n,e){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const i=2*Math.PI*o/(t+r-1);s[o]=n-e*Math.cos(i)}return Bs(s,"float32")}M({hammingWindow_:function WY(t){return z2(t,.54,.46)}});const V2=M({hannWindow_:function GY(t){return z2(t,.5,.5)}}),U2=M({frame_:function qY(t,n,e,r=!1,s=0){let o=0;const i=[];for(;o+n<=t.size;)i.push(Ot(t,o,n)),o+=e;if(r)for(;o<t.size;){const a=o+n-t.size,l=Tn([Ot(t,o,n-a),Pg([a],s)]);i.push(l),o+=e}return 0===i.length?Ah([],[0,n]):W(Tn(i),[i.length,n])}});M({stft_:function KY(t,n,e,r,s=V2){null==r&&(r=function HY(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}(n));const o=U2(t,n,e),i=V(o,s(n)),a=[];for(let l=0;l<o.shape[0];l++)a.push(qg(Ot(i,[l,0],[1,n]),r));return Tn(a)}});const JY=M({cropAndResize_:function YY(t,n,e,r,s="bilinear",o=0){const i=T(t,"image","cropAndResize"),a=T(n,"boxes","cropAndResize","float32"),l=T(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return S(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),S(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),F.runKernel(S0,{image:i,boxes:a,boxInd:l},{method:s,extrapolationValue:o,cropSize:r})}}),QY=M({flipLeftRight_:function ZY(t){const n=T(t,"image","flipLeftRight","float32");return S(4===n.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`),F.runKernel(M0,{image:n},{})}}),tJ=M({rotateWithOffset_:function eJ(t,n,e=0,r=.5){const s=T(t,"image","rotateWithOffset","float32");return S(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),F.runKernel(lC,{image:s},{radians:n,fillValue:e,center:r})}});function Tu(t,n,e,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=t.shape[0];return e=Math.min(e,i),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),S(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),S(1===n.rank,()=>"scores must be a 1D tensor"),S(n.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`),S(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const rJ=M({nonMaxSuppression_:function nJ(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=T(t,"boxes","nonMaxSuppression"),i=T(n,"scores","nonMaxSuppression"),a=Tu(o,i,e,r,s);return F.runKernel(G0,{boxes:o,scores:i},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function sJ(t,n,e){const r=function oJ(t,n,e){return function aJ(t,n,e){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=e(n,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(t,n,e||iJ)}(t,n,e);t.splice(r<0?-(r+1):r,0,n)}function iJ(t,n){return t>n?1:t<n?-1:0}function uI(t,n,e,r,s){return hI(t,n,e,r,s,0)}function cI(t,n,e,r,s,o){return hI(t,n,e,r,s,0,!1,o,!0)}function dI(t,n,e,r,s,o){return hI(t,n,e,r,s,o,!0)}function hI(t,n,e,r,s,o,i=!1,a=!1,l=!1){const u=[];for(let g=0;g<n.length;g++)n[g]>s&&u.push({score:n[g],boxIndex:g,suppressBeginIndex:0});u.sort(H2);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<e&&u.length>0;){const g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:v}=g;if(y<s)break;let x=!1;for(let w=d.length-1;w>=v;--w){const _=lJ(t,b,d[w]);if(_>=r){x=!0;break}if(g.score=g.score*uJ(r,c,_),g.score<=s)break}g.suppressBeginIndex=d.length,x||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&sJ(u,g,H2))}const f=d.length,p=e-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=f),m}function lJ(t,n,e){const r=t.subarray(4*n,4*n+4),s=t.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),f=(a-o)*(l-i),p=(d-u)*(h-c);if(f<=0||p<=0)return 0;const m=Math.max(o,u),g=Math.max(i,c),y=Math.min(a,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(f+p-v)}function uJ(t,n,e){const r=Math.exp(n*e*e);return e<=t?r:0}function H2(t,n){return t.score-n.score||t.score===n.score&&n.boxIndex-t.boxIndex}function fI(){return(fI=Q(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=T(t,"boxes","nonMaxSuppressionAsync"),i=T(n,"scores","nonMaxSuppressionAsync"),a=Tu(o,i,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=uI(u,c,e,r,s);return o!==t&&o.dispose(),i!==n&&i.dispose(),Bs(d,"int32")})).apply(this,arguments)}const fJ=M({nonMaxSuppressionWithScore_:function hJ(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=T(t,"boxes","nonMaxSuppression"),a=T(n,"scores","nonMaxSuppression"),l=Tu(i,a,e,r,s,o),d=F.runKernel(K0,{boxes:i,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function pI(){return(pI=Q(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=T(t,"boxes","nonMaxSuppressionAsync"),a=T(n,"scores","nonMaxSuppressionAsync"),l=Tu(i,a,e,r,s,o);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=yield Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:f}=dI(c,d,e,r,s,o);return i!==t&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Bs(h,"int32"),selectedScores:Bs(f)}})).apply(this,arguments)}const yJ=M({nonMaxSuppressionPadded_:function gJ(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=T(t,"boxes","nonMaxSuppression"),a=T(n,"scores","nonMaxSuppression"),l=Tu(i,a,e,r,s,null),p=F.runKernel(q0,{boxes:i,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:p[0],validOutputs:p[1]}}});function mI(){return(mI=Q(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=T(t,"boxes","nonMaxSuppressionAsync"),a=T(n,"scores","nonMaxSuppressionAsync"),l=Tu(i,a,e,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([i.data(),a.data()]),{selectedIndices:p,validOutputs:m}=cI(h,f,u,c,d,o);return i!==t&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Bs(p,"int32"),validOutputs:Oe(m,"int32")}})).apply(this,arguments)}const W2=M({resizeBilinear_:function xJ(t,n,e=!1,r=!1){const s=T(t,"images","resizeBilinear");S(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===n.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),S(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=F.runKernel(og,{images:o},{alignCorners:e,halfPixelCenters:r,size:n});return i?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),j2=M({resizeNearestNeighbor_:function wJ(t,n,e=!1,r=!1){const s=T(t,"images","resizeNearestNeighbor");S(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===n.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),S("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=F.runKernel(sg,{images:o},{alignCorners:e,halfPixelCenters:r,size:n});return i?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),IJ=M({transform_:function CJ(t,n,e="nearest",r="constant",s=0,o){const i=T(t,"image","transform","float32"),a=T(n,"transforms","transform","float32");return S(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),S(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),F.runKernel(oC,{image:i,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:o})}}),ku=M({lessEqual_:function DJ(t,n){let e=T(t,"a","lessEqual"),r=T(n,"b","lessEqual");return[e,r]=mn(e,r),wt(e.shape,r.shape),F.runKernel(Bm,{a:e,b:r})}});function gI(t,n,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return F.runKernel(Y0,{},{start:t,stop:n,step:e,dtype:r})}const SJ=M({bandPart_:function _J(t,n,e){S(n%1==0,()=>`bandPart(): numLower must be an integer, got ${n}.`),S(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const r=T(t,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);if(!(n<=o))throw new Error(`bandPart(): numLower (${n}) must not be greater than the number of rows (${o}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);n<0&&(n=o),e<0&&(e=i);const a=W(gI(0,o,1,"int32"),[-1,1]),l=gI(0,i,1,"int32"),u=Fe(a,l),c=Oo(ku(u,Oe(+n,"int32")),Ya(u,Oe(-e,"int32"))),d=An([o,i],r.dtype);return W(Ls(fo(W(r,[-1,o,i])).map(h=>bs(c,h,d))),s)}}),Ja=M({pow_:function EJ(t,n){let e=T(t,"base","pow"),r=T(n,"exp","pow");return[e,r]=mn(e,r),F.runKernel(Xd,{a:e,b:r})}});function G2(t,n,e=null){if(0===t.rank)return Qn(t);if(1!==t.rank&&null===e)return G2(W(t,[-1]),n,e);if(1===t.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===n)return Pe(Qn(t),e);if(n===1/0)return Ps(Qn(t),e);if(n===-1/0)return Eh(Qn(t),e);if("euclidean"===n||2===n)return wr(Pe(Ja(Qn(t),Oe(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(e)&&2===e.length){if(1===n)return Ps(Pe(Qn(t),e[0]),e[1]-1);if(n===1/0)return Ps(Pe(Qn(t),e[1]),e[0]);if(n===-1/0)return Eh(Pe(Qn(t),e[1]),e[0]);if("fro"===n||"euclidean"===n)return wr(Pe(Wt(t),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const yI=M({norm_:function NJ(t,n="euclidean",e=null,r=!1){const s=G2(t=T(t,"x","norm"),n,e);let o=s.shape;if(r){const i=mt(e,t.shape);o=xn(s.shape,i)}return W(s,o)}}),kJ=M({gramSchmidt_:function TJ(t){let n;if(Array.isArray(t)){n=!1,S(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)S(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else n=!0,t=ys(t,t.shape[0],0).map(s=>Nu(s,[0]));S(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const e=[],r=t;for(let s=0;s<t.length;++s)e.push(F.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=V(Pe(V(e[i],o)),e[i]);o=Fe(o,a)}return Le(o,yI(o,"euclidean"))}));return n?Ls(e,0):e}});function q2(t,n=!1){return F.tidy(()=>{S(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const e=t.shape[0],r=t.shape[1];let s=A2(e),o=Ga(t);const i=Ah([[1]],[1,1]);let a=Ga(i);const l=e>=r?r:e;for(let u=0;u<l;++u){const c=o,d=a,h=s;[a,o,s]=F.tidy(()=>{const f=Ot(o,[u,u],[e-u,1]),p=yI(f),m=Ot(o,[u,u],[1,1]),g=bs(Fo(m,0),Ah([[-1]]),Ah([[1]])),y=Fe(m,V(g,p)),b=Le(f,y);a=1===b.shape[0]?Ga(i):Tn([i,Ot(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const v=yn(Le(At(g,y),p)),x=Ot(o,[u,0],[e-u,r]),w=V(v,a),_=Ht(a);if(0===u)o=Fe(x,At(w,At(_,x)));else{const R=Fe(x,At(w,At(_,x)));o=Tn([Ot(o,[0,0],[u,r]),R],0)}const D=Ht(w),A=Ot(s,[0,u],[e,s.shape[1]-u]);if(0===u)s=Fe(A,At(At(A,a),D));else{const R=Fe(A,At(At(A,a),D));s=Tn([Ot(s,[0,0],[e,u]),R],1)}return[a,o,s]}),ut([c,d,h])}return!n&&e>r&&(s=Ot(s,[0,0],[e,r]),o=Ot(o,[0,0],[r,r])),[s,o]})}const RJ=M({qr_:function AJ(t,n=!1){if(S(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return q2(t,n);{const e=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),r=fo(W(t,[e,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];return r.forEach(l=>{const[u,c]=q2(l,n);s.push(u),o.push(c)}),[W(Ls(s,0),t.shape),W(Ls(o,0),t.shape)]}}});var Ar=(()=>{return(t=Ar||(Ar={}))[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Ar;var t})();const xi=M({computeWeightedLoss_:function $J(t,n,e=Ar.SUM_BY_NONZERO_WEIGHTS){const r=T(t,"losses","computeWeightedLoss");let s=null;null!=n&&(s=T(n,"weights","computeWeightedLoss"));const o=null==s?r:V(r,s);if(e===Ar.NONE)return o;if(e===Ar.SUM)return Pe(o);if(e===Ar.MEAN){if(null==s)return gn(o);{const i=r.size/s.size,a=Le(Pe(o),Pe(s));return i>1?Le(a,Oe(i)):a}}if(e===Ar.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Le(Pe(o),Oe(r.size));{const i=V(s,yi(r.shape)),a=Ae(Pe(Su(i,Oe(0))),"float32");return Le(Pe(o),a)}}throw Error(`Unknown reduction: ${e}`)}});M({absoluteDifference_:function FJ(t,n,e,r=Ar.SUM_BY_NONZERO_WEIGHTS){const s=T(t,"labels","absoluteDifference"),o=T(n,"predictions","absoluteDifference");let i=null;null!=e&&(i=T(e,"weights","absoluteDifference")),fs(s.shape,o.shape,"Error in absoluteDifference: ");const a=Qn(Fe(s,o));return xi(a,i,r)}}),M({cosineDistance_:function MJ(t,n,e,r,s=Ar.SUM_BY_NONZERO_WEIGHTS){const o=T(t,"labels","cosineDistance"),i=T(n,"predictions","cosineDistance");let a=null;null!=r&&(a=T(r,"weights","cosineDistance")),fs(o.shape,i.shape,"Error in cosineDistance: ");const l=Oe(1),u=Fe(l,Pe(V(o,i),e,!0));return xi(u,a,s)}}),M({hingeLoss_:function LJ(t,n,e,r=Ar.SUM_BY_NONZERO_WEIGHTS){let s=T(t,"labels","hingeLoss");const o=T(n,"predictions","hingeLoss");let i=null;null!=e&&(i=T(e,"weights","hingeLoss")),fs(s.shape,o.shape,"Error in hingeLoss: ");const a=Oe(1);s=Fe(V(Oe(2),s),a);const l=bi(Fe(a,V(s,o)));return xi(l,i,r)}}),M({huberLoss_:function zJ(t,n,e,r=1,s=Ar.SUM_BY_NONZERO_WEIGHTS){const o=T(t,"labels","huberLoss"),i=T(n,"predictions","huberLoss");let a=null;null!=e&&(a=T(e,"weights","huberLoss")),fs(o.shape,i.shape,"Error in huberLoss: ");const l=Oe(r),u=Qn(Fe(i,o)),c=Nh(u,l),d=Fe(u,c),h=me(V(Oe(.5),Wt(c)),V(l,d));return xi(h,a,s)}}),M({logLoss_:function UJ(t,n,e,r=1e-7,s=Ar.SUM_BY_NONZERO_WEIGHTS){const o=T(t,"labels","logLoss"),i=T(n,"predictions","logLoss");let a=null;null!=e&&(a=T(e,"weights","logLoss")),fs(o.shape,i.shape,"Error in logLoss: ");const l=Oe(1),u=Oe(r),c=yn(V(o,ms(me(i,u)))),d=V(Fe(l,o),ms(me(Fe(l,i),u))),h=Fe(c,d);return xi(h,a,s)}});const bI=M({squaredDifference_:function WJ(t,n){let e=T(t,"a","squaredDifference"),r=T(n,"b","squaredDifference");return[e,r]=mn(e,r),wt(e.shape,r.shape),F.runKernel(lh,{a:e,b:r},{})}});M({meanSquaredError_:function jJ(t,n,e,r=Ar.SUM_BY_NONZERO_WEIGHTS){const s=T(t,"labels","meanSquaredError"),o=T(n,"predictions","meanSquaredError");let i=null;null!=e&&(i=T(e,"weights","meanSquaredError")),fs(s.shape,o.shape,"Error in meanSquaredError: ");const a=bI(s,o);return xi(a,i,r)}});const vI=M({log1p_:function qJ(t){const e={x:T(t,"x","log1p")};return F.runKernel(Wd,e)}});M({sigmoidCrossEntropy_:function XJ(t,n,e,r=0,s=Ar.SUM_BY_NONZERO_WEIGHTS){let o=T(t,"multiClassLabels","sigmoidCrossEntropy");const i=T(n,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=T(e,"weights","sigmoidCrossEntropy")),fs(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=Oe(r),c=Oe(1),d=Oe(.5);o=me(V(o,Fe(c,u)),V(d,u))}const l=function KJ(t,n){const e=T(t,"labels","sigmoidCrossEntropyWithLogits"),r=T(n,"logits","sigmoidCrossEntropyWithLogits");fs(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=bi(r),o=V(r,e),i=vI(Ms(yn(Qn(r))));return me(Fe(s,o),i)}(o,i);return xi(l,a,s)}});const K2=M({logSumExp_:function JJ(t,n=null,e=!1){const r=T(t,"x","logSumExp"),s=mt(n,r.shape),o=Ps(r,s,!0),i=Fe(r,o),a=Ms(i),l=Pe(a,s),u=ms(l),c=me(W(o,u.shape),u);if(e){const d=xn(c.shape,s);return W(c,d)}return c}});M({softmaxCrossEntropy_:function QJ(t,n,e,r=0,s=Ar.SUM_BY_NONZERO_WEIGHTS){let o=T(t,"onehotLabels","softmaxCrossEntropy");const i=T(n,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=T(e,"weights","softmaxCrossEntropy")),fs(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const u=Oe(r),c=Oe(1),d=Oe(o.shape[1]);o=me(V(o,Fe(c,u)),Le(u,d))}const l=function ZJ(t,n,e=-1){if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${n.rank} and dim was ${e}`);return fi((s,o,i)=>{const l=K2(o,[e],!0),u=Fe(Ae(o,"float32"),l);i([s,u]);const c=yn(V(u,s));return{value:Pe(c,[e]),gradFunc:(f,p)=>{const[m,g]=p,y=xn(f.shape,[e]);return[V(W(f,y),Fe(Ae(m,"float32"),Ms(g))),V(W(f,y),Fe(Ms(g),Ae(m,"float32")))]}}})(t,n)}(o,i);return xi(l,a,s)}});const Za={flipLeftRight:QY,resizeNearestNeighbor:j2,resizeBilinear:W2,rotateWithOffset:tJ,cropAndResize:JY,nonMaxSuppression:rJ,nonMaxSuppressionAsync:function cJ(t,n,e){return fI.apply(this,arguments)},nonMaxSuppressionWithScore:fJ,nonMaxSuppressionWithScoreAsync:function pJ(t,n,e){return pI.apply(this,arguments)},nonMaxSuppressionPadded:yJ,nonMaxSuppressionPaddedAsync:function bJ(t,n,e){return mI.apply(this,arguments)},transform:IJ},tZ={bandPart:SJ,gramSchmidt:kJ,qr:RJ};let xI=(()=>{class t extends Xi{constructor(e,r,s=null){super(),this.learningRate=e,this.rho=r,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=F.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=F.registeredVariables[s];null==this.accumulatedGrads[o]&&(this.accumulatedGrads[o]={originalName:`${s}/accum_grad`,variable:U(()=>St(i).variable(!1))}),null==this.accumulatedUpdates[o]&&(this.accumulatedUpdates[o]={originalName:`${s}/accum_var`,variable:U(()=>St(i).variable(!1))});const l=Array.isArray(e)?e[o].tensor:e[s];if(null==l)return;const u=this.accumulatedGrads[o].variable,c=this.accumulatedUpdates[o].variable;U(()=>{const d=me(V(u,this.rho),V(Wt(l),1-this.rho)),h=V(Le(wr(me(c,this.epsilon)),wr(me(u,this.epsilon))),l),f=me(V(c,this.rho),V(Wt(h),1-this.rho));u.assign(d),c.assign(f);const p=me(V(h,-this.learningRate),i);i.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ut(this.accumulatedGrads.map(e=>e.variable)),ut(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return Q(function*(){const r=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return Q(function*(){const s=(e=yield r.extractIterations(e)).length/2;r.accumulatedGrads=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),r.accumulatedUpdates=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.rho,r.epsilon)}}return t.className="Adadelta",t})();le(xI);let wI=(()=>{class t extends Xi{constructor(e,r=.1){super(),this.learningRate=e,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=F.registeredVariables[s];null==this.accumulatedGrads[o]&&(this.accumulatedGrads[o]={originalName:`${s}/accumulator`,variable:U(()=>Pg(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[o].tensor:e[s];if(null==a)return;const l=this.accumulatedGrads[o].variable;U(()=>{const u=me(l,Wt(a));l.assign(u);const c=me(V(Le(a,wr(me(u,F.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ut(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return Q(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return Q(function*(){e=yield r.extractIterations(e),r.accumulatedGrads=e.map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,r){return new e(r.learningRate,r.initialAccumulatorValue)}}return t.className="Adagrad",t})();le(wI);let CI=(()=>{class t extends Xi{constructor(e,r,s,o=null){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],U(()=>{this.accBeta1=Oe(r).variable(),this.accBeta2=Oe(s).variable()}),null==o&&(this.epsilon=F.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);U(()=>{const s=Fe(1,this.accBeta1),o=Fe(1,this.accBeta2);r.forEach((i,a)=>{const l=F.registeredVariables[i];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:U(()=>St(l).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:U(()=>St(l).variable(!1))});const c=Array.isArray(e)?e[a].tensor:e[i];if(null==c)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,f=me(V(d,this.beta1),V(c,1-this.beta1)),p=me(V(h,this.beta2),V(Wt(c),1-this.beta2)),m=Le(f,s),g=Le(p,o);d.assign(f),h.assign(p);const y=me(V(Le(m,me(wr(g),this.epsilon)),-this.learningRate),l);l.assign(y)}),this.accBeta1.assign(V(this.accBeta1,this.beta1)),this.accBeta2.assign(V(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ut(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&ut(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return Q(function*(){const r=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return Q(function*(){e=yield r.extractIterations(e),U(()=>{r.accBeta1.assign(Ja(r.beta1,r.iterations_+1)),r.accBeta2.assign(Ja(r.beta2,r.iterations_+1))});const s=e.length/2;r.accumulatedFirstMoment=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),r.accumulatedSecondMoment=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon)}}return t.className="Adam",t})();le(CI);let II=(()=>{class t extends Xi{constructor(e,r,s,o=null,i=0){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=o,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],U(()=>{this.iteration=Oe(0).variable(),this.accBeta1=Oe(r).variable()}),null==o&&(this.epsilon=F.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);U(()=>{const s=Fe(1,this.accBeta1),o=Le(-this.learningRate,me(V(this.iteration,this.decay),1));r.forEach((i,a)=>{const l=F.registeredVariables[i];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:St(l).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:St(l).variable(!1)});const c=Array.isArray(e)?e[a].tensor:e[i];if(null==c)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,f=me(V(d,this.beta1),V(c,1-this.beta1)),p=V(h,this.beta2),m=Qn(c),g=gi(p,m);d.assign(f),h.assign(g);const y=me(V(Le(o,s),Le(f,me(g,this.epsilon))),l);l.assign(y)}),this.iteration.assign(me(this.iteration,1)),this.accBeta1.assign(V(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ut(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&ut(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return Q(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return Q(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}}return t.className="Adamax",t})();le(II);let Zg=(()=>{class t extends Xi{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=Array.isArray(e)?e[o].tensor:e[s];if(null==i)return;const a=F.registeredVariables[s];U(()=>{const l=me(V(this.c,i),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ur(Oe(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return Q(function*(){return[yield e.saveIterations()]})()}setWeights(e){var r=this;return Q(function*(){if(0!==(e=yield r.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,r){return new e(r.learningRate)}}return t.className="SGD",t})();le(Zg);let DI=(()=>{class t extends Zg{constructor(e,r,s=!1){super(e),this.learningRate=e,this.momentum=r,this.useNesterov=s,this.accumulations=[],this.m=Oe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=F.registeredVariables[s];null==this.accumulations[o]&&(this.accumulations[o]={originalName:`${s}/momentum`,variable:U(()=>St(i).variable(!1))});const a=this.accumulations[o].variable,l=Array.isArray(e)?e[o].tensor:e[s];null!=l&&U(()=>{let u;const c=me(V(this.m,a),l);u=me(V(this.c,this.useNesterov?me(l,V(c,this.m)):c),i),a.assign(c),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ut(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return Q(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return Q(function*(){e=yield r.extractIterations(e),r.accumulations=e.map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,r){return new e(r.learningRate,r.momentum,r.useNesterov)}}return t.className="Momentum",t})();le(DI);let _I=(()=>{class t extends Xi{constructor(e,r=.9,s=0,o=null,i=!1){if(super(),this.learningRate=e,this.decay=r,this.momentum=s,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==o&&(this.epsilon=F.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=F.registeredVariables[s],a=!1;null==this.accumulatedMeanSquares[o]&&(this.accumulatedMeanSquares[o]={originalName:`${s}/rms`,variable:U(()=>St(i).variable(a))}),null==this.accumulatedMoments[o]&&(this.accumulatedMoments[o]={originalName:`${s}/momentum`,variable:U(()=>St(i).variable(a))}),null==this.accumulatedMeanGrads[o]&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${s}/mg`,variable:U(()=>St(i).variable(a))});const l=Array.isArray(e)?e[o].tensor:e[s];if(null==l)return;const u=this.accumulatedMeanSquares[o].variable,c=this.accumulatedMoments[o].variable;U(()=>{const d=me(V(u,this.decay),V(Wt(l),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[o].variable,f=me(V(h,this.decay),V(l,1-this.decay)),p=Le(V(l,this.learningRate),wr(Fe(d,me(Wt(f),this.epsilon)))),m=me(V(c,this.momentum),p);u.assign(d),h.assign(f),c.assign(m);const g=Fe(i,m);i.assign(g)}else{const h=me(V(u,this.decay),V(Wt(l),1-this.decay)),f=me(V(c,this.momentum),Le(V(l,this.learningRate),wr(me(h,this.epsilon))));u.assign(h),c.assign(f);const p=Fe(i,f);i.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ut(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&ut(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&ut(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return Q(function*(){const r=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&r.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return Q(function*(){e=yield r.extractIterations(e);const s=r.centered?e.length/3:e.length/2,o=!1;r.accumulatedMeanSquares=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})),r.accumulatedMoments=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})),r.centered&&(r.accumulatedMeanGrads=e.slice(2*s,3*s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,r){return new e(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}}return t.className="RMSProp",t})();le(_I);class Qa{static sgd(n){return new Zg(n)}static momentum(n,e,r=!1){return new DI(n,e,r)}static rmsprop(n,e=.9,r=0,s=null,o=!1){return new _I(n,e,r,s,o)}static adam(n=.001,e=.9,r=.999,s=null){return new CI(n,e,r,s)}static adadelta(n=.001,e=.95,r=null){return new xI(n,e,r)}static adamax(n=.002,e=.9,r=.999,s=null,o=0){return new II(n,e,r,s,o)}static adagrad(n,e=.1){return new wI(n,e)}}const Au={sgd:Qa.sgd,momentum:Qa.momentum,adadelta:Qa.adadelta,adagrad:Qa.adagrad,rmsprop:Qa.rmsprop,adamax:Qa.adamax,adam:Qa.adam},nZ=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function SI(){return new Promise(t=>nZ(()=>t()))}function EI(t,n){const e=t[0].length;t.forEach((s,o)=>{S(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),S(n>=0&&n<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=t[0];t.forEach((s,o)=>{for(let i=0;i<e;i++)S(i===n||s[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function wi(t,n){const e=t[0].slice();for(let r=1;r<t.length;r++)e[n]+=t[r][n];return e}const NI=30;function Qg(t){return t<=NI?t:p0(t,Math.floor(Math.sqrt(t)))}function TI(t,n,e){return[e*("number"==typeof t?t:t[0]),n*("number"==typeof t?t:t[1])]}function Fh(t,n,e,r=!0){let s=[];if(r)s=s.concat(n.slice(0)),s.push(t[0]/e),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=n.length;for(let i=0;i<o;++i)s=s.concat([t[i+1]/n[i],n[i]]);s=s.concat(t.slice(o+1))}return s}function Oh(t,n,e=!0){const r=[];if(e){r.push(n);for(let s=n+1;s<t;++s)s<=2*n?(r.push(s),r.push(s-(n+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<t;++i)i>=2*n+1||i%2==1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Mh(t,n,e,r=!0){const s=[];s.push(r?t[0]/e:t[0]*e);for(let o=1;o<t.length;++o)s.push(o<=n.length?r?n[o-1]*t[o]:t[o]/n[o-1]:t[o]);return s}function kI(t,n){const e=[0];for(let r=0;r<n;++r)e.push(t[r][0]);return e}function AI(t,n,e){const r=t.slice(0,1);for(let s=0;s<e;++s)r.push(t[s+1]-n[s][0]-n[s][1]);return r}function RI(t,n){const e=t.shape.length,r=n.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==n.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${n.shape[r-1]} vs. ${e}`);if(0===te(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=n.shape,o=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const a=t.shape,l=s.slice();l.pop();let u=1;for(let d=o;d<e;++d)u*=a[d],l.push(a[d]);const c=[...Ve(t.shape).map(d=>d/u),1].slice(0,o);return[l,i,u,c]}function X2(t,n,e){const r=n.rank>1?n.shape[n.rank-1]:1,s=n.rank>1?n.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${n.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(e.rank-s))throw new Error(o+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+t.length-r)throw new Error(o+" update.rank != "+(s+t.length-r));for(let i=0;i<s;++i)if(e.shape[i]!==n.shape[i])throw new Error(o+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${n.shape[i]}).`);for(let i=0;i<e.rank-s;++i)if(e.shape[i+s]!==t[i+r])throw new Error(o+` updates.shape[${i+s}] (${e.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function Y2(t,n,e){if(n.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==n.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===n.size)throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}X2(e,n,t)}function Ph(t,n,e){const r=n.shape.length,s=r>1?n.shape[r-1]:1,o=e.length;let i=1;for(let d=s;d<o;++d)i*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:te(n.shape)/a,sliceSize:i,strides:[...Ve(e.slice(0,s)),1],outputSize:te(e)}}const ey=1.7580993408473768,ty=1.0507009873554805,$I=.3275911,FI=.254829592,OI=-.284496736,MI=1.421413741,PI=-1.453152027,LI=1.061405429;function Ru(...t){ne().getBool("IS_TEST")||console.warn(...t)}function rZ(...t){ne().getBool("IS_TEST")||console.log(...t)}function Ci(t,n){if(t.length!==n.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${n.length}.`);const e=new Float32Array(2*t.length);for(let r=0;r<e.length;r+=2)e[r]=t[r/2],e[r+1]=n[r/2];return e}function J2(t){const n=new Float32Array(t.length/2),e=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)n[r/2]=t[r],e[r/2]=t[r+1];return{real:n,imag:e}}function Z2(t){const n=Math.ceil(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let s=0;s<t.length;s+=4)e[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:e,imag:r}}function Q2(t){const n=Math.floor(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let s=2;s<t.length;s+=4)e[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:e,imag:r}}function BI(t,n){return{real:t[2*n],imag:t[2*n+1]}}function eF(t,n,e,r){t[2*r]=n,t[2*r+1]=e}function tF(t,n){const e=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(n?2:-2)*Math.PI*(s/t);e[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:e,imag:r}}function nF(t,n,e){const r=(e?2:-2)*Math.PI*(t/n);return{real:Math.cos(r),imag:Math.sin(r)}}function zI(t,n,e=0){let r=[];if("number"==typeof n)S(t.shape[e]%n==0,()=>"Number of splits must evenly divide the axis."),r=new Array(n).fill(t.shape[e]/n);else{S(n.reduce((i,a)=>(-1===a&&(i+=1),i),0)<=1,()=>"There should be only one negative value in split array.");const o=n.indexOf(-1);if(-1!==o){const i=n.reduce((a,l)=>l>0?a+l:a);n[o]=t.shape[e]-i}S(t.shape[e]===n.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=n}return r}function rF(t,n){let r,e=!1;for(t<=NI?(r=t,e=!0):r=p0(t,Math.floor(Math.sqrt(t)));!e;)r>n||r===t?e=!0:r=p0(t,r+1);return r}function sF(t,n,e){const r=[],s=t.length;for(let o=0;o<s;o++)r.push(o!==n?t[o]:e);return r}function VI(t,n,e,r){const s=n.shape.length,o=t.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(t.shape[d]!==n.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${n.shape[d]}.`);const i=t.shape[e],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(t.shape[d]),l*=t.shape[d];for(let d=r;d<e;d++)a.push(t.shape[d]),u*=t.shape[d];for(let d=r;d<s;d++)a.push(n.shape[d]);for(let d=e+1;d<o;d++)a.push(t.shape[d]),c*=t.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function UI(t){try{return t.map(n=>mu(n))}catch(n){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n}`)}}function oF(t){return t.map(n=>mh(n))}function HI(t,n){const e=[];for(let o=0;o<n.length;o++)n[o]&&e.push(o);const r=xt(t,"int32"),s=xt([e.length,t.length],"int32");for(let o=0;o<e.length;o++){const i=r.indexToLoc(e[o]);s.values.set(i,o*t.length)}return s.toTensor()}const iF={kernelName:gm,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,$h(Ae(e,"float32"),-1))}}},sZ={kernelName:vd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=Wt(Ae(e,"float32")),s=wr(Fe(Oe(1),r));return yn(Le(t,s))}}}},oZ={kernelName:xd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=wr(Fe(Wt(Ae(e,"float32")),1));return Le(t,r)}}}},iZ={kernelName:fu,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=wt(e.shape,r.shape);return{a:()=>{let a=t;const l=Vn(e.shape,s);return l.length>0&&(a=Pe(a,l)),W(a,e.shape)},b:()=>{let a=t;const l=Vn(r.shape,s);return l.length>0&&(a=Pe(a,l)),W(a,r.shape)}}}},aZ={kernelName:ym,saveAllInputs:!0,gradFunc:(t,n)=>{const e={};return n.forEach((r,s)=>{e[s]=()=>t.clone()}),e}},lZ={kernelName:bm,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>St(e)}}},uZ={kernelName:vm,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>St(e)}}},cZ={kernelName:wd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Le(t,wr(Fe(Oe(1),Wt(Ae(e,"float32")))))}}},dZ={kernelName:Cd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=wr(me(Oe(1),Wt(Ae(e,"float32"))));return Le(t,r)}}}},hZ={kernelName:_d,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=wt(e.shape,r.shape);return{a:()=>{const a=me(Wt(e),Wt(r));let l=V(t,Le(r,a));const u=Vn(e.shape,s);return u.length>0&&(l=Pe(l,u)),W(l,e.shape)},b:()=>{const a=me(Wt(e),Wt(r));let l=yn(V(t,Le(e,a)));const u=Vn(r.shape,s);return u.length>0&&(l=Pe(l,u)),W(l,r.shape)}}}},fZ={kernelName:Id,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Le(t,me(Wt(Ae(e,"float32")),1))}}},pZ={kernelName:Dd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Le(t,Fe(Oe(1),Wt(Ae(e,"float32"))))}}},gZ=M({avgPool3dGrad_:function mZ(t,n,e,r,s,o){const i=T(t,"dy","avgPool3dGrad"),a=T(n,"input","avgPool3dGrad");let l=i,u=a,c=!1;4===a.rank&&(c=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=W(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),null!=o&&S(Jn(s),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const f=F.runKernel(x0,{dy:l,input:u},{filterSize:e,strides:r,pad:s,dimRoundingMode:o});return c?W(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),yZ={kernelName:wm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:s,strides:o,pad:i,dimRoundingMode:a}=e;return{x:()=>gZ(t,r,s,o,i,a)}}},vZ=M({avgPoolGrad_:function bZ(t,n,e,r,s){const o=T(t,"dy","avgPoolGrad"),i=T(n,"input","avgPoolGrad");S(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;3===i.rank&&(u=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=F.runKernel(v0,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return u?W(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),xZ={kernelName:xm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:s,strides:o,pad:i}=e;return{x:()=>vZ(t,r,s,o,i)}}},wZ={kernelName:Cm,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{const[r,s]=n,{transposeA:o,transposeB:i}=e;return o||i?!o&&i?{a:()=>At(t,s,!1,!1),b:()=>At(t,r,!0,!1)}:o&&!i?{a:()=>At(s,t,!1,!0),b:()=>At(r,t,!1,!1)}:{a:()=>At(s,t,!0,!0),b:()=>At(t,r,!0,!0)}:{a:()=>At(t,s,!1,!0),b:()=>At(r,t,!0,!1)}}},ny=M({spaceToBatchND_:function CZ(t,n,e){const r=T(t,"x","spaceToBatchND");return S(r.rank>=1+n.length,()=>`input rank ${r.rank} should be > than [blockShape] ${n.length}`),S(e.length===n.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${n.length}`),S(r.shape.reduce((i,a,l)=>l>0&&l<=n.length?i&&(a+e[l-1][0]+e[l-1][1])%n[l-1]==0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${n.toString()}`),F.runKernel(cg,{x:r},{blockShape:n,paddings:e})}}),IZ={kernelName:Im,gradFunc:(t,n,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>ny(t,r,s)}}},DZ={kernelName:"BroadcastTo",gradFunc:(t,n,e)=>{const s=e.inputShape,o=e.shape,i=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>Pe(t,a,!0)}}},_Z={kernelName:Sd,gradFunc:t=>({x:()=>t.clone()})},SZ={kernelName:Ed,gradFunc:t=>({x:()=>St(t)})},EZ={kernelName:Nd,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{clipValueMin:s,clipValueMax:o}=e;return{x:()=>bs(Oo(Ya(r,s),ku(r,o)),t,St(t))}}},NZ={kernelName:Dm,inputsToSave:["x"],gradFunc:iF.gradFunc},TZ={kernelName:_m,saveAllInputs:!0,gradFunc:(t,n,e)=>{const r=n.map(l=>l.shape),{axis:s}=e,o=mt(s,n[0].shape)[0],i=r.map(l=>l[o]);return ys(t,i,o).map(l=>()=>l)}},kZ={kernelName:Sm,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,{dilations:o,strides:i,pad:a,dataFormat:l}=e;return S(Ji(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>WC(r.shape,t,s,i,a,l),filter:()=>iI(r,t,s.shape,i,a,l)}}},AZ={kernelName:Em,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Zi(t,s,o,i,a,1,l),filter:()=>iI(t,r,s.shape,o,i,a,l)}}},$Z=M({conv3DBackpropFilter_:function RZ(t,n,e,r,s){let o=t;4===t.rank&&(o=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=n;return 4===i.rank&&(i=W(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),S(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),S(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),S(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),S(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),S(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`),F.runKernel(D0,{x:o,dy:i},{strides:r,pad:s,filterShape:e})}}),OZ=M({conv3DBackpropInput_:function FZ(t,n,e,r,s){S(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let o=t,i=n,a=!1;4===n.rank&&(a=!0,i=W(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],u=i.shape[4];S(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),S(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),S(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),S(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),S(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=F.runKernel(_0,{dy:i,filter:e},{pad:s,strides:r,inputShape:o});return a?W(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),MZ={kernelName:Nm,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:s,pad:o}=e;S(Ji(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,a]=n;return{x:()=>OZ(i.shape,t,a,s,o),filter:()=>$Z(i,t,a.shape,s,o)}}},WI=M({sin_:function PZ(t){const e={x:T(t,"x","sin")};return F.runKernel(nh,e)}}),LZ={kernelName:Td,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(yn(WI(Ae(e,"float32"))),t)}}},jI=M({sinh_:function BZ(t){const e={x:T(t,"x","sinh")};return F.runKernel(rh,e)}}),zZ={kernelName:kd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(jI(Ae(e,"float32")),t)}}},GI=M({cumsum_:function VZ(t,n=0,e=!1,r=!1){const o={x:T(t,"x","cumsum")};return F.runKernel(Tm,o,{axis:n,exclusive:e,reverse:r})}}),UZ={kernelName:Tm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s,exclusive:o,reverse:i}=e;return{x:()=>{const a=wn([s],r.rank);let l=GI(t,s,o,!i);return null!=a&&(l=Ht(l,a)),l}}}},HZ={kernelName:km,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:s,pad:o,dimRoundingMode:i}=e,a=r??[1,1];S(Ji(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=n;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),S(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),S(cr(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),null!=i&&S(Jn(o),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`),{x:()=>B2(l.shape,t,u,s,o,r,i),filter:()=>L2(l,t,u.shape,s,o,r,i)}}},WZ={kernelName:Am,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,o={x:r,filter:s,dy:t},i={x:r,filter:s,dy:t};return{x:()=>F.runKernel(A0,o,e),filter:()=>F.runKernel(R0,i,e)}}},jZ={kernelName:Rd,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n,r={dy:t,y:e};return{x:()=>F.runKernel($0,r)}}},GZ={kernelName:$d,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=V(Ms(yn(Wt(e))),2/Math.sqrt(Math.PI));return{x:()=>V(t,r)}}},qZ={kernelName:Fd,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,e)}}},KZ={kernelName:$m,inputsToSave:["input"],gradFunc:(t,n)=>{const[e]=n;return{input:()=>W(t,e.shape)}}},XZ={kernelName:Od,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,Ms(e))}}},YZ={kernelName:Md,gradFunc:t=>({x:()=>St(t)})},JZ={kernelName:Pd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=wt(e.shape,r.shape);return{a:()=>{const a=Le(t,Ae(r,"float32")),l=Vn(e.shape,s);return l.length>0?W(Pe(a,l),e.shape):a},b:()=>{let a=V(t,Ae(e,"float32"));const l=Vn(r.shape,s);l.length>0&&(a=W(Pe(a,l),r.shape));const u=Wt(r);return yn(Le(a,Ae(u,"float32")))}}}},qI=M({rsqrt_:function ZZ(t){const e={x:T(t,"x","rsqrt")};return F.runKernel(eh,e)}}),QZ={kernelName:Fm,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{const{varianceEpsilon:r}=e,[s,o,i,a]=n,l=a??Oe(1),u=Vn(o.shape,s.shape),c=[];if(1===o.rank){for(let x=0;x<s.shape.length-1;++x)c.push(s.shape[x]);c.push(1)}const d=Fe(s,o),h=V(t,l),f=qI(me(i,Oe(r))),p=V(V(V(f,f),f),Oe(-.5));return{x:()=>W(V(V(t,1===o.rank?Xa(W(f,[1,1,1,o.shape[0]]),c):f),l),s.shape),mean:()=>{let x=V(V(f,Oe(-1)),h);return 1===o.rank&&(x=Pe(x,u)),W(x,o.shape)},variance:()=>{let x=V(V(p,d),h);return 1===o.rank&&(x=Pe(x,u)),W(x,o.shape)},scale:()=>{const x=V(d,f);let w=V(t,x);return 1===o.rank&&(w=Pe(w,u)),W(w,o.shape)},offset:()=>{let x=t;return 1===o.rank&&(x=Pe(x,u)),W(x,o.shape)}}}},aF=M({unsortedSegmentSum_:function eQ(t,n,e){const r=T(t,"x","unsortedSegmentSum"),s=T(n,"segmentIds","unsortedSegmentSum","int32");return S(Jn(e),()=>"numSegments must be of dtype int"),F.runKernel(mg,{x:r,segmentIds:s},{numSegments:e})}}),tQ={kernelName:Om,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{const[r,s]=n,{axis:o}=e,i=mt(o,r.shape)[0];return{x:()=>{const l=r.shape,u=s.size,c=l.slice(0,i),d=c.length,h=l.slice(o,l.length).slice(1),f=h.length,p=lF(0,d),m=lF(d+1,d+1+f),g=uF([c,[u],h]),y=W(t,g),b=W(s,[u]),v=uF([[d],p,m]),x=Ht(y,v);let w=aF(x,b,r.shape[i]);const _=_u(v);return w=Ht(w,_),w},indices:()=>s}}};function lF(t,n){const e=[];for(let r=t;r<n;++r)e.push(r);return e}function uF(t){const n=[];for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r)n.push(t[e][r]);return n}const nQ={kernelName:Ld,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>St(e),b:()=>St(r)}}},rQ={kernelName:Bd,gradFunc:t=>({x:()=>Ae(t,"float32")})},sQ={kernelName:zd,gradFunc:t=>({x:()=>St(t)})},oQ={kernelName:Vd,gradFunc:t=>({x:()=>St(t)})},iQ={kernelName:Ud,gradFunc:t=>({x:()=>St(t)})},aQ={kernelName:Pm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{alpha:s}=e,o=Fo(r,0);return{x:()=>bs(o,t,V(t,s))}}},lQ={kernelName:Wd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Le(t,me(e,1))}}},uQ={kernelName:Hd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Le(t,Ae(e,"float32"))}}},cQ={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e;return{logits:()=>{const i=Ms(r);return Fe(t,V(Pe(t,s,!0),i))}}}},hQ=M({localResponseNormalizationBackprop_:function dQ(t,n,e,r=5,s=1,o=1,i=.5){return F.runKernel(V0,{x:t,y:n,dy:e},{depthRadius:r,bias:s,alpha:o,beta:i})}}),fQ={kernelName:Hm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{depthRadius:o,bias:i,alpha:a,beta:l}=e;return{x:()=>hQ(r,s,t,o,i,a,l)}}};function cF(t,n,e,r){return n.rank<e.rank&&(n=W(n,xn(n.shape,r))),t.rank<e.rank&&(t=W(t,xn(t.shape,r))),{x:()=>V(t,Ae(Ka(e,n),t.dtype))}}const dF={kernelName:Wm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{reductionIndices:s}=r,o=n[0],l=cF(t,n[1],o,mt(s,o.shape));return{x:()=>l.x()}}},KI=M({less_:function pQ(t,n){let e=T(t,"a","less"),r=T(n,"b","less");return[e,r]=mn(e,r),wt(e.shape,r.shape),F.runKernel(Lm,{a:e,b:r})}}),mQ={kernelName:jd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>V(t,Ae(Ya(e,r),"float32")),b:()=>V(t,Ae(KI(e,r),"float32"))}}},yQ=M({maxPool3dGrad_:function gQ(t,n,e,r,s,o,i){const a=T(t,"dy","maxPool3dGrad"),l=T(n,"input","maxPool3dGrad"),u=T(e,"output","maxPool3dGrad");let c=a,d=l,h=u,f=!1;4===l.rank&&(f=!0,c=W(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=W(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=W(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),S(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),S(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),null!=i&&S(Jn(o),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`);const g=F.runKernel(H0,{dy:c,input:d,output:h},{filterSize:r,strides:s,pad:o,dimRoundingMode:i});return f?W(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),bQ={kernelName:Gm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>yQ(t,r,s,o,i,a,l)}}},xQ=M({maxPoolGrad_:function vQ(t,n,e,r,s,o,i){const a=T(t,"dy","maxPoolGrad"),l=T(n,"input","maxPoolGrad"),u=T(e,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),null!=i&&S(Jn(o),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`),F.runKernel(U0,{dy:a,input:l,output:u},{filterSize:r,strides:s,pad:o,dimRoundingMode:i})}}),wQ={kernelName:jm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a}=e;return{x:()=>xQ(t,r,s,o,i,a)}}},CQ={kernelName:qm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e,o=mt(s,r.shape),l=te(tr(r.shape,o)[1]);return{x:()=>{const c=r.shape.slice();o.forEach(f=>{c[f]=1});const d=W(t,c);return Le(V(d,yi(r.shape,"float32")),l)}}}},IQ={kernelName:Km,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{axis:s}=r,[o,i]=n,l=cF(t,i,o,mt(s,o.shape));return{x:()=>l.x()}}},DQ={kernelName:Gd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>V(t,Ae(ku(e,r),"float32")),b:()=>V(t,Ae(Fo(e,r),"float32"))}}},_Q={kernelName:Xm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>Ot(t,o,r.shape)}}},SQ={kernelName:qd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=wt(e.shape,r.shape);return{a:()=>{const a=Vn(e.shape,s);return a.length>0?W(Pe(t,a),e.shape):t},b:()=>{const a=V(t,yn(_h(Le(e,r)))),l=Vn(r.shape,s);return l.length>0?W(Pe(a,l),r.shape):a}}}},EQ={kernelName:Kd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=wt(e.shape,r.shape);return{a:()=>{const a=V(t,Ae(r,"float32")),l=Vn(e.shape,s);return l.length>0?W(Pe(a,l),e.shape):a},b:()=>{const a=V(t,Ae(e,"float32")),l=Vn(r.shape,s);return l.length>0?W(Pe(a,l),r.shape):a}}}},NQ={kernelName:Ym,gradFunc:t=>({x:()=>yn(t)})},TQ={kernelName:Qm,inputsToSave:["indices"],gradFunc:(t,n)=>{const e=n[0];return{indices:()=>An(e.shape,"float32")}}},kQ={kernelName:Zm,gradFunc:t=>({x:()=>St(t)})},AQ={kernelName:eg,saveAllInputs:!0,gradFunc:(t,n,e)=>{const{axis:r}=e;return fo(t,r).map(o=>()=>o)}},hF={kernelName:tg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>Ot(t,o,r.shape)}}},RQ={kernelName:Xd,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,n)=>{const[e,r,s]=n,o=e,i=r,a=wt(o.shape,i.shape);return{a:()=>{const c=Ae(i,"float32");let d=V(t,V(c,Ja(o,Fe(c,Oe(1)))));const h=Vn(o.shape,a);return h.length>0&&(d=Pe(d,h)),W(d,o.shape)},b:()=>{const c=Fo(o,0),d=bs(c,ms(o),St(o));let h=V(t,V(s,d));const f=Vn(i.shape,a);return f.length>0&&(h=Pe(h,f)),W(h,i.shape)}}}},$Q={kernelName:ng,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{const[e,r]=n,s=Fo(e,0);return{x:()=>bs(s,t,V(t,r)),alpha:()=>{let o=bs(s,St(t),V(t,e));const i=Vn(r.shape,t.shape);return i.length>0&&(o=Pe(o,i)),W(o,r.shape)}}}},FQ={kernelName:Ad,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=wt(e.shape,r.shape);return{a:()=>{const a=Le(t,Ae(r,"float32")),l=Vn(e.shape,s);return l.length>0?W(Pe(a,l),e.shape):a},b:()=>{let a=V(t,Ae(e,"float32"));const l=Vn(r.shape,s);l.length>0&&(a=W(Pe(a,l),r.shape));const u=Wt(r);return yn(Le(a,Ae(u,"float32")))}}}},OQ={kernelName:Yd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Le(t,yn(Wt(e)))}}},MQ={kernelName:Zd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=V(ku(e,6),$h(e));return{x:()=>V(t,Ae(r,"float32"))}}},PQ={kernelName:Jd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,Ae($h(e),"float32"))}}},LQ={kernelName:rg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>W(t,e.shape)}}},BQ={kernelName:og,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,s={dy:t,images:r};return{images:()=>F.runKernel(Q0,s,e)}}},zQ={kernelName:sg,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,s={dy:t,images:r};return{images:()=>F.runKernel(Z0,s,e)}}},VQ={kernelName:ig,gradFunc:(t,n,e)=>{const{dims:r}=e,s=mt(r,t.shape);return{x:()=>vi(t,s)}}},UQ={kernelName:Qd,gradFunc:t=>({x:()=>St(t)})},HQ={kernelName:eh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>yn(Le(t,V(Ja(e,1.5),2)))}}},ry=M({logicalNot_:function WQ(t){const e={x:T(t,"x","logicalNot","bool")};return F.runKernel(Vm,e)}}),jQ={kernelName:ag,inputsToSave:["condition"],gradFunc:(t,n)=>{const[e]=n;return{condition:()=>Ae(St(e),"float32"),t:()=>V(t,Ae(e,t.dtype)),e:()=>V(t,Ae(ry(e),t.dtype))}}},GQ={kernelName:th,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=Fo(e,Oe(0)),s=Oe(ey),o=Oe(ty),i=V(t,o),a=V(V(t,s),Ms(Ae(e,"float32")));return bs(r,i,a)}}}},qQ={kernelName:oh,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,V(e,Fe(Oe(1),e)))}}},KQ={kernelName:sh,gradFunc:t=>({x:()=>St(t)})},sy=M({cos_:function XQ(t){const e={x:T(t,"x","cos")};return F.runKernel(Td,e)}}),YQ={kernelName:nh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(sy(Ae(e,"float32")),t)}}},XI=M({cosh_:function JQ(t){const e={x:T(t,"x","cosh")};return F.runKernel(kd,e)}}),ZQ={kernelName:rh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(XI(Ae(e,"float32")),t)}}},QQ={kernelName:lg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{begin:s,size:o}=e,i=r.shape,[a,l]=Ag(r,s,o),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>zg(t,u)}}},eee={kernelName:hg,outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{dim:s}=e,i=V(t,r);return{logits:()=>Fe(i,V(Pe(i,[s],!0),r))}}},tee={kernelName:ih,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,Eu(e))}}},oy=M({batchToSpaceND_:function nee(t,n,e){const r=T(t,"x","batchToSpaceND"),s=n.reduce((a,l)=>a*l);return S(r.rank>=1+n.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${n.length}`),S(e.length===n.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${n.length}`),S(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${s}`),F.runKernel(Im,{x:r},{blockShape:n,crops:e})}}),fF={kernelName:cg,gradFunc:(t,n,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>oy(t,r,s)}}},pF={kernelName:dg,gradFunc:(t,n,e)=>{const{axis:r}=e;return{x:()=>Tn(t,r)}}},yee=[iF,sZ,oZ,iZ,aZ,lZ,uZ,cZ,dZ,hZ,fZ,pZ,yZ,xZ,wZ,IZ,DZ,_Z,SZ,EZ,NZ,TZ,AZ,kZ,MZ,LZ,zZ,UZ,HZ,WZ,FQ,jZ,GZ,qZ,KZ,XZ,JZ,YZ,QZ,tQ,nQ,rQ,sQ,oQ,iQ,aQ,lQ,uQ,cQ,fQ,dF,dF,mQ,bQ,wQ,CQ,IQ,DQ,_Q,SQ,EQ,NQ,TQ,kQ,AQ,hF,hF,RQ,$Q,OQ,MQ,PQ,LQ,BQ,zQ,VQ,UQ,HQ,jQ,GQ,qQ,KQ,YQ,ZQ,QQ,eee,tee,fF,fF,pF,pF,{kernelName:ah,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Le(t,V(wr(Ae(e,"float32")),2))}}},{kernelName:lh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Oe(2);return{a:()=>V(t,V(s,Fe(e,r))),b:()=>V(t,V(s,Fe(r,e)))}}},{kernelName:tC,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,V(Ae(e,"float32"),2))}}},{kernelName:fh,gradFunc:t=>({x:()=>St(t)})},{kernelName:uh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=wt(e.shape,r.shape);return{a:()=>{let a=t;const l=Vn(e.shape,s);return l.length>0&&(a=Pe(a,l)),W(a,e.shape)},b:()=>{let a=t;const l=Vn(r.shape,s);return l.length>0&&(a=Pe(a,l)),W(yn(a),r.shape)}}}},{kernelName:ug,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,s=r.shape.slice(),{axis:o}=e;mt(o,r.shape).forEach(u=>{s[u]=1});const a=W(t,s),l=V(a,yi(r.shape,"float32"));return{x:()=>l}}},{kernelName:ch,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Le(t,Wt(sy(e)))}}},{kernelName:dh,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(Fe(Oe(1),Wt(e)),t)}}},{kernelName:hh,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{reps:s}=e;return{x:()=>{let i=St(r);if(1===r.rank)for(let a=0;a<s[0];++a)i=me(i,Ot(t,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)i=me(i,Ot(t,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=me(i,Ot(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=me(i,Ot(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return i}}}},{kernelName:fg,gradFunc:(t,n,e)=>{const r=e,{perm:s}=r,o=_u(s);return{x:()=>Ht(t,o)}}},{kernelName:pg,gradFunc:(t,n,e)=>{const r=e,{axis:s}=r;return{value:()=>Ls(t,s)}}},{kernelName:mg,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>function mee(t,n){const e=gi(n,St(n)),r=Sh(t,e);let s=Ya(n,Oe(0,"int32"));const o=r.rank-s.rank;for(let a=0;a<o;++a)s=Os(s,a+1);s=Oo(s,yi(r.shape,"bool"));const i=St(r);return bs(s,r,i)}(t,e)}}},{kernelName:gg,gradFunc:t=>({x:()=>St(t)})}];for(const t of yee)vX(t);J().prototype.abs=function(){return this.throwIfDisposed(),Qn(this)};const mF=M({acos_:function bee(t){const e={x:T(t,"x","acos")};return F.runKernel(vd,e)}});J().prototype.acos=function(){return this.throwIfDisposed(),mF(this)};const gF=M({acosh_:function vee(t){const e={x:T(t,"x","acosh")};return F.runKernel(xd,e)}});J().prototype.acosh=function(){return this.throwIfDisposed(),gF(this)},J().prototype.add=function(t){return this.throwIfDisposed(),me(this,t)},J().prototype.all=function(t,n){return this.throwIfDisposed(),zC(this,t,n)},J().prototype.any=function(t,n){return this.throwIfDisposed(),$g(this,t,n)},J().prototype.argMax=function(t){return this.throwIfDisposed(),Fg(this,t)};const yF=M({argMin_:function xee(t,n=0){const r={x:T(t,"x","argMin")};return F.runKernel(vm,r,{axis:n})}});J().prototype.argMin=function(t){return this.throwIfDisposed(),yF(this,t)},J().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),W(this,[])},J().prototype.asType=function(t){return this.throwIfDisposed(),Ae(this,t)},J().prototype.as1D=function(){return this.throwIfDisposed(),W(this,[this.size])},J().prototype.as2D=function(t,n){return this.throwIfDisposed(),W(this,[t,n])},J().prototype.as3D=function(t,n,e){return this.throwIfDisposed(),W(this,[t,n,e])},J().prototype.as4D=function(t,n,e,r){return this.throwIfDisposed(),W(this,[t,n,e,r])},J().prototype.as5D=function(t,n,e,r,s){return this.throwIfDisposed(),W(this,[t,n,e,r,s])};const bF=M({asin_:function wee(t){const e={x:T(t,"x","asin")};return F.runKernel(wd,e)}});J().prototype.asin=function(){return this.throwIfDisposed(),bF(this)};const vF=M({asinh_:function Cee(t){const e={x:T(t,"x","asinh")};return F.runKernel(Cd,e)}});J().prototype.asinh=function(){return this.throwIfDisposed(),vF(this)};const xF=M({atan_:function Iee(t){const e={x:T(t,"x","atan")};return F.runKernel(Id,e)}});J().prototype.atan=function(){return this.throwIfDisposed(),xF(this)};const wF=M({atan2_:function Dee(t,n){let e=T(t,"a","atan2"),r=T(n,"b","atan2");return[e,r]=mn(e,r),F.runKernel(_d,{a:e,b:r})}});J().prototype.atan2=function(t){return this.throwIfDisposed(),wF(this,t)};const CF=M({atanh_:function _ee(t){const e={x:T(t,"x","atanh")};return F.runKernel(Dd,e)}});J().prototype.atanh=function(){return this.throwIfDisposed(),CF(this)},J().prototype.avgPool=function(t,n,e,r){return this.throwIfDisposed(),Mg(this,t,n,e,r)},J().prototype.batchToSpaceND=function(t,n){return this.throwIfDisposed(),oy(this,t,n)},J().prototype.batchNorm=function(t,n,e,r,s){return this.throwIfDisposed(),Du(this,t,n,e,r,s)},J().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Wg(this,t)},J().prototype.cast=function(t){return this.throwIfDisposed(),Ae(this,t)};const IF=M({ceil_:function See(t){const e={x:T(t,"x","ceil")};return F.runKernel(Ed,e)}});J().prototype.ceil=function(){return this.throwIfDisposed(),IF(this)},J().prototype.clipByValue=function(t,n){return this.throwIfDisposed(),Jr(this,t,n)},J().prototype.concat=function(t,n){return this.throwIfDisposed(),t instanceof un&&(t=[t]),Tn([this,...t],n)},J().prototype.conv1d=function(t,n,e,r,s,o){return this.throwIfDisposed(),HC(this,t,n,e,r,s,o)},J().prototype.conv2dTranspose=function(t,n,e,r,s){return this.throwIfDisposed(),jC(this,t,n,e,r,s)},J().prototype.conv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),Zi(this,t,n,e,r,s,o)},J().prototype.cos=function(){return this.throwIfDisposed(),sy(this)},J().prototype.cosh=function(){return this.throwIfDisposed(),XI(this)},J().prototype.cumsum=function(t,n,e){return this.throwIfDisposed(),GI(this,t,n,e)};const DF=M({depthToSpace_:function Eee(t,n,e="NHWC"){const r=T(t,"x","depthToSpace"),s="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],i="NHWC"===e?r.shape[3]:r.shape[1];return S(s*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${n}  for depthToSpace with input shape\n    ${r.shape}`),S(o*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${n} for depthToSpace with input shape\n        ${r.shape}`),S(i%(n*n)==0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${r.shape}`),F.runKernel(N0,{x:r},{blockSize:n,dataFormat:e})}});J().prototype.depthToSpace=function(t,n){return this.throwIfDisposed(),DF(this,t,n)},J().prototype.depthwiseConv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),Ch(this,t,n,e,r,s,o)};const _F=M({dilation2d_:function Nee(t,n,e,r,s=[1,1],o="NHWC"){const i=T(t,"x","dilation2d"),a=T(n,"filter","dilation2d");S(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;3===i.rank&&(l=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0);const h=F.runKernel(Am,{x:l,filter:a},{strides:e,pad:r,dilations:s});return u?W(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});J().prototype.dilation2d=function(t,n,e,r,s){return this.throwIfDisposed(),_F(this,t,n,e,r,s)};const SF=M({divNoNan_:function Tee(t,n){let e=T(t,"a","div"),r=T(n,"b","div");[e,r]=mn(e,r);const s=Le(e,r),o=St(s),i=Ka(r,o);return bs(i,o,s)}});J().prototype.divNoNan=function(t){return this.throwIfDisposed(),SF(this,t)},J().prototype.div=function(t){return this.throwIfDisposed(),Le(this,t)};const Aee=M({dot_:function kee(t,n){const e=T(t,"t1","dot"),r=T(n,"t2","dot");S(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(S(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===e.rank&&1===r.rank){const i=W(e,[1,-1]),a=W(r,[-1,1]),l=At(i,a);return W(l,[])}if(1===e.rank&&2===r.rank){const i=W(e,[1,-1]),a=W(r,[r.shape[0],r.shape[1]]),l=At(i,a);return W(l,[l.size])}if(2===e.rank&&1===r.rank){const i=W(r,[-1,1]),a=At(e,i);return W(a,[a.size])}{const i=W(r,[r.shape[0],r.shape[1]]);return At(e,i)}}});J().prototype.dot=function(t){return this.throwIfDisposed(),Aee(this,t)},J().prototype.elu=function(){return this.throwIfDisposed(),Ih(this)},J().prototype.equal=function(t){return this.throwIfDisposed(),Ka(this,t)};const EF=M({erf_:function Ree(t){let n=T(t,"x","erf");return S("int32"===n.dtype||"float32"===n.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===n.dtype&&(n=Ae(n,"float32")),F.runKernel($d,{x:n})}});J().prototype.erf=function(){return this.throwIfDisposed(),EF(this)},J().prototype.exp=function(){return this.throwIfDisposed(),Ms(this)},J().prototype.expandDims=function(t){return this.throwIfDisposed(),Os(this,t)};const NF=M({expm1_:function $ee(t){const e={x:T(t,"x","expm1")};return F.runKernel(Od,e)}});J().prototype.expm1=function(){return this.throwIfDisposed(),NF(this)},J().prototype.fft=function(){return this.throwIfDisposed(),Gg(this)},J().prototype.flatten=function(){return this.throwIfDisposed(),W(this,[this.size])},J().prototype.floor=function(){return this.throwIfDisposed(),_h(this)},J().prototype.floorDiv=function(t){return this.throwIfDisposed(),GC(this,t)},J().prototype.gather=function(t,n){return this.throwIfDisposed(),Sh(this,t,n)},J().prototype.greaterEqual=function(t){return this.throwIfDisposed(),Ya(this,t)},J().prototype.greater=function(t){return this.throwIfDisposed(),Fo(this,t)},J().prototype.ifft=function(){return this.throwIfDisposed(),Rh(this)},J().prototype.irfft=function(){return this.throwIfDisposed(),oI(this)};const Oee=M({isFinite_:function Fee(t){const e={x:T(t,"x","isFinite")};return F.runKernel(zd,e)}});J().prototype.isFinite=function(){return this.throwIfDisposed(),Oee(this)};const Pee=M({isInf_:function Mee(t){const e={x:T(t,"x","isInf")};return F.runKernel(Vd,e)}});J().prototype.isInf=function(){return this.throwIfDisposed(),Pee(this)};const Bee=M({isNaN_:function Lee(t){const e={x:T(t,"x","isNaN")};return F.runKernel(Ud,e)}});J().prototype.isNaN=function(){return this.throwIfDisposed(),Bee(this)},J().prototype.leakyRelu=function(t){return this.throwIfDisposed(),Lg(this,t)},J().prototype.lessEqual=function(t){return this.throwIfDisposed(),ku(this,t)},J().prototype.less=function(t){return this.throwIfDisposed(),KI(this,t)};const TF=M({localResponseNormalization_:function zee(t,n=5,e=1,r=1,s=.5){const o=T(t,"x","localResponseNormalization");S(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),S(Jn(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c=F.runKernel(Hm,{x:i},{depthRadius:n,bias:e,alpha:r,beta:s});return a?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});J().prototype.localResponseNormalization=function(t,n,e,r){return this.throwIfDisposed(),TF(this,t,n,e,r)};const Uee=M({logSigmoid_:function Vee(t){const n=T(t,"x","logSigmoid");return fi(r=>({value:yn(kh(yn(r))),gradFunc:i=>V(i,Eu(yn(r)))}))(n)}});J().prototype.logSigmoid=function(){return this.throwIfDisposed(),Uee(this)},J().prototype.logSoftmax=function(t){return this.throwIfDisposed(),qC(this,t)},J().prototype.logSumExp=function(t,n){return this.throwIfDisposed(),K2(this,t,n)},J().prototype.log=function(){return this.throwIfDisposed(),ms(this)},J().prototype.log1p=function(){return this.throwIfDisposed(),vI(this)},J().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Oo(this,t)},J().prototype.logicalNot=function(){return this.throwIfDisposed(),ry(this)};const YI=M({logicalOr_:function Hee(t,n){const e=T(t,"a","logicalOr","bool"),r=T(n,"b","logicalOr","bool");return wt(e.shape,r.shape),F.runKernel(Um,{a:e,b:r})}});J().prototype.logicalOr=function(t){return this.throwIfDisposed(),YI(this,t)};const jee=M({logicalXor_:function Wee(t,n){const e=T(t,"a","logicalXor","bool"),r=T(n,"b","logicalXor","bool");return wt(e.shape,r.shape),Oo(YI(t,n),ry(Oo(t,n)))}});J().prototype.logicalXor=function(t){return this.throwIfDisposed(),jee(this,t)},J().prototype.matMul=function(t,n,e){return this.throwIfDisposed(),At(this,t,n,e)},J().prototype.maxPool=function(t,n,e,r){return this.throwIfDisposed(),Bg(this,t,n,e,r)},J().prototype.max=function(t,n){return this.throwIfDisposed(),Ps(this,t,n)},J().prototype.maximum=function(t){return this.throwIfDisposed(),gi(this,t)},J().prototype.mean=function(t,n){return this.throwIfDisposed(),gn(this,t,n)},J().prototype.min=function(t,n){return this.throwIfDisposed(),Eh(this,t,n)},J().prototype.minimum=function(t){return this.throwIfDisposed(),Nh(this,t)};const kF=M({mirrorPad_:function Gee(t,n,e){S("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=T(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(n.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${n.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)S(2===n[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(n[a][0]>=0&&n[a][0]<=r.shape[a]-s&&n[a][1]>=0&&n[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return F.runKernel(Xm,{x:r},{paddings:n,mode:e})}});J().prototype.mirrorPad=function(t,n){return this.throwIfDisposed(),kF(this,t,n)};const AF=M({mod_:function qee(t,n){let e=T(t,"a","mod"),r=T(n,"b","mod");return[e,r]=mn(e,r),F.runKernel(qd,{a:e,b:r})}});J().prototype.mod=function(t){return this.throwIfDisposed(),AF(this,t)},J().prototype.mul=function(t){return this.throwIfDisposed(),V(this,t)},J().prototype.neg=function(){return this.throwIfDisposed(),yn(this)},J().prototype.norm=function(t,n,e){return this.throwIfDisposed(),yI(this,t,n,e)},J().prototype.notEqual=function(t){return this.throwIfDisposed(),Su(this,t)},J().prototype.oneHot=function(t,n=1,e=0){return this.throwIfDisposed(),YC(this,t,n,e)},J().prototype.onesLike=function(){return this.throwIfDisposed(),gs(this)},J().prototype.pad=function(t,n){return this.throwIfDisposed(),zg(this,t,n)};const Jee=M({pool_:function Kee(t,n,e,r,s,o){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const i=T(t,"x","maxPool");let a=i,l=!1;3===i.rank&&(l=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(cr(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const u=Fs(a.shape,n,o,s,r),c=[u.dilationHeight,u.dilationWidth];let d;d="same"===r?function Yee(t,n){const r=t.map((i,a)=>i+(i-1)*(n[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const h=1===c[0]&&1===c[1],[f,p]=function Xee(t,n,e){const r=e.map(c=>c[0]),s=e.map(c=>c[1]),o=t.concat(r,s),i=n.map((c,d)=>(c-o[d]%c)%c),a=s.map((c,d)=>c+i[d]),l=n.map((c,d)=>[r[d],a[d]]),u=n.map((c,d)=>[0,i[d]]);return[l,u]}([u.inHeight,u.inWidth],c,d),m=h?r:"valid",g=h?a:ny(a,c,f),b=("avg"===e?()=>Mg(g,n,o,m):()=>Bg(g,n,o,m))(),v=h?b:oy(b,c,p);return l?W(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});J().prototype.pool=function(t,n,e,r,s){return this.throwIfDisposed(),Jee(this,t,n,e,r,s)},J().prototype.pow=function(t){return this.throwIfDisposed(),Ja(this,t)},J().prototype.prelu=function(t){return this.throwIfDisposed(),Vg(this,t)};const JI=M({prod_:function Zee(t,n=null,e=!1){let r=T(t,"x","prod");return"bool"===r.dtype&&(r=Ae(r,"int32")),F.runKernel(X0,{x:r},{axis:n,keepDims:e})}});J().prototype.prod=function(t,n){return this.throwIfDisposed(),JI(this,t,n)};const RF=M({reciprocal_:function Qee(t){const e={x:T(t,"x","reciprocal")};return F.runKernel(Yd,e)}});J().prototype.reciprocal=function(){return this.throwIfDisposed(),RF(this)},J().prototype.relu=function(){return this.throwIfDisposed(),bi(this)},J().prototype.relu6=function(){return this.throwIfDisposed(),aI(this)},J().prototype.reshapeAs=function(t){return this.throwIfDisposed(),W(this,t.shape)},J().prototype.reshape=function(t){return this.throwIfDisposed(),W(this,t)},J().prototype.resizeBilinear=function(t,n,e){return this.throwIfDisposed(),W2(this,t,n,e)},J().prototype.resizeNearestNeighbor=function(t,n,e){return this.throwIfDisposed(),j2(this,t,n,e)},J().prototype.reverse=function(t){return this.throwIfDisposed(),vi(this,t)},J().prototype.rfft=function(){return this.throwIfDisposed(),qg(this)};const $F=M({round_:function ete(t){const e={x:T(t,"x","round")};return F.runKernel(Qd,e)}});J().prototype.round=function(){return this.throwIfDisposed(),$F(this)},J().prototype.rsqrt=function(){return this.throwIfDisposed(),qI(this)},J().prototype.selu=function(){return this.throwIfDisposed(),QC(this)},J().prototype.separableConv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),O2(this,t,n,e,r,s,o)},J().prototype.sigmoid=function(){return this.throwIfDisposed(),Eu(this)};const FF=M({sign_:function tte(t){const e={x:T(t,"x","sign")};return F.runKernel(sh,e)}});J().prototype.sign=function(){return this.throwIfDisposed(),FF(this)},J().prototype.sin=function(){return this.throwIfDisposed(),WI(this)},J().prototype.sinh=function(){return this.throwIfDisposed(),jI(this)},J().prototype.slice=function(t,n){return this.throwIfDisposed(),Ot(this,t,n)},J().prototype.softmax=function(t){return this.throwIfDisposed(),Hg(this,t)},J().prototype.softplus=function(){return this.throwIfDisposed(),kh(this)},J().prototype.spaceToBatchND=function(t,n){return this.throwIfDisposed(),ny(this,t,n)},J().prototype.split=function(t,n){return this.throwIfDisposed(),ys(this,t,n)},J().prototype.sqrt=function(){return this.throwIfDisposed(),wr(this)},J().prototype.square=function(){return this.throwIfDisposed(),Wt(this)},J().prototype.squaredDifference=function(t){return this.throwIfDisposed(),bI(this,t)},J().prototype.squeeze=function(t){return this.throwIfDisposed(),Nu(this,t)},J().prototype.stack=function(t,n){this.throwIfDisposed();const e=t instanceof un?[this,t]:[this,...t];return Ls(e,n)},J().prototype.step=function(t){return this.throwIfDisposed(),$h(this,t)};const OF=M({stridedSlice_:function nte(t,n,e,r,s=0,o=0,i=0,a=0,l=0){const c={x:T(t,"x","stridedSlice")};return F.runKernel(rC,c,{begin:n,end:e,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l})}});J().prototype.stridedSlice=function(t,n,e,r,s,o,i,a){return this.throwIfDisposed(),OF(this,t,n,e,r,s,o,i,a)},J().prototype.sub=function(t){return this.throwIfDisposed(),Fe(this,t)},J().prototype.sum=function(t,n){return this.throwIfDisposed(),Pe(this,t,n)};const MF=M({tan_:function rte(t){const e={x:T(t,"x","tan")};return F.runKernel(ch,e)}});J().prototype.tan=function(){return this.throwIfDisposed(),MF(this)},J().prototype.tanh=function(){return this.throwIfDisposed(),nI(this)},J().prototype.tile=function(t){return this.throwIfDisposed(),Xa(this,t)},J().prototype.toBool=function(){return this.throwIfDisposed(),Ae(this,"bool")},J().prototype.toFloat=function(){return this.throwIfDisposed(),Ae(this,"float32")},J().prototype.toInt=function(){return this.throwIfDisposed(),Ae(this,"int32")};const PF=M({topk_:function ste(t,n=1,e=!0){const r=T(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(n>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${n}`);const o={x:r},i={k:n,sorted:e},[a,l]=F.runKernel(sC,o,i);return{values:a,indices:l}}});J().prototype.topk=function(t,n){return this.throwIfDisposed(),PF(this,t,n)},J().prototype.transpose=function(t){return this.throwIfDisposed(),Ht(this,t)};const ZI=M({unique_:function ote(t,n=0){const e=T(t,"x","unique","string_or_numeric");S(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:n},[o,i]=F.runKernel(iC,r,s);return{values:o,indices:i}}});let iy;function Un(){return null==iy&&(iy=function T7(){return F.backend}().epsilon()),iy}J().prototype.unique=function(t){return this.throwIfDisposed(),ZI(this,t)},J().prototype.unsortedSegmentSum=function(t,n){return this.throwIfDisposed(),aF(this,t,n)},J().prototype.unstack=function(t){return this.throwIfDisposed(),fo(this,t)},J().prototype.where=function(t,n){return this.throwIfDisposed(),bs(t,this,n)},J().prototype.zerosLike=function(){return this.throwIfDisposed(),St(this)};class Mo extends Error{constructor(n){super(n),Object.setPrototypeOf(this,Mo.prototype)}}class zs extends Error{constructor(n){super(n),Object.setPrototypeOf(this,zs.prototype)}}class L extends Error{constructor(n){super(n),Object.setPrototypeOf(this,L.prototype)}}class rt extends Error{constructor(n){super(n),Object.setPrototypeOf(this,rt.prototype)}}class QI extends Error{constructor(n){super(n),Object.setPrototypeOf(this,QI.prototype)}}class LF extends Error{constructor(n){super(n),Object.setPrototypeOf(this,LF.prototype)}}function el(t,n){if(Array.isArray(t)){let e=[];for(let r=0;r<n;r++)e=e.concat(t);return e}{const e=new Array(n);return e.fill(t),e}}function vs(t,n){if(!t)throw new QI(n)}function BF(t,n){let e=0;for(const r of t)r===n&&e++;return e}function Hr(t){return 1===t.length?t[0]:t}function Yt(t){return Array.isArray(t)?t:[t]}function Ii(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function tl(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(n,e)=>e.toUpperCase())}let Vs={};function eD(t){if(null==t)return null;const n={};return n.className=t.getClassName(),n.config=t.getConfig(),n}function tD(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(n=>tD(n));else{const n=Object.keys(t);for(const e of n){const r=t[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?tD(r):t[e]=r.value)}}}function Lh(t,n={},e={},r="object",s=!1){if("string"==typeof t){const o=t;let i;if(o in e)i=e[o];else if(o in Vs)i=Vs[o];else if(i=n[o],null==i)throw new L(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const o=t;if(null==o.className||null==o.config)throw new L(`${r}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const i=o.className;let a,l;if(i in e?[a,l]=e[i]:i in Vs?[a,l]=Vs.className:i in n&&([a,l]=n[i]),null==a)throw new L(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const f of Object.keys(Vs))u[f]=Vs[f];for(const f of Object.keys(e))u[f]=e[f];o.config.customObjects=u;const d=Object.assign({},Vs);for(const f of Object.keys(e))Vs[f]=e[f];tD(o.config);const h=l(a,o.config,e,s);return Vs=Object.assign({},d),h}{const u=Object.assign({},Vs);for(const d of Object.keys(e))Vs[d]=e[d];const c=new a(o.config);return Vs=Object.assign({},u),c}}}function ay(t,n){return-1*function ite(t,n){return t<n?-1:t>n?1:0}(t,n)}function Qi(t){if(null==t)return t;const n=[];for(const e of t)-1===n.indexOf(e)&&n.push(e);return n}function ate(t){if(null==t)throw new L(`Invalid value in obj: ${JSON.stringify(t)}`);for(const n in t)if(t.hasOwnProperty(n))return!1;return!0}function nl(t,n,e){if(null!=e&&t.indexOf(e)<0)throw new L(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}function nD(t,n,e=0,r=1/0){return vs(e>=0),vs(r>=e),Array.isArray(t)&&t.length>=e&&t.length<=r&&t.every(s=>typeof s===n)}function nr(t,n){Array.isArray(t)?(S(t.length>0,()=>`${n} is unexpectedly an empty array.`),t.forEach((e,r)=>nr(e,`element ${r+1} of ${n}`))):S(Number.isInteger(t)&&t>0,()=>`Expected ${n} to be a positive integer, but got ${zF(t)}.`)}function zF(t){return null===t?"null":Array.isArray(t)?"["+t.map(n=>zF(n)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function VF(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function rD(t,n){return U(()=>wr(Pe(V(t,t),n,!0)))}class Bh extends Cu{getConfig(){return{}}}le((()=>{class t extends Bh{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return U(()=>{const r=rD(e,this.axis),s=Jr(r,0,this.maxValue);return V(e,Le(s,me(Un(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return t.className="MaxNorm",t})()),le((()=>{class t extends Bh{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return U(()=>Le(e,me(Un(),rD(e,this.axis))))}getConfig(){return{axis:this.axis}}}return t.className="UnitNorm",t})()),le((()=>{class t extends Bh{apply(e){return bi(e)}}return t.className="NonNeg",t})()),le((()=>{class t extends Bh{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return U(()=>{const r=rD(e,this.axis),s=me(V(this.rate,Jr(r,this.minValue,this.maxValue)),V(1-this.rate,r));return V(e,Le(s,me(Un(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return t.className="MinMaxNorm",t})());const UF={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Hn(t){return eD(t)}function HF(t,n={}){return Lh(t,$s.getMap().classNameMap,n,"constraint")}function Wn(t){return null==t?null:"string"==typeof t?HF({className:t in UF?UF[t]:t,config:{}}):t instanceof Bh?t:HF(t)}const ute=["channelsFirst","channelsLast"],cte=["nearest","bilinear"],dte=["valid","same","causal"],hte=["max","avg"],fte=["sum","mul","concat","ave"],$u=new Map;function Cn(t){nl(ute,"DataFormat",t)}function xs(t){nl(dte,"PaddingMode",t)}function WF(t){nl(hte,"PoolMode",t)}const zh=[];function rl(t,n){zh.push(t);try{const e=n();return zh.pop(),e}catch(e){throw zh.pop(),e}}function GF(t){if(!KF(t))throw new Error("Not a valid tensor name: '"+t+"'");return function mte(){return 0===zh.length?"":zh.join("/")+"/"}()+t}function qF(t){if(!KF(t))throw new Error("Not a valid tensor name: '"+t+"'");$u.has(t)||$u.set(t,0);const n=$u.get(t);if($u.set(t,$u.get(t)+1),n>0){const e=`${t}_${n}`;return $u.set(e,1),e}return t}const gte=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function KF(t){return!!t.match(gte)}function yte(t){return t===parseInt(t.toString(),10)}function ea(t,n,e){null==n&&(n=0),null==e&&(e=t.length);let r=1;for(let s=n;s<e;++s)r*=t[s];return r}function ly(t){return Bs(t=Array.isArray(t)?new Float32Array(t):t)}function Fu(t){return Eh(ly(t)).dataSync()[0]}function ta(t){return Ps(ly(t)).dataSync()[0]}function mo(t,n){if(n<t)throw new L(`end (${n}) < begin (${t}) is forbidden.`);const e=[];for(let r=t;r<n;++r)e.push(r);return e}function Vh(t,n){return t.asType(n)}function Uh(t,n=-1){const e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),t.reshape(e)}function sl(t,n,e){return U(()=>{switch(t.rank){case 1:return eI(t,n,e);case 2:return M2(t,[n,0],[e,t.shape[1]]);case 3:return tI(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return Ug(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Ot(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Ot(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new L(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function sD(t,n,e){return U(()=>{switch(t.rank){case 1:return eI(t,n,e);case 2:return M2(t,[0,n],[t.shape[0],e]);case 3:return tI(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return Ug(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new L(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function uy(t,n,e,r){return U(()=>{switch(t.rank){case 1:return eI(t,n,e);case 2:switch(r){case 1:return sl(t,n,e);case 2:return sD(t,n,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return sl(t,n,e);case 2:return tI(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return sD(t,n,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return sl(t,n,e);case 2:return Ug(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return Ug(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return sD(t,n,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}default:throw new L(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function oD(t,n=-1){let e;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),Tn(t,n)}function YF(t,n){switch(t.rank){case 1:return e9([t,n]);case 2:return n9([t,n],0);case 3:return s9([t,n],0);case 4:return i9([t,n],0);default:throw new L(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function iD(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new L(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return Xa(t,n)}function cy(t,n=0,e=1,r,s){return Z9(t,n,e,r,s)}function Po(t,n,e,r){if(t.rank<2||n.rank<2)throw new rt(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3&&t.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new rt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${n.shape}`);if(2===t.rank&&2===n.rank)return lI({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?aD(t.rank,r,"channelsLast"):null,activation:e});{const s=t.shape.slice(),o=s.pop();t=t.reshape([-1,o]);const i=n.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:n.rank},(p,m)=>0===m?n.rank-2:m<=n.rank-2?m-1:m);n=n.transpose(c).reshape([l,-1]);const d=[...s,...u];return lI({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?aD(t.rank,r,"channelsLast"):null,activation:e}).reshape(d)}}function JF(t,n,e){return U(()=>(n=Array.isArray(n)?Bs(n,"int32"):n.toInt(),Sh(t,n,e)))}function Hh(t){return V(t,t)}function aD(t,n,e){const r=n.shape;if(1!==n.rank&&n.rank!==t)throw new L(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===e)return n.reshape(1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return n.reshape(1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===e)return n.reshape(1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return n.reshape(1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===e)return n.reshape(1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return n.reshape(1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return n;throw new L(`Unsupported input rank by biasAdd: ${n.rank}`)}function Lo(t,n,e){return U(()=>(null==e&&(e="channelsLast"),Cn(e),t.add(aD(t.rank,n,e))))}function ZF(t,n,e,r){return U(()=>SY(t,n,e,r))}function Wh(t,n,e=!1){return e?t():n()}const Ste=["fanIn","fanOut","fanAvg"],Ete=["normal","uniform","truncatedNormal"];class Us extends Cu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}le((()=>{class t extends Us{apply(e,r){return An(e,r)}}return t.className="Zeros",t})());let QF=(()=>{class t extends Us{apply(e,r){return yi(e,r)}}return t.className="Ones",t})();le(QF),le((()=>{class t extends Us{constructor(e){if(super(),"object"!=typeof e)throw new L(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new L(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return U(()=>V(Oe(this.value),yi(e,r)))}getConfig(){return{value:this.value}}}return t.className="Constant",t})()),le((()=>{class t extends Us{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Th(e,this.minval,this.maxval,r)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return t.className="RandomUniform",t})()),le((()=>{class t extends Us{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new rt(`randomNormal does not support dType ${r}.`);return cy(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="RandomNormal",t})()),le((()=>{class t extends Us{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new rt(`truncatedNormal does not support dType ${r}.`);return rI(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="TruncatedNormal",t})()),le((()=>{class t extends Us{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return U(()=>{if(2!==e.length||e[0]!==e[1])throw new L("Identity matrix initializer can only be used for 2D square matrices.");return V(this.gain,A2(e[0]))})}getConfig(){return{gain:this.gain}}}return t.className="Identity",t})());let ws=(()=>{class t extends Us{constructor(e){if(super(),e.scale<0)throw new L(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale??1,this.mode=e.mode??"fanIn",function Nte(t){nl(Ste,"FanMode",t)}(this.mode),this.distribution=e.distribution??"normal",function Tte(t){nl(Ete,"Distribution",t)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function kte(t,n="channelsLast"){let e,r;if(Cn(n),2===t.length)e=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===n){const s=ea(t,2);e=t[1]*s,r=t[0]*s}else if("channelsLast"===n){const s=ea(t,0,t.length-2);e=t[t.length-2]*s,r=t[t.length-1]*s}}else{const s=ea(t);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),o=s[0],i=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,o):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(o+i)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new rt(`${this.getClassName()} does not support dType ${r}.`);return rI(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return Th(e,-l,l,r)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return t.className="VarianceScaling",t})();le(ws);let eO=(()=>{class t extends ws{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ws.className}}return t.className="GlorotUniform",t})();le(eO);let tO=(()=>{class t extends ws{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ws.className}}return t.className="GlorotNormal",t})();le(tO);let nO=(()=>{class t extends ws{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ws.className}}return t.className="HeNormal",t})();le(nO);let rO=(()=>{class t extends ws{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ws.className}}return t.className="HeUniform",t})();le(rO);let sO=(()=>{class t extends ws{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ws.className}}return t.className="LeCunNormal",t})();le(sO);let oO=(()=>{class t extends ws{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ws.className}}return t.className="LeCunNormal",t})();le(oO),le((()=>{class t extends Us{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain??this.DEFAULT_GAIN,this.seed=e.seed,null!=this.seed)throw new rt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,r){return U(()=>{if(e.length<2)throw new rt("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const o=cy(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let i=tZ.gramSchmidt(o);return e[0]>e[1]&&(i=i.transpose()),V(this.gain,i)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return t.className="Orthogonal",t})());const iO={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function aO(t,n={}){return Lh(t,$s.getMap().classNameMap,n,"initializer")}function dn(t){return eD(t)}function sn(t){if("string"==typeof t){const n=t in iO?iO[t]:t;if("GlorotNormal"===n)return new tO;if("GlorotUniform"===n)return new eO;if("HeNormal"===n)return new nO;if("HeUniform"===n)return new rO;if("LeCunNormal"===n)return new sO;if("LeCunUniform"===n)return new oO;{const e={};return e.className=n,e.config={},aO(e)}}return t instanceof Us?t:aO(t)}let Ate=0;function lO(){return Ate++}const dy={};function hy(t=""){return t in dy||(dy[t]=0),dy[t]+=1,t+dy[t].toString()}function lD(t){return Array.isArray(t)&&Array.isArray(t[0])}function fy(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function ct(t){let n;if(Array.isArray(t)){if(1!==t.length)throw new L(`Expected Tensor length to be 1; got ${t.length}`);n=t[0]}else n=t;return n}function jt(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new L(`Expected exactly 1 Shape; got ${t.length}`)}return t}function py(t){let n=0;for(const e of t)n+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return n}const uO="Variable";class Bo{constructor(n,e="float32",r=uO,s=!0,o=null){this.dtype=e??"float32",this.shape=n.shape,this.id=lO(),this.originalName=GF(r=r??uO),this.name=qF(this.originalName),this.trainable_=s,this.constraint=o,this.val=function vY(t,n=!0,e,r){return F.makeVariable(t,n,e,r)}(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),function Rte(t,n){if(t.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}(this.val,n),this.val.id!==n.id&&(this.val.assign(n),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}}function uD(t){return t.map(n=>n.read())}function cD(t){t.forEach(n=>{n[0].write(n[1])})}class hr{constructor(n){this.dtype=n.dtype,this.shape=n.shape,this.ndim=null!=n.shape?n.shape.length:n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}}class zo{constructor(n,e,r,s,o,i,a){this.dtype=n,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=a,this.id=lO(),null!=i&&(this.originalName=GF(i),this.name=qF(this.originalName)),this.rank=e.length}}let $te=0;class my{constructor(n,e){this.callArgs=e,this.id=$te++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(const r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){const n=[];for(const e of this.inboundLayers)n.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Fte=0;class Et extends Cu{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Fte++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=n.name;if(!e){const r=this.getClassName();e=Ii(r)+"_"+hy(r)}if(this.name=e,this.trainable_=n.trainable??!0,null!=n.inputShape||null!=n.batchInputShape){let r;if(null!=n.batchInputShape)r=n.batchInputShape;else if(null!=n.inputShape){let o=null;null!=n.batchSize&&(o=n.batchSize),r=[o].concat(n.inputShape)}this.batchInputShape=r;let s=n.dtype;null==s&&(s=n.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=n.weights?n.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,e){return n.name+"_ib-"+e.toString()}getNodeAtIndex(n,e){if(0===this.inboundNodes.length)throw new zs(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=n)throw new L(`Asked to get ${e} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return Hr(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return Hr(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Mo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Mo(`Layer ${this.name} is not connected, no input to return.`);return Hr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Mo(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Mo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Hr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(e=>e.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){if(n=Yt(n),null==this.inputSpec||0===this.inputSpec.length)return;const e=Yt(this.inputSpec);if(n.length!==e.length)throw new L(`Layer ${this.name} expects ${e.length} inputs, but it received ${n.length} input tensors. Input received: ${n}`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];if(null==o)continue;const i=s.rank;if(null!=o.ndim&&i!==o.ndim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${i}`);if(null!=o.maxNDim&&i>o.maxNDim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${i}`);if(null!=o.minNDim&&i<o.minNDim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${i}.`);if(null!=o.dtype&&s.dtype!==o.dtype)throw new L(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const a=s.shape;for(const l in o.axes){const u=Number(l),c=o.axes[l],d=u>=0?a[u]:a[a.length+u];if(null!=c&&-1===[c,null].indexOf(d))throw new L(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(null!=o.shape)for(let a=0;a<o.shape.length;++a){const l=o.shape[a],u=s.shape[a];if(null!=l&&null!=u&&l!==u)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(n,e){return n}invokeCallHook(n,e){null!=this._callHook&&this._callHook(n,e)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,e){e=e||{},this.assertNotDisposed();const r=Yt(n);let s=!0;for(const i of r)if(!(i instanceof zo)){s=!1;break}let o=!0;for(const i of r)if(i instanceof zo){o=!1;break}if(s===o)throw new L("Arguments to apply() must be all SymbolicTensors or all Tensors");return rl(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);const i=[];for(const a of Yt(n))i.push(a.shape);this.build(Hr(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(n),o){let i=this.call(n,e);const a=Yt(i),l=[];for(let u of a)-1!==r.indexOf(u)&&(u=u.clone()),l.push(u);if(i=Hr(l),null!=this.activityRegularizer)throw new rt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const i=function Ote(t){t=Yt(t);const n=[];for(const e of t)n.push(e.shape);return Hr(n)}(n),a=this.computeOutputShape(i);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(n)?i[0]:i),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((c,d)=>new zo(u,c,this,Yt(n),e,this.name,d)):new zo(u,a,this,Yt(n),e,this.name),this.addInboundNode(n,l,null,null,i,a,e),this._refCount++,null!=this.activityRegularizer)throw new rt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(n){if(null!=this.batchInputShape)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=n[s]&&n[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Mo(`The layer ${this.name} has never been called and thus has no defined output shape.`);const n=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===n.indexOf(r)&&n.push(r)}if(1===n.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Mo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new zs(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return py(this.weights)}build(n){this.built=!0}getWeights(n=!1){return uD(n?this.trainableWeights:this.weights)}setWeights(n){U(()=>{const e=this.weights;if(e.length!==n.length)throw new L(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${e.length} weights. Provided weights: ${n}...`);if(0===e.length)return;const r=[],s=uD(e);for(let o=0;o<s.length;++o){const i=s[o],a=e[o],l=n[o];if(!zt(i.shape,l.shape))throw new L(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}cD(r)})}addWeight(n,e,r,s,o,i,a){if(-1!==this._addedWeightNames.indexOf(n))throw new L(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=sn("zeros"));const l=s.apply(e,r),u=new Bo(l,r,n,i,a);return l.dispose(),null!=o&&this.addLoss(()=>o.apply(u.read())),null==i&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){null==n||Array.isArray(n)&&0===n.length||(n=Yt(n),null!=this._losses&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(n,e,r,s,o,i,a=null){const l=Yt(n);e=Yt(e),r=Yt(r),s=Yt(s),o=fy(o),i=fy(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new my({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const n={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(n.batchInputShape=this.batchInputShape),null!=this.dtype&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return 0==--this._refCount&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}}function cO(t,n,e){if((null==n||null!=e&&e>0)&&(n=t.sourceLayer,e=t.nodeIndex),0===n.inboundNodes.length)return[t];{const r=n.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let o=0;o<r.inboundLayers.length;o++){const u=cO(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const c of u)-1===s.indexOf(c)&&s.push(c)}return s}}}let gy=(()=>{class t extends Et{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:hy("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new L("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new L("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new L("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const o=new zo(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new my({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new L(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return t.className="InputLayer",t})();function na(t){return dD.apply(this,arguments)}function dD(){return(dD=Q(function*(t){if(null==t)return;const n=[],e=[],r=[];for(const s in t){const o=t[s];if("number"!=typeof o){const i=o;n.push(i.data()),e.push(s),r.push(i)}}if(n.length>0){const s=yield Promise.all(n);for(let o=0;o<s.length;++o)t[e[o]]=s[o][0];ut(r)}})).apply(this,arguments)}function dO(t){if(null!=t)for(const n in t){const e=t[n];"number"!=typeof e&&e.dispose()}}le(gy);class Ou{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,e){return Q(function*(){})()}onEpochEnd(n,e){return Q(function*(){})()}onBatchBegin(n,e){return Q(function*(){})()}onBatchEnd(n,e){return Q(function*(){})()}onTrainBegin(n){return Q(function*(){})()}onTrainEnd(n){return Q(function*(){})()}setModel(n){}}class Bte{constructor(n,e=10){null==n&&(n=[]),this.callbacks=n,this.queueLength=e}append(n){this.callbacks.push(n)}setParams(n){for(const e of this.callbacks)e.setParams(n)}setModel(n){for(const e of this.callbacks)e.setModel(n)}onEpochBegin(n,e){var r=this;return Q(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(n,e)})()}onEpochEnd(n,e){var r=this;return Q(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(n,e)})()}onBatchBegin(n,e){var r=this;return Q(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(n,e)})()}onBatchEnd(n,e){var r=this;return Q(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(n,e)})()}onTrainBegin(n){var e=this;return Q(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainBegin(n)})()}onTrainEnd(n){var e=this;return Q(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainEnd(n)})()}}class zte extends Ou{constructor(){super()}onEpochBegin(n){var e=this;return Q(function*(){e.seen=0,e.totals={}})()}onBatchEnd(n,e){var r=this;return Q(function*(){null==e&&(e={});const s=e.size??0;r.seen+=s;for(const o in e){const i=e[o];if("number"==typeof i)r.totals.hasOwnProperty(o)||(r.totals[o]=0),r.totals[o]=r.totals[o]+i*s;else{let a;o in r.totals?a=r.totals[o]:r.totals[o]=0;const l=U(()=>me(r.totals[o],V(i,s)));r.totals[o]=l,a?.dispose()}}})()}onEpochEnd(n,e){var r=this;return Q(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:U(()=>{const o=V(Le(1,r.seen),r.totals[s]);e[s]=o,r.totals[s].dispose(),ur(e[s])}))})()}}class Vte extends Ou{onTrainBegin(n){var e=this;return Q(function*(){e.epoch=[],e.history={}})()}onEpochEnd(n,e){var r=this;return Q(function*(){null==e&&(e={}),r.epoch.push(n);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var n=this;return Q(function*(){const e=[],r=[],s=[];for(const i in n.history){const a=n.history[i];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(i),s.push(l))}const o=yield Promise.all(e);for(let i=0;i<o.length;++i)n.history[r[i]][s[i]].dispose(),n.history[r[i]][s[i]]=o[i][0]})()}}class Ute extends Ou{constructor(n,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");h0(this.yieldEvery)&&(this.maybeWait=function lte(t,n){let r,e=Ur();return(...o)=>{const i=Ur();return i-e<n||(e=i,r=t(...o)),r}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,e,r){var s=this;return Q(function*(){const o=[];null!=s.yield&&(yield na(r),o.push(s.yield(n,e,r))),o.push(SI()),yield Promise.all(o)})()}onEpochBegin(n,e){var r=this;return Q(function*(){r.currentEpoch=n,null!=r.epochBegin&&(yield na(e),yield r.epochBegin(n,e))})()}onEpochEnd(n,e){var r=this;return Q(function*(){const s=[];null!=r.epochEnd&&(yield na(e),s.push(r.epochEnd(n,e))),"epoch"===r.yieldEvery&&s.push(SI()),yield Promise.all(s)})()}onBatchBegin(n,e){var r=this;return Q(function*(){null!=r.batchBegin&&(yield na(e),yield r.batchBegin(n,e))})()}onBatchEnd(n,e){var r=this;return Q(function*(){const s=[];null!=r.batchEnd&&(yield na(e),s.push(r.batchEnd(n,e))),"batch"===r.yieldEvery?s.push(SI()):h0(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,n,e)),yield Promise.all(s)})()}onTrainBegin(n){var e=this;return Q(function*(){null!=e.trainBegin&&(yield na(n),yield e.trainBegin(n))})()}onTrainEnd(n){var e=this;return Q(function*(){null!=e.trainEnd&&(yield na(n),yield e.trainEnd(n))})()}}function hO(t,n){return null==t&&(t={}),t instanceof Ou?[t]:Array.isArray(t)&&t[0]instanceof Ou?t:Yt(t).map(r=>new Ute(r,n))}let Hte=(()=>{class t{constructor(){}static registerCallbackConstructor(e,r){S(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),t.checkForDuplicate(r),null==t.constructors[e]&&(t.constructors[e]=[]),t.constructors[e].push(r)}static checkForDuplicate(e){for(const r in t.constructors)t.constructors[+r].forEach(o=>{if(o===e)throw new L("Duplicate callback constructor.")})}static clear(){t.constructors={}}static createCallbacks(e){const r=[];for(const s in t.constructors){const o=+s;e>=o&&r.push(...t.constructors[o])}return r.map(s=>new s)}}return t.constructors={},t})();function fO(t,n,e,r,s,o,i,a,l){const u=new Vte,c=[new zte,...Hte.createCallbacks(n)];null!=t&&c.push(...t),c.push(u);const d=new Bte(c);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:o,batchSize:i,verbose:n,doValidation:a,metrics:l}),{callbackList:d,history:u}}function Di(t,n={},e=!1){return Lh(t,$s.getMap().classNameMap,n,"layer",e)}function yy(t,n){return U(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const e=Pe(Hh(t),n,!0),r=Pg(e.shape,Un()),s=wr(gi(e,r));return Le(t,s)})}function by(t,n){return U(()=>gn(Hh(Fe(n,t)),-1))}function hD(t,n){return U(()=>gn(Qn(Fe(n,t)),-1))}function fD(t,n){return U(()=>{const e=Fe(t,n),r=Jr(Qn(t),Un(),Number.MAX_VALUE),s=Qn(Le(e,r));return V(100,gn(s,-1))})}function jh(t,n,e=!1){return U(()=>{if(e)n=Hg(n);else{const r=Pe(n,n.shape.length-1,!0);n=Le(n,r)}return n=Jr(n,Un(),1-Un()),yn(Pe(V(t.toFloat(),ms(n)),n.shape.length-1))})}function vy(t,n,e=!1){return U(()=>{const r=_h(function wte(t){const n=[ea(t.shape)];return t.reshape(n)}(t)).toInt(),s=(n=Jr(n,Un(),1-Un())).shape;return jh(YC(r,s[s.length-1]).reshape(s),n,e)})}function xy(t,n){return U(()=>{let e;return e=Jr(n,Un(),1-Un()),e=ms(Le(e,Fe(1,e))),gn(function Xte(t,n){if(!zt(t.shape,n.shape))throw new L(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`);return U(()=>{const e=n.relu(),r=n.abs().neg();return e.sub(n.mul(t)).add(r.exp().log1p())})}(t,e),-1)})}function pO(t,n){return U(()=>{const e=yy(t,-1),r=yy(n,-1),s=V(e,r);return yn(Pe(s,-1))})}const wy={meanSquaredError:by,meanAbsoluteError:hD,meanAbsolutePercentageError:fD,meanSquaredLogarithmicError:function Wte(t,n){return U(()=>{const e=Jr(n,Un(),Number.MAX_VALUE),r=ms(me(1,e)),s=Jr(t,Un(),Number.MAX_VALUE),o=ms(me(1,s));return gn(Hh(Fe(r,o)),-1)})},squaredHinge:function jte(t,n){return U(()=>{const e=gi(0,Fe(1,V(t,n)));return gn(Hh(e),-1)})},hinge:function Gte(t,n){return U(()=>{const e=gi(0,Fe(1,V(t,n)));return gn(e,-1)})},categoricalHinge:function qte(t,n){return U(()=>{const e=Pe(V(t,n),-1),r=Ps(V(Fe(1,t),n),-1);return gi(0,me(1,Fe(r,e)))})},logcosh:function Kte(t,n){return U(()=>{const e=Math.log(2),r=Fe(n,t),s=Fe(me(r,kh(V(-2,r))),e);return gn(s,-1)})},categoricalCrossentropy:jh,sparseCategoricalCrossentropy:vy,binaryCrossentropy:xy,kullbackLeiblerDivergence:function Yte(t,n){return U(()=>{const e=Jr(t,Un(),1),r=Jr(n,Un(),1);return Pe(V(t,ms(Le(e,r))),-1)})},poisson:function Jte(t,n){return U(()=>{const e=ms(me(Un(),n));return gn(Fe(n,V(t,e)),-1)})},cosineProximity:pO};function pD(t){if("string"==typeof t){if(t in wy)return wy[t];let n=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new L(n)}return t}function mO(t,n){return U(()=>{const e=V(.5,gs(n)),r=Vh(Fo(n,e),t.dtype);return gn(Ka(t,r),-1)})}function gO(t,n){return U(()=>Vh(Ka(Fg(t,-1),Fg(n,-1)),"float32"))}function tne(t,n){return xy(t,n)}function nne(t,n){return t.rank===n.rank&&(t=t.squeeze([t.rank-1])),(n=n.argMax(-1)).dtype!==t.dtype&&(n=n.asType(t.dtype)),Ka(t,n).asType("float32")}const bO=jh,vO=vy,Cy={binaryAccuracy:mO,categoricalAccuracy:gO,precision:function ene(t,n){return U(()=>{const e=function yO(t,n){return U(()=>Oo(t.equal(1),n.equal(1)).sum().cast("float32"))}(t,n),r=function Qte(t,n){return U(()=>Oo(t.equal(0),n.equal(1)).sum().cast("float32"))}(t,n),s=e.add(r);return bs(Fo(s,0),e.div(s),0).cast("float32")})},categoricalCrossentropy:bO,sparseCategoricalCrossentropy:vO,mse:by,MSE:by,mae:hD,MAE:hD,mape:fD,MAPE:fD,cosine:pO};function cne(t){if("string"==typeof t&&t in Cy)return Cy[t];if("string"!=typeof t&&null!=t)return t;throw new L(`Unknown metric ${t}`)}function Iy(t){if(vs(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let n;for(const e of Object.keys(wy))if(wy[e]===t){n=e;break}if(void 0!==n)return n;for(const e of Object.keys(Cy))if(Cy[e]===t){n=e;break}return void 0!==n?n:t.name}}function wO(t,n,e=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!mD(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(t);r.length>1048576&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function mD(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const n=Object.keys(t);for(const e of n)if("string"!=typeof e||!mD(t[e]))return!1;return!0}if(Array.isArray(t)){for(const n of t)if(!mD(n))return!1;return!0}return!1}{const n=typeof t;return"string"===n||"number"===n||"boolean"===n}}function Dy(t,n,e=console.log){let r="";for(let s=0;s<t.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=t[s],r=r.slice(0,n[s]),r+=" ".repeat(n[s]-r.length);e(r)}function mne(t,n,e){let r;try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}Dy([`${t.name} (${t.getClassName()})`,r,t.countParams().toString()],n,e)}function gne(t,n,e,r){let s;try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const o=[];for(const c of t.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(c)))for(let d=0;d<c.inboundLayers.length;++d)o.push(`${c.inboundLayers[d].name}[${c.nodeIndices[d]}][${c.tensorIndices[d]}]`);const i=t.name,a=t.getClassName(),l=0===o.length?"":o[0];Dy([`${i} (${a})`,s,t.countParams().toString(),l],n,r);for(let c=1;c<o.length;++c)Dy(["","","",o[c]],n,r)}function CO(t,n,e){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===n&&"string"==typeof e}function gD(t,n){if(null===t)return null;if("string"==typeof t)return tl(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let s=0;s<r;++s){const o=t[s];CO(n,s,o)?e.push(o):e.push(gD(o,n))}return e}{const e={};for(const r of Object.keys(t)){const s=t[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const o=tl(r);e[o]=gD(s,o)}}return e}}function yD(t,n){if(null==t)return null;if("string"==typeof t)return Ii(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let s=0;s<r;++s){const o=t[s];CO(n,s,o)?e.push(o):e.push(yD(o,n))}return e}{const e={};for(const r of Object.keys(t)){const s=t[r];e[Ii(r)]="name"!==r&&"className"!==r||"string"!=typeof s?yD(s,r):s}return e}}class ra{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof ra)for(const e in n.id2Value)this.id2Value[e]=n.id2Value[e],e in n.id2Mask&&(this.id2Mask[e]=n.id2Mask[e]);else{if(null==n)return;for(const e of n)this.add(e.key,e.value)}}add(n,e,r){if(null!=this.id2Value[n.id])throw new L(`Duplicate key: name=${n.name}, id=${n.id}`);return this.id2Value[n.id]=function yne(t,n){if(null==t.dtype||t.dtype===n.dtype)return n;try{return Ae(n,t.dtype)}catch{throw new L(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(n,e),this.name2Id[n.name]=n.id,null!=r&&(this.id2Mask[n.id]=r),this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return null!=this.id2Value[n.id]}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof zo){if(null==this.id2Value[n.id])throw new L(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}{const e=this.name2Id[n];if(null==e)throw new L(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[e]}}getMask(n){if(n instanceof zo){if(null==this.id2Value[n.id])throw new L(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}{const e=this.name2Id[n];if(null==e)throw new L(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&ut(this.id2Mask)}}const vD={},IO={};function Gh(t,n,e,r){const s=null!=e&&e.training,o=Array.isArray(t),i=o?t:[t],a=i.map(p=>p.name),l=[],u=n.names();for(const p of a)-1!==u.indexOf(p)?l.push(n.getValue(p)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=a.join(",")+"|"+n.names().join(",");let d,h;if(null==vD[c]){const p=function bne(t,n){S(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===t.length){const s=DO(t[0],n);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const o of t){const{sorted:i,recipientMap:a}=DO(o,n);for(const l of i)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:e,recipientCounts:vne(r)}}(i,n);d=p.sorted,h=p.recipientCounts,vD[c]=d,IO[c]=h}d=vD[c],h={},s||Object.assign(h,IO[c]);const f=new ra(n);for(let p=0;p<d.length;++p){if(null!=r){const R=BC().numTensors;R>r.maxNumTensors&&(r.maxNumTensors=R),R<r.minNumTensors&&(r.minNumTensors=R)}const m=d[p],g=m.sourceLayer;if(g instanceof gy)continue;const y=[],b=[],v=[];let x=!1;for(const R of m.inputs){const O=f.getValue(R),j=f.getMask(R);y.push(O),b.push(j),null!=j&&(x=!0),s||(h[R.name]--,0===h[R.name]&&!n.hasKey(R)&&-1===a.indexOf(R.name)&&!O.isDisposed&&!0!==R.sourceLayer.stateful&&v.push(O))}x&&((e=e||{}).mask=b[0]);const w=Yt(g.apply(y,e));let _=null;g.supportsMasking&&(_=g.computeMask(y,b));const D=xne(m),A=Array.isArray(D)?D:[D];for(let R=0;R<A.length;++R){f.hasKey(A[R])||f.add(A[R],w[R],Array.isArray(_)?_[0]:_);const O=a.indexOf(A[R].name);-1!==O&&(l[O]=w[R])}s||ut(v)}return f.disposeMasks(),o?l:l[0]}function vne(t){const n={};for(const e in t)n[e]=t[e].size;return n}function DO(t,n){const e=new Set,r=[],s={};for(const a of n.names())e.add(a);const o=[],i=[];for(o.push(t);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(0===a.inputs.length||l)o.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)null==s[u.name]&&(s[u.name]=new Set),s[u.name].add(a.name),!e.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function xne(t){let n;if(1===t.sourceLayer.inboundNodes.length)n=t.sourceLayer.output;else{let e=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(const s of t.sourceLayer.inboundNodes[r].outputTensors)if(s.id===t.id){e=r;break}n=t.sourceLayer.getOutputAt(e)}return n}class go extends Et{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=hy(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(n.inputs)?n.inputs.slice():[n.inputs],this.outputs=Array.isArray(n.outputs)?n.outputs.slice():[n.outputs],Qi(this.inputs).length!==this.inputs.length)throw new L(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Qi(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const v=b.sourceLayer,x=b.nodeIndex,w=b.tensorIndex;vs(0===x,"input layer has >1 nodes"),vs(0===w,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const v=this.inputLayers[b];if(!(v instanceof gy))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},r={},s={},o={},i={},a=[],l=(b,v,x,w,_,D)=>{(null==w||null==_||null==D)&&(w=b.sourceLayer,_=b.nodeIndex,D=b.tensorIndex);const A=w.inboundNodes[_];if(-1!==x.indexOf(A))throw new zs(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(-1!==v.indexOf(A))return;this.containerNodes.add(go.nodeKey(w,_)),w.id in i||(i[w.id]=Object.keys(i).length),-1===x.indexOf(A)&&x.push(A);const R=A.inboundLayers.length;for(let O=0;O<R;O++)l(A.inputTensors[O],v,x,A.inboundLayers[O],A.nodeIndices[O],A.tensorIndices[O]);for(v.push(A);x.indexOf(A)>=0;)x.splice(x.indexOf(A),1);a.push(A)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const d=a.slice().reverse();for(const b of d){r[b.id]=b,b.id in e||(e[b.id]=0);let v=e[b.id];v=Math.max(v,s[b.outboundLayer.id]??0),s[b.outboundLayer.id]=v,o[b.outboundLayer.id]=b.outboundLayer,e[b.id]=v;for(let w=0;w<b.inboundLayers.length;w++){const A=b.inboundLayers[w].inboundNodes[b.nodeIndices[w]];e[A.id]=Math.max(v+1,e[A.id]??0),r[A.id]=A}}const h={};for(const b in e){const v=e[b];v in h||(h[v]=[]),h[v].push(r[b])}const f={};for(const b in s){const v=s[b];v in f||(f[v]=[]),f[v].push(o[b])}let p=Object.keys(f).map(b=>parseInt(b,10)).sort(ay);this.layers=[];for(const b of p){const v=f[b];v.sort((x,w)=>{const _=i[x.id],D=i[w.id];return _<D?-1:_>D?1:0});for(const x of v)x instanceof go&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=f,p=Object.keys(h).map(b=>parseInt(b,10)).sort(ay);const m=this.inputs.slice(),g=[];for(const b of p)for(const v of h[b]){const x=v.outboundLayer;if(null!=x){for(const w of v.inputTensors)if(-1===m.indexOf(w))throw new zs(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${x.name}". The following previous layers were accessed without issue: ${g}`);for(const w of v.outputTensors)m.push(w);g.push(x.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const v=y.filter(x=>x===b).length;if(1!==v)throw new zs(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new my({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const n={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)n.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)n.numDisposedVariables+=e.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new L("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(const e of this.layers)n=n.concat(e.trainableWeights);return n}get nonTrainableWeights(){const n=[];for(const e of this.layers)n.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,e=!0){const r={};let s=0;for(const i of this.layers)for(const a of i.weights){if(null!=r[a.originalName])throw new L(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const o=[];for(const i in n){let a=i;if(null==r[i]){const l=i.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])o.push([r[a],n[i]]);else if(e)throw new L(`Provided weight data has no target variable: ${i}`);delete r[a]}if(e){const i=[];for(const a in r)i.push(a);if(i.length>0)throw new L(`${i.length} of ${s} weights are not set: ${i}`)}cD(o)}updatedConfig(){const n=this.getConfig(),e={};return e.className=this.getClassName(),e.config=n,e.kerasVersion="tfjs-layers 3.3.0",e.backend="TensorFlow.js",e}toJSON(n,e=!0){const r=yD(this.updatedConfig());return e?JSON.stringify(r):r}call(n,e){return U(()=>{n=Yt(n);const r=new ra;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],n[s]);return Gh(this.outputs,r,e)})}computeMask(n,e){return U(()=>{let r;return n=Yt(n),r=null==e?el(null,n.length):Yt(e),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){const e=fy(n);if(e.length!==this.inputLayers.length)throw new L(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(ay);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(c.id))continue;const d=[];for(let m=0;m<u.inboundLayers.length;m++)d.push(r[`${u.inboundLayers[m].name}_${u.nodeIndices[m]}_${u.tensorIndices[m]}`]);const f=fy(c.computeOutputShape(Hr(d))),p=c.inboundNodes.indexOf(u);for(let m=0;m<f.length;m++)r[`${c.name}_${p}_${m}`]=f[m]}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const l=i[a];vs(l in r),o.push(r[l])}return Hr(o)}runInternalGraph(n,e){null==e&&(e=el(null,n.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[n[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(ay);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,f=c.outputTensors,p=new Array;for(const m of h)m.id in r&&p.push(r[m.id]);if(p.length===h.length){let g,y,b,v,m={};if(null!=c.callArgs&&(m=c.callArgs),1===p.length){const[x,w]=p[0];null==m.mask&&(m.mask=w),b=Yt(d.call(x,m)),v=Yt(d.computeMask(x,w)),g=[x],y=[w]}else g=p.map(x=>x[0]),y=p.map(x=>x[1]),null==m.mask&&(m.mask=y),b=Yt(d.call(g,m)),v=Yt(d.computeMask(g,y));if(d.activityRegularizer)throw new rt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<f.length;++x)r[f[x].id]=[b[x],v[x]]}}}const o=[],i=[],a=[];for(const l of this.outputs){vs(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(n){const e={};let r;for(const s of this.layers){r=s instanceof go?1:0;for(let o=0;o<s.inboundNodes.length;o++){const i=go.nodeKey(s,o);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(n,e){if(null!=e){if(this.layers.length<=e)throw new L(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==n)throw new L("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===n)return r;throw new L(`No such layer: ${n}`)}calculateLosses(){return U(()=>{const n=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=go.nodeKey(e,r);this.containerNodes.has(s)&&n.push(...e.calculateLosses())}return n})}getConfig(){const n={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],f=go.nodeKey(i,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],v=h.tensorIndices[g];let w=e[go.nodeKey(y,h.nodeIndices[g])];null==w&&(w=0),m.push([y.name,w,v,p])}u.push(m)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}n.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],u=go.nodeKey(a,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),s.push([a.name,c,this.inputLayersTensorIndices[i]])}n.inputLayers=s;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],u=go.nodeKey(a,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),o.push([a.name,c,this.outputLayersTensorIndices[i]])}return n.outputLayers=o,n}static fromConfig(n,e,r={},s=!1){const o={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){const b=[];let v;for(const x of y){const w=x[0],_=x[1],D=x[2];if(v=x[3]??{},!(w in o))return void a(g,y);const A=o[w];if(A.inboundNodes.length<=_)return void a(g,y);b.push(A.inboundNodes[_].outputTensors[D])}b.length>0&&g.apply(Hr(b),v)}function u(g){const y=g.name,b=Di(g,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(s),o[y]=b,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new L(`Corrupted configuration, expected array for nodeData: ${x}`);a(b,x)})}const c=e.name,d=e.layers;for(const g of d)u(g);for(;!ate(i);)for(const g of d){const y=o[g.name];if(y.name in i){const b=i[y.name];delete i[y.name];for(const v of b)l(y,v)}}const h=[],f=[],p=e.inputLayers;for(const g of p){const y=g[0],b=g[1],v=g[2];vs(y in o),h.push(o[y].inboundNodes[b].outputTensors[v])}const m=e.outputLayers;for(const g of m){const y=g[0],b=g[1],v=g[2];vs(y in o),f.push(o[y].inboundNodes[b].outputTensors[v])}return new n({inputs:h,outputs:f,name:c})}get stateful(){if(this._stateful)throw new L("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const n of this.layers)if(n.stateful)return!0;return!1}resetStates(){U(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}}function SO(t,n){return function _O(t,n,e){const r=n.length;if(null==t||Array.isArray(t)&&0===t.length)return n.map(s=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&n[0]in t?[t[n[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${e} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const s=[];return n.forEach(o=>{s.push(o in t?t[o]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${n} keys. Provided ${e} not understood: ${JSON.stringify(t)}`)}(t,n,"classWeight")}function EO(t,n,e,r){return xD.apply(this,arguments)}function xD(){return(xD=Q(function*(t,n,e,r){if(null!=n||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=U(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(yield s.data());ut(s);const i=[];return o.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Bs(i,"float32")}return null})).apply(this,arguments)}function wne(t,n){return V(t,n)}function NO(t,n){let e,r;e=n.xs,r=n.ys,S(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);const o=TO("input",t.inputNames,e),i=TO("output",t.outputNames,r),a=o[0].shape[0];S(o.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),S(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<i.length;l++)S(i[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:o,ys:i}}function TO(t,n,e){if(e instanceof un)return[e];if(Array.isArray(e))return S(e.length===n.length,()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`),e;{const r=[];for(const s of n){if(null==e[s])throw new L(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(e[s])}return r}}function Ine(t){if(3===t.length)throw new rt("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}function wD(){return(wD=Q(function*(t,n,e){const r=null!=e.batchesPerEpoch;if(S(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),S(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),S(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=null!=e.validationData;let o,i;if(s)if(kO(e.validationData))S(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=Ine(e.validationData);o=g.xs,i=g.ys}const a=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const c=hO(e.callbacks,e.yieldEvery),d=e.verbose??1,{callbackList:h,history:f}=fO(c,d,e.epochs,null,null,_ne(n,e),null,s,u);h.setModel(t),t.history=f,yield h.onTrainBegin(),t.stopTraining_=!1;let p=e.initialEpoch??0,m=yield n.iterator();for(;p<e.epochs;){const g={};yield h.onEpochBegin(p);let y=0,b=0;for(r||(m=yield n.iterator());!r||y<e.batchesPerEpoch;){const v=yield m.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=v.value){const{xs:x,ys:w}=NO(t,v.value),_={};_.batch=b,_.size=x[0].shape[0],yield h.onBatchBegin(b,_);const D=[];if(null!=e.classWeight){const O=SO(e.classWeight,t.outputNames);for(let j=0;j<O.length;++j)D.push(yield EO(w[j],null,O[j]))}const A=x.concat(w).concat(D),R=a(A);ut(A);for(let O=0;O<l.length;++O){const K=R[O];_[l[O]]=K,ur(K)}yield h.onBatchEnd(b,_),dO(_),b++,y++}if(r?y>=e.batchesPerEpoch:v.done){if(s){let x;x=kO(e.validationData)?Yt(yield t.evaluateDataset(e.validationData,{batches:e.validationBatches})):Yt(t.evaluate(o,i,{batchSize:e.validationBatchSize??32,verbose:0}));for(let w=0;w<t.metricsNames.length;++w)g[`val_${t.metricsNames[w]}`]=x[w]}break}if(t.stopTraining_)break}if(yield h.onEpochEnd(p,g),p++,t.stopTraining_)break}return yield h.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})).apply(this,arguments)}function _ne(t,n){let e=null;return null!=n.batchesPerEpoch?e=n.batchesPerEpoch:Number.isFinite(t.size)&&(e=t.size),e}function kO(t){return"function"==typeof t.iterator}function Sne(t){return"function"==typeof t.next}function CD(){return(CD=Q(function*(t,n,e){const r=null!=(e=e||{}).batches,s=t.testFunction;let o=[];if(e.verbose>0)throw new rt("Verbose mode is not implemented yet.");S(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const i=Sne(n)?n:yield n.iterator();let a=0,l=0;for(;!r||l<e.batches;){const u=yield i.next();if(o=U(()=>{if(u.value){const{xs:c,ys:d}=NO(t,u.value),h=c.concat(d),f=U(()=>s(h));if(ut(h),0===l)for(let m=0;m<f.length;++m)o.push(Oe(0));const p=h[0].shape[0];for(let m=0;m<f.length;++m){const g=f[m],y=o[m];o[m]=U(()=>me(o[m],V(p,g))),l>0&&ut(y)}ut(f),a+=p,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=Le(o[u],a),ut(c)}return Hr(o)})).apply(this,arguments)}function ID(t){S(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function qh(t,n,e){return null==t?[null]:Array.isArray(t)?t.map(r=>sl(r,n,e-n)):sl(t,n,e-n)}function DD(t,n){return U(()=>null==t?null:Array.isArray(t)?t.map(e=>DD(e,n)):JF(t,"int32"===n.dtype?n:n.toInt()))}function _D(t,n){const e=[];let r=0,s=null;for(;r<t;)s=r+n,s>=t&&(s=t),e.push([r,s]),r=s;return e}function Nne(t,n,e,r,s,o,i,a,l,u,c,d,h,f,p){return SD.apply(this,arguments)}function SD(){return(SD=Q(function*(t,n,e,r,s,o,i,a,l,u,c,d,h,f,p){null==s&&(s=32),null==o&&(o=1),null==c&&(c=!0),null==h&&(h=0);let m=!1;if(null!=l&&null!=u&&(m=!0),null!=p&&(m=!0,null==f))throw new L("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=t.checkNumSamples(e,s,f,"steps_per_epoch");let y;null!=g&&(y=mo(0,g)),null==i&&(i=1);const{callbackList:b,history:v}=fO(a,i,o,h,g,f,s,m,d);b.setModel(t),t.history=v,yield b.onTrainBegin(),t.stopTraining_=!1;for(let x=h;x<o;++x){yield b.onEpochBegin(x);const w={};if(null!=f)throw new rt("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new rt("batch shuffling is not implemneted yet");c&&_$(y);const _=Bs(y),D=_D(g,s);for(let A=0;A<D.length;++A){const R={};if(yield b.onBatchBegin(A,R),U(()=>{const O=D[A][0],j=D[A][1],K=sl(_,O,j-O);R.batch=A,R.size=j-O;const G=DD(e,K),Z=n(G);for(let q=0;q<r.length;++q){const re=Z[q];R[r[q]]=re,ur(re)}if(A===D.length-1&&m){const q=t.testLoop(l,u,s);for(let Y=0;Y<r.length;++Y){const re=r[Y],ee=q[Y];ur(ee),w["val_"+re]=ee}}}),yield b.onBatchEnd(A,R),dO(R),t.stopTraining_)break}_.dispose()}if(yield b.onEpochEnd(x,w),t.stopTraining_)break}return yield b.onTrainEnd(),yield t.history.syncData(),t.history})).apply(this,arguments)}function ED(){return(ED=Q(function*(t,n,e,r={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,o,i,a,l,u,c;t.isTraining=!0;try{const d=r.batchSize??32;ID(d);const h=!1,f=yield t.standardizeUserData(n,e,r.sampleWeight,r.classWeight,h,d);s=f[0],o=f[1],c=f[2];let m,p=!1;if(null!=r.validationData&&r.validationData.length>0){if(p=!0,2!==r.validationData.length)throw 3===r.validationData.length?new rt("validationData including sample weights is not supported yet."):new L(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);i=r.validationData[0],a=r.validationData[1];const D=!0,A=yield t.standardizeUserData(i,a,null,null,D,d);l=A[0],u=A[1],m=l.concat(u)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){p=!0;const D=Math.floor(s[0].shape[0]*(1-r.validationSplit)),A=s[0].shape[0];l=qh(s,D,A),s=qh(s,0,D),u=qh(o,D,A),o=qh(o,0,D),m=l.concat(u)}else null!=r.validationSteps&&(p=!0);const g=s.concat(o).concat(c);t.checkTrainableWeightsConsistency();const y=t.makeTrainFunction(),b=t.getDedupedMetricsNames();let v,x;p?(t.makeTestFunction(),v=t.testFunction,x=b.slice().concat(b.map(D=>"val_"+D))):(v=null,m=[],x=b.slice());const w=hO(r.callbacks,r.yieldEvery);return yield Nne(t,y,g,b,d,r.epochs,r.verbose,w,v,m,r.shuffle,x,r.initialEpoch,null,null)}finally{t.isTraining=!1,ol(s,n),ol(o,e),ol(l,i),ol(u,a),null!=c&&ut(c)}})).apply(this,arguments)}function AO(t){const n=[];t instanceof un&&(t=[t]);for(let e=0;e<t.length;++e){const r=t[e];if(1===r.rank)n.push(Uh(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function ol(t,n){if(null==t)return;const e=[];if(n instanceof un)e.push(n.id);else if(Array.isArray(n))n.forEach(s=>e.push(s.id));else if(null!=n)for(const s in n)e.push(n[s].id);const r=[];if(t instanceof un)-1===e.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=t)for(const s in t){const o=t[s];-1===e.indexOf(o.id)&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function ND(t){return Array.isArray(t)}function RO(t){return!function kne(t){return t instanceof un}(t)&&!ND(t)}function $O(t,n,e,r=!0,s=""){if(null==n||0===n.length){if(null!=t){let i=!1;if(ND(t)&&t.length>0)i=!0;else if(RO(t)){for(const a in t)if(t.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new L(`Error when checking model ${s} expected no data, but got ${t}`)}return[]}if(null==t)return n.map(i=>null);let o;if(RO(t)){o=[];for(const i of n){if(null==t[i])throw new L(`No data provided for "${i}". Need data for each key in: ${n}`);o.push(t[i])}}else if(ND(t)){if(t.length!==n.length)throw new L(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);o=t}else{if(n.length>1)throw new L(`The model ${s} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);o=[t]}if(o=AO(o),null!=e)for(let i=0;i<n.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new L(`Error when checking ${s}: expected ${n[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const u=a.shape[l],c=e[i][l];if(null!=c&&c>=0&&u!==c)throw new L(`Error when checking ${s}: expected ${n[i]} to have shape [${e[i]}], but got array with shape [${a.shape}].`)}}return o}function FO(t,n,e,r=!0,s=""){let o;if(Array.isArray(t)){if(t.length!==n.length)throw new L(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${t.length} Tensors(s).`);o=t}else{if(n.length>1)throw new L(`The model expects ${n.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);o=[t]}if(null!=e)for(let i=0;i<n.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new L(`Error when checking ${s}: expected ${n[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const u=a.shape[l],c=e[i][l];if(null!=c&&c!==u)throw new L(`Error when checking ${s}: expected ${n[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Mu=(()=>{class t extends go{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new L("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function hne(t,n,e,r=console.log){const s=function pne(t){let n=!0;const e=[],r=[];for(const s in t.nodesByDepth)e.push(t.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){n=!1;break}r.push(...s)}if(n)for(const s of t.layers){let o=!1;for(const i of s.inboundNodes)if(-1!==r.indexOf(i)){if(o){n=!1;break}o=!0}if(!n)break}return n}(t),o=["Layer (type)","Output shape","Param #"];let i;if(s?(n=n||65,e=e||[.45,.85,1]):(n=n||98,e=e||[.33,.55,.67,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(n*c))),!s){o.push("Receives inputs"),i=[];for(const c in t.nodesByDepth)i.push(...t.nodesByDepth[c])}r("_".repeat(n)),Dy(o,e,r),r("=".repeat(n));const a=t.layers;for(let c=0;c<a.length;++c)s?mne(a[c],e,r):gne(a[c],e,i,r),r((c===a.length-1?"=":"_").repeat(n));t.checkTrainableWeightsConsistency();const l=function fne(t){let n;return n=py(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),n}(t),u=py(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(n))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function dne(t){const n={Adagrad:()=>Au.adagrad(.01),Adadelta:()=>Au.adadelta(1,.95,Un()),Adam:()=>Au.adam(.001,.9,.999,Un()),Adamax:()=>Au.adamax(.002,.9,.999,Un(),0),RMSProp:()=>Au.rmsprop(.001,.9,0,Un()),SGD:()=>Au.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new L(`Unknown Optimizer ${t}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Xi))throw new L("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new L(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>pD(l))}else{const a=pD(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new L(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(pD(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],rl("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==s.indexOf(a))continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const o=function $ne(t,n){if(null==t||Array.isArray(t)&&0===t.length)return n.map(r=>[]);let e;if("string"==typeof t||"function"==typeof t)e=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);e=t}if(Array.isArray(e))return n.map(r=>e);{const r=[];for(const s of n){let o=e.hasOwnProperty(s)?e[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}(e.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};rl("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(c=>{let h,f,p;for(const m of c){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const y=this.internalOutputShapes[a];let b;1===y[y.length-1]||this.lossFunctions[a]===xy?-1!==["accuracy","acc"].indexOf(m)?f=mO:-1!==["crossentropy","ce"].indexOf(m)&&(f=tne):this.lossFunctions[a]===vy?-1!==["accuracy","acc"].indexOf(m)?f=nne:-1!==["crossentropy","ce"].indexOf(m)&&(f=vO):-1!==["accuracy","acc"].indexOf(m)?f=gO:-1!==["crossentropy","ce"].indexOf(m)&&(f=bO),-1!==["accuracy","acc"].indexOf(m)?b="acc":-1!==["crossentropy","ce"].indexOf(m)&&(b="ce"),p=f,h=""+b}else p=cne(m),h=""+Iy(m);let g;rl(h,()=>{g=p}),i(a,h,g)}})(o[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const o=s.batchSize??32;ID(o);const a=this.standardizeUserDataXY(e,r,!0,o);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),Hr(this.testLoop(this.testFunction,l,o,s.verbose,s.steps))}finally{ol(a[0],e),ol(a[1],r)}}evaluateDataset(e,r){var s=this;return Q(function*(){return s.makeTestFunction(),function Ene(t,n,e){return CD.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,o="steps"){let i;if(null!=s){if(i=null,null!=r)throw new L(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new L(`Either the input data should have a defined shape, or ${o} shoud be specified.`);i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new L("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),i=this.retrieveSymbolicTensors(s?r:[r]),a=new ra;if(e instanceof un&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new L(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(null==c)throw new L(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const l=Gh(i,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=el(null,e.length);let s=e.length;for(const o of this.layers){const i=Array.isArray(o.output)?o.output:[o.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){const u=a.indexOf(e[l]);if(-1!==u&&(r[l]=i[u],s--),0===s)break}if(0===s)break}if(s>0){const o=[];throw r.forEach((i,a)=>{null==i&&o.push(e[a])}),new L(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(e,r=32,s=!1){return U(()=>{const o=this.checkNumSamples(e);if(s)throw new rt("Verbose predictLoop() is not implemented yet.");const i=_D(o,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)U(()=>{const h=qh(e,i[l][0],i[l][1]),f=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)f.push({key:this.inputs[m],value:h[m]});else f.push({key:this.inputs[0],value:h});const p=new ra(f);return Gh(this.outputs,p)}).forEach((c,d)=>a[d].push(c));return Hr(a.map(l=>Tn(l,0)))})}predict(e,r={}){const s=AO(e);FO(s,this.inputNames,this.feedInputShapes,!1);try{const o=r.batchSize??32;return ID(o),this.predictLoop(s,o)}finally{ol(s,e)}}predictOnBatch(e){FO(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,o){if(null==this.optimizer_)throw new zs("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];i.push(this.feedLossFns[a]===vy?l.slice(0,l.length-1).concat([1]):l)}if(function Ane(t,n,e){const r=Qi(t.map(o=>o.shape[0]));r.sort();const s=Qi(n.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new L(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(s.length>1)throw new L(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!zt(r,s))throw new L(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=$O(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=$O(r,this.feedOutputNames,i,!1,"target")),function Rne(t,n,e){const r=[by,xy,jh];for(let s=0;s<t.length;++s){const o=t[s],i=n[s],a=e[s];if(null!=i){if(i===jh&&1===o.shape[o.shape.length-1])throw new L(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const d=l[c],h=u[c];if(null!=h&&d!==h)throw new L(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&e[0].shape[0]%o!=0)throw new L(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,o,i=!0,a){var l=this;return Q(function*(){const[u,c]=l.standardizeUserDataXY(e,r,i,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=o){const h=SO(o,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield EO(c[f],null,h[f]))}return[u,c,d]})()}testLoop(e,r,s,o=0,i){return U(()=>{const a=this.checkNumSamples(r,s,i,"steps"),l=[];if(o>0)throw new rt("Verbose mode is not implemented yet.");if(null!=i)throw new rt("steps mode in testLoop() is not implemented yet");{const u=_D(a,s),c=Bs(mo(0,a));for(let d=0;d<u.length;++d){const h=u[d][0],f=u[d][1],p=sl(c,h,f-h),m=DD(r,p),g=e(m);if(0===d)for(let y=0;y<g.length;++y)l.push(Oe(0));for(let y=0;y<g.length;++y)l[y]=me(l[y],V(f-h,g[y]))}for(let d=0;d<l.length;++d)l[d]=Le(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const o=e[s];let i=o;BF(e,o)>1&&(i+=`_${BF(e.slice(0,s),o)}`),r.push(i)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const f=new ra(h),p=Gh(this.outputs,f,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let b=(0,this.lossFunctions[g])(o[g],p[g]);null!=i[g]&&(b=wne(b,i[g]));const v=gn(b);r.push(v),m=0===g?b:me(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=r[g];else{const v=this.metricsTensors[g][1];y=gn((0,this.metricsTensors[g][0])(o[v],p[v]))}ur(y),a.push(y)}return m=gn(m),this.calculateLosses().forEach(g=>{m=me(m,g)}),m},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>U(()=>{const r=[];let s;const o=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:o[c]});const l=new ra(a),u=Gh(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=gn((0,this.lossFunctions[c])(i[c],u[c]));s=0===c?h:me(s,h),r.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],f=gn((0,this.metricsTensors[c][0])(i[h],u[h]));r.push(f)}return r})}fit(e,r,s={}){var o=this;return Q(function*(){return function Tne(t,n,e){return ED.apply(this,arguments)}(o,e,r,s)})()}fitDataset(e,r){var s=this;return Q(function*(){return function Dne(t,n,e){return wD.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return Q(function*(){const o=yield s.standardizeUserData(e,r),i=o[0],a=o[1],u=s.makeTrainFunction()(i.concat(a)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return ut(u),Hr(c)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,o=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<o.length;++a)s&&!o[a].trainable||r.push({name:o[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=BC().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-BC().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Ii(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Ii(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const o of r){if("string"!=typeof s[o])throw new Error("Serialization of non-string loss is not supported.");e[o]=Ii(s[o])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Ii(Iy(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ii(Iy(e)));{const e={};for(const r in this.metrics)e[r]=Ii(Iy(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=Di(gD(e.optimizer_config));let o,i;if("string"==typeof e.loss)o=tl(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>tl(a));else if(null!=e.loss){o={};for(const a in e.loss)o[a]=tl(e.loss[a])}if(Array.isArray(e.metrics))i=e.metrics.map(a=>tl(a));else if(null!=e.metrics){i={};for(const a in e.metrics)i[a]=tl(e.metrics[a])}this.compile({loss:o,metrics:i,optimizer:s})}save(e,r){var s=this;return Q(function*(){if("string"==typeof e){const d=t2(e);if(0===d.length)throw new L(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new L(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new L("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=yield J$(s.getNamedWeights(r)),u={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.3.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){u.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield J$(yield s.optimizer.getWeights(),d);o.specs.push(...f),o.data=vC([o.data,h])}return null!=s.userDefinedMetadata&&(wO(s.userDefinedMetadata,s.name,!0),u.userDefinedMetadata=s.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)})()}setUserDefinedMetadata(e){wO(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return t.className="Model",t})();le(Mu),le((()=>{class t extends Mu{}return t.className="Functional",t})()),le((()=>{class t extends Mu{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:hy("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new L(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof t||e instanceof Mu;let s;if(r){if(s=e,1!==s.outputs.length)throw new L("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new L("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new L("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=function Pte(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new L("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=t.batchShape;null!=t.shape&&null==n&&(n=[null].concat(t.shape));let e=t.dtype;return null==e&&(e="float32"),new gy({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new L(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new L("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=cO(this.outputs[0])}this.inboundNodes=[],new my({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:el(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(jt(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Mu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new zs("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return Q(function*(){if(!s.built)throw new zs("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var o=this;return Q(function*(){if(!o.built)throw new zs("The model needs to be compiled before being used.");return o.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return Q(function*(){if(!s.built)throw new zs("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return Q(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},o=!1){let i,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new L("Legacy serialization format not supported yet.");i=r}else S(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof t))throw new rt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of i){const d=Di(u,void 0,o);o&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new L("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new L("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return t.className="Sequential",t})());class Zr extends Cu{getConfig(){return{}}}le((()=>{class t extends Zr{apply(e,r=1){return function Ite(t,n=1){if(1!==n)throw new rt(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return Ih(t)}(e,r)}}return t.className="elu",t})()),le((()=>{class t extends Zr{apply(e){return QC(e)}}return t.className="selu",t})()),le((()=>{class t extends Zr{apply(e){return bi(e)}}return t.className="relu",t})()),le((()=>{class t extends Zr{apply(e){return U(()=>Nh(6,bi(e)))}}return t.className="relu6",t})()),le((()=>{class t extends Zr{apply(e){return e}}return t.className="linear",t})()),le((()=>{class t extends Zr{apply(e){return Eu(e)}}return t.className="sigmoid",t})()),le((()=>{class t extends Zr{apply(e){return function _te(t){return U(()=>{const n=me(.5,V(.2,t));return Jr(n,0,1)})}(e)}}return t.className="hardSigmoid",t})()),le((()=>{class t extends Zr{apply(e){return kh(e)}}return t.className="softplus",t})()),le((()=>{class t extends Zr{apply(e){return function Dte(t){return U(()=>Le(t,Qn(t).add(1)))}(e)}}return t.className="softsign",t})()),le((()=>{class t extends Zr{apply(e){return nI(e)}}return t.className="tanh",t})());let OO=(()=>{class t extends Zr{apply(e,r=-1){return Hg(e,r)}}return t.className="softmax",t})();function sa(t){return t.getClassName()}function RD(t,n={}){return Lh(t,$s.getMap().classNameMap,n,"activation")}function oa(t){if(null==t){return RD({className:"linear",config:{}})}if("string"==typeof t){const n={};return n.className=t,n.config={},RD(n)}return t instanceof Zr?t:RD(t)}le(OO),le((()=>{class t extends Zr{apply(e,r=-1){return qC(e,r)}}return t.className="logSoftmax",t})()),le((()=>{class t extends Zr{apply(e,r=1){return U(()=>Eu(e.mul(r)).mul(e))}}return t.className="swish",t})());class MO extends Cu{}le((()=>{class t extends MO{constructor(e){super(),function $D(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return U(()=>{let r=An([1]);return this.hasL1&&(r=me(r,Pe(V(this.l1,Qn(e))))),this.hasL2&&(r=me(r,Pe(V(this.l2,Hh(e))))),r.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return t.className="L1L2",t})());const PO={l1l2:"L1L2"};function Gt(t){return eD(t)}function LO(t,n={}){return Lh(t,$s.getMap().classNameMap,n,"regularizer")}function on(t){return null==t?null:"string"==typeof t?LO({className:t in PO?PO[t]:t,config:{}}):t instanceof MO?t:LO(t)}function Pu(t,n,e){if("number"==typeof t)return el(t,n);if(t.length!==n)throw new L(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${t.length} elements.`);for(let r=0;r<n;++r){const s=t[r];if(!yte(s))throw new L(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t}function yo(t,n,e,r,s=1){if(null==t)return t;let i;return i="same"===e?t:t-(n+(n-1)*(s-1))+1,Math.floor((i+r-1)/r)}function _y(t,n,e,r){if(null==t)return null;if("valid"===r)t=t*n+ta([e-n,0]);else{if("same"!==r)throw new L(`Unsupport padding mode: ${r}.`);t*=n}return t}function OD(t,n){return U(()=>(Cn(n),"channelsFirst"===n?Ht(t,[0,2,3,1]):t))}function BO(t,n){return U(()=>(Cn(n),"channelsFirst"===n?Ht(t,[0,2,3,4,1]):t))}function MD(t,n,e,r=[1,1],s="valid",o,i,a=null){return U(()=>{if(null==o&&(o="channelsLast"),Cn(o),3!==t.rank&&4!==t.rank)throw new L(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==n.rank&&4!==n.rank)throw new L(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=OD(t,o);if("causal"===s)throw new rt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=P2({x:l,filter:n,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===o&&(l=Ht(l,[0,3,1,2])),l})}le((()=>{class t extends Et{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=ct(e);let s=bi(e);return null!=this.maxValue&&(s=Jr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ReLU",t})()),le((()=>{class t extends Et{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=ct(e);return Lg(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LeakyReLU",t})()),le((()=>{class t extends Et{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=sn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=on(e.alphaRegularizer),this.alphaConstraint=Wn(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new L(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=jt(e)).slice(1);if(null!=this.sharedAxes)for(const o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let o=1;o<e.length;++o)s[o]=e[o];this.inputSpec=[new hr({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=ct(e),Vg(e,this.alpha.read())}getConfig(){const e={alphaInitializer:dn(this.alphaInitializer),alphaRegularizer:Gt(this.alphaRegularizer),alphaConstraint:Hn(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return t.className="PReLU",t})()),le((()=>{class t extends Et{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new rt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=ct(e);return Ih(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ELU",t})()),le((()=>{class t extends Et{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=e.theta??this.DEFAULT_THETA}call(e,r){const s=ct(e);return s.mul(Vh(s.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ThresholdedReLU",t})()),le((()=>{class t extends Et{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new OO).apply,this.axis=e.axis??this.DEFAULT_AXIS}call(e,r){const s=ct(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Softmax",t})());class Sy extends Et{constructor(n,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Sy.verifyArgs(e),this.rank=n,nr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new rt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Pu(e.kernelSize,n,"kernelSize"),this.strides=Pu(e.strides??1,n,"strides"),this.padding=e.padding??"valid",xs(this.padding),this.dataFormat=e.dataFormat??"channelsLast",Cn(this.dataFormat),this.activation=oa(e.activation),this.useBias=e.useBias??!0,this.biasInitializer=sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Wn(e.biasConstraint),this.biasRegularizer=on(e.biasRegularizer),this.activityRegularizer=on(e.activityRegularizer),this.dilationRate=Pu(e.dilationRate??1,n,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new L(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new L(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new L(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(n){if(vs("kernelSize"in n,"required key 'kernelSize' not in config"),"number"!=typeof n.kernelSize&&!nD(n.kernelSize,"number",1,3))throw new L(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){const n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:sa(this.activation),useBias:this.useBias,biasInitializer:dn(this.biasInitializer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),biasConstraint:Hn(this.biasConstraint)},e=super.getConfig();return Object.assign(n,e),n}}class Lu extends Sy{constructor(n,e){super(n,e),this.kernel=null,Lu.verifyArgs(e),this.filters=e.filters,nr(this.filters,"filters"),this.kernelInitializer=sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Wn(e.kernelConstraint),this.kernelRegularizer=on(e.kernelRegularizer)}build(n){n=jt(n);const e="channelsFirst"===this.dataFormat?1:n.length-1;if(null==n[e])throw new L(`The channel dimension of the input should be defined. Found ${n[e]}`);const r=n[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(n,e){return U(()=>{let r;n=ct(n);const s=null==this.bias?null:this.bias.read(),o=VF(this.activation.getClassName());if(null!=o&&2===this.rank)r=MD(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)r=function zO(t,n,e,r=1,s="valid",o,i=1){return U(()=>{if(null==o&&(o="channelsLast"),Cn(o),3!==t.shape.length)throw new L(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==n.shape.length)throw new L(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new L(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===o&&(t=Ht(t,[0,2,1])),"causal"===s)throw new rt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=HC(t,n,r,"same"===s?"same":"valid","NWC",i);return null!=e&&(a=Lo(a,e)),a})}(n,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=MD(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new rt("convolutions greater than 3D are not implemented yet.");r=function VO(t,n,e,r=[1,1,1],s="valid",o,i){return U(()=>{if(null==o&&(o="channelsLast"),Cn(o),4!==t.rank&&5!==t.rank)throw new L(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==n.rank&&5!==n.rank)throw new L(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=BO(t,o);if("causal"===s)throw new rt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=k2(a,n,r,"same"===s?"same":"valid","NDHWC",i),null!=e&&(a=Lo(a,e)),"channelsFirst"===o&&(a=Ht(a,[0,4,1,2,3])),a})}(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=jt(n);const e=[],r="channelsLast"===this.dataFormat?n.slice(1,n.length-1):n.slice(2);for(let o=0;o<r.length;++o){const i=yo(r[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);e.push(i)}let s=[n[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const n={filters:this.filters,kernelInitializer:dn(this.kernelInitializer),kernelRegularizer:Gt(this.kernelRegularizer),kernelConstraint:Hn(this.kernelConstraint)},e=super.getConfig();return Object.assign(n,e),n}static verifyArgs(n){if(!("filters"in n)||"number"!=typeof n.filters||n.filters<1)throw new L(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}}let UO=(()=>{class t extends Lu{constructor(e){super(2,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!nD(e.kernelSize,"number",1,2))throw new L(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv2D",t})();le(UO),le((()=>{class t extends Lu{constructor(e){super(3,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new L(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv3D",t})()),le((()=>{class t extends UO{constructor(e){if(super(e),this.inputSpec=[new hr({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new L(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=jt(e)).length)throw new L("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new L("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new hr({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return U(()=>{let s=ct(e);if(4!==s.shape.length)throw new L(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const c=o[l],h=this.kernelSize[1],p=this.strides[1],y=[o[0],_y(o[a],this.strides[0],this.kernelSize[0],this.padding),_y(c,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=Ht(s,[0,2,3,1]));let b=jC(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Ht(b,[0,3,1,2])),null!=this.bias&&(b=Lo(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const r=(e=jt(e)).slice();let s,o,i;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3):(s=3,o=1,i=2);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[s]=this.filters,r[o]=_y(r[o],u,a,this.padding),r[i]=_y(r[i],c,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv2DTranspose",t})());let Pne=(()=>{class t extends Lu{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new L("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new L("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new L(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier??1,this.depthwiseInitializer=sn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=on(r.depthwiseRegularizer),this.depthwiseConstraint=Wn(r.depthwiseConstraint),this.pointwiseInitializer=sn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=on(r.pointwiseRegularizer),this.pointwiseConstraint=Wn(r.pointwiseConstraint)}build(e){if((e=jt(e)).length<this.rank+2)throw new L(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new L(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],o=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new hr({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return U(()=>{let s;if(e=ct(e),1===this.rank)throw new rt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Ht(e,[0,2,3,1])),s=O2(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Lo(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=Ht(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=dn(this.depthwiseInitializer),e.pointwiseInitializer=dn(this.pointwiseInitializer),e.depthwiseRegularizer=Gt(this.depthwiseRegularizer),e.pointwiseRegularizer=Gt(this.pointwiseRegularizer),e.depthwiseConstraint=Hn(this.depthwiseConstraint),e.pointwiseConstraint=Hn(this.pointwiseConstraint),e}}return t.className="SeparableConv",t})();function HO(t,n,e,r){if(Array.isArray(t)){if(null!=n||null!=e)throw new L("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(n=t.slice(1,t.length)),t=t[0]}function s(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:t,initialState:n=s(n),constants:e=s(e)}}function WO(t,n,e,r=!1,s,o,i=!1,a=!1){return U(()=>{const l=n.shape.length;if(l<3)throw new L(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(mo(2,l));if(n=Ht(n,u),null!=o)throw new rt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=s.asType("bool").asType("float32")).rank===l-1&&(s=Os(s,-1)),s=Ht(s,u)),r&&(n=vi(n,0),null!=s&&(s=vi(s,0)));const c=[];let d,h=e;const f=n.shape[0],p=fo(n);let m,g;null!=s&&(m=fo(s));for(let y=0;y<f;++y){const b=p[y],v=U(()=>t(b,h));if(null==s)d=v[0],h=v[1];else{const x=U(()=>{const w=m[y],_=gs(w).sub(w);return{output:v[0].mul(w).add(h[0].mul(_)),newStates:h.map((R,O)=>v[1][O].mul(w).add(R.mul(_)))}});d=x.output,h=x.newStates}a&&c.push(d)}return a&&(g=Ls(c,1)),[d,g,h]})}le((()=>{class t extends Pne{constructor(e){super(2,e)}}return t.className="SeparableConv2D",t})()),le((()=>{class t extends Lu{constructor(e){super(1,e),t.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!nD(e.kernelSize,"number",1,1))throw new L(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv1D",t})()),le((()=>{class t extends Et{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return U(()=>{if(e=ct(e),"channelsLast"===this.dataFormat){const s=uy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return uy(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=uy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return uy(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Cropping2D",t})()),le((()=>{class t extends Et{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size??this.DEFAULT_SIZE,this.dataFormat=e.dataFormat??"channelsLast",Cn(this.dataFormat),this.interpolation=e.interpolation??"nearest",function pte(t){nl(cte,"InterpolationFormat",t)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return U(()=>{let s=ct(e);const o=s.shape;if("channelsFirst"===this.dataFormat){s=Ht(s,[0,2,3,1]);const i=this.size[0]*o[2],a=this.size[1]*o[3],l="nearest"===this.interpolation?s.resizeNearestNeighbor([i,a]):s.resizeBilinear([i,a]);return Ht(l,[0,3,1,2])}{const i=this.size[0]*o[1],a=this.size[1]*o[2];return"nearest"===this.interpolation?s.resizeNearestNeighbor([i,a]):s.resizeBilinear([i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="UpSampling2D",t})()),le((()=>{class t extends Sy{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier??1,this.depthwiseInitializer=sn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Wn(e.depthwiseConstraint),this.depthwiseRegularizer=on(e.depthwiseRegularizer)}build(e){if((e=jt(e)).length<4)throw new L(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new L(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return U(()=>{let s=function Lne(t,n,e=[1,1],r="valid",s,o){return U(()=>{null==s&&(s="channelsLast"),Cn(s);let i=OD(t,s);if(4!==t.rank)throw new L(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==n.rank)throw new L(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return i=Ch(i,n,e,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===s&&(i=Ht(i,[0,3,1,2])),i})}(e=ct(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Lo(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=jt(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=yo("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=yo(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],o,i,a]:[e[0],i,a,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=dn(this.depthwiseInitializer),e.depthwiseRegularizer=Gt(this.depthwiseRegularizer),e.depthwiseConstraint=Hn(this.depthwiseRegularizer),e}}return t.className="DepthwiseConv2D",t})());let Kh=(()=>{class t extends Et{constructor(e){let r;if(super(e),null==e.cell)throw new L("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new qO({cells:e.cell}):e.cell,null==r.stateSize)throw new L("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences??!1,this.returnState=e.returnState??!1,this.goBackwards=e.goBackwards??!1,this._stateful=e.stateful??!1,this.unroll=e.unroll??!1,this.supportsMasking=!0,this.inputSpec=[new hr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return this.states_??mo(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null)}setStates(e){this.states_=e}computeOutputShape(e){lD(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let o;if(o=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const i=[];for(const a of r)i.push([e[0],a]);return[o].concat(i)}return o}computeMask(e,r){return U(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const o=this.states.map(i=>null);return[s].concat(o)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new rt("Constants support is not implemented in RNN yet.");lD(e)&&(e=e[0]);const s=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new hr({shape:[s,null,...o]});const i=[e[0]].concat(e.slice(2));let a;if(this.cell.build(i),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!zt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new L(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new hr({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){U(()=>{if(!this.stateful)throw new Mo("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new L("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>An([s,o])):[An([s,this.cell.stateSize])];else if(null==e)ut(this.states_),null!=this.keptStates&&(ut(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>An([s,o])):this.states_[0]=An([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new L(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):ut(this.states_);for(let o=0;o<this.states_.length;++o){const i=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,l=[s,a];if(!zt(i.shape,l))throw new L(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>ur(o.clone()))})}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=HO(e,s,o,this.numConstants);e=i.inputs,s=i.initialState,o=i.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new hr({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=o&&(r.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof zo){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return U(()=>{const s=null==r?null:r.mask,o=null==r?null:r.training;let i=null==r?null:r.initialState;e=ct(e),null==i&&(i=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new L(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:o},c=WO((m,g)=>{const y=this.cell.call([m].concat(g),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,o);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(e){return U(()=>{let r=An(e.shape);return r=Pe(r,[1,2]),r=Uh(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?iD(r,[1,s]):r):this.cell.stateSize>1?[iD(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===t.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign({},s,e,r)}static fromConfig(e,r,s={}){const i=Di(r.cell,s);return new e(Object.assign(r,{cell:i}))}}return t.className="RNN",t})();le(Kh);class Ey extends Et{}let jO=(()=>{class t extends Ey{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,nr(this.units,"units"),this.activation=oa(e.activation??this.DEFAULT_ACTIVATION),this.useBias=e.useBias??!0,this.kernelInitializer=sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=on(e.kernelRegularizer),this.recurrentRegularizer=on(e.recurrentRegularizer),this.biasRegularizer=on(e.biasRegularizer),this.kernelConstraint=Wn(e.kernelConstraint),this.recurrentConstraint=Wn(e.recurrentConstraint),this.biasConstraint=Wn(e.biasConstraint),this.dropout=Fu([1,ta([0,e.dropout??0])]),this.recurrentDropout=Fu([1,ta([0,e.recurrentDropout??0])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=jt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return U(()=>{if(2!==e.length)throw new L(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const o=r.training??!1;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ia({ones:()=>gs(e),rate:this.dropout,training:o})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ia({ones:()=>gs(s),rate:this.recurrentDropout,training:o}));const a=this.dropoutMask,l=this.recurrentDropoutMask;i=Po(null!=a?V(e,a):e,this.kernel.read()),null!=this.bias&&(i=Lo(i,this.bias.read())),null!=l&&(s=V(s,l));let u=me(i,Po(s,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:sa(this.activation),useBias:this.useBias,kernelInitializer:dn(this.kernelInitializer),recurrentInitializer:dn(this.recurrentInitializer),biasInitializer:dn(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:Hn(this.kernelConstraint),recurrentConstraint:Hn(this.recurrentConstraint),biasConstraint:Hn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,r)}}return t.className="SimpleRNNCell",t})();le(jO),le((()=>{class t extends Kh{constructor(e){e.cell=new jO(e),super(e)}call(e,r){return U(()=>(null!=this.cell.dropoutMask&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return t.className="SimpleRNN",t})());let GO=(()=>{class t extends Ey{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new L("GRUCell does not support reset_after parameter set to true.");this.units=e.units,nr(this.units,"units"),this.activation=oa(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=oa(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=on(e.kernelRegularizer),this.recurrentRegularizer=on(e.recurrentRegularizer),this.biasRegularizer=on(e.biasRegularizer),this.kernelConstraint=Wn(e.kernelConstraint),this.recurrentConstraint=Wn(e.recurrentConstraint),this.biasConstraint=Wn(e.biasConstraint),this.dropout=Fu([1,ta([0,e.dropout??0])]),this.recurrentDropout=Fu([1,ta([0,e.recurrentDropout??0])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=jt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return U(()=>{if(2!==e.length)throw new L(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training??!1;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ia({ones:()=>gs(e),rate:this.dropout,training:s,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ia({ones:()=>gs(o),rate:this.recurrentDropout,training:s,count:3}));const a=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(e=V(e,this.dropoutMask[0]));let d=Po(e,this.kernel.read());this.useBias&&(d=Lo(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=V(o,a[0]));const h=this.recurrentKernel.read(),[f,p]=ys(h,[2*this.units,this.units],h.rank-1),m=Po(o,f),[g,y,b]=ys(d,3,d.rank-1),[v,x]=ys(m,2,m.rank-1);l=this.recurrentActivation.apply(me(g,v)),u=this.recurrentActivation.apply(me(y,x));const w=Po(V(u,o),p);c=this.activation.apply(me(b,w));const _=me(V(l,o),V(me(1,yn(l)),c));return[_,_]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:sa(this.activation),recurrentActivation:sa(this.recurrentActivation),useBias:this.useBias,kernelInitializer:dn(this.kernelInitializer),recurrentInitializer:dn(this.recurrentInitializer),biasInitializer:dn(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:Hn(this.kernelConstraint),recurrentConstraint:Hn(this.recurrentConstraint),biasConstraint:Hn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,r)}}return t.className="GRUCell",t})();le(GO),le((()=>{class t extends Kh{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new GO(e),super(e)}call(e,r){return U(()=>(null!=this.cell.dropoutMask&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="GRU",t})());let PD=(()=>{class t extends Ey{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,nr(this.units,"units"),this.activation=oa(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=oa(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=on(e.kernelRegularizer),this.recurrentRegularizer=on(e.recurrentRegularizer),this.biasRegularizer=on(e.biasRegularizer),this.kernelConstraint=Wn(e.kernelConstraint),this.recurrentConstraint=Wn(e.recurrentConstraint),this.biasConstraint=Wn(e.biasConstraint),this.dropout=Fu([1,ta([0,e.dropout??0])]),this.recurrentDropout=Fu([1,ta([0,e.recurrentDropout??0])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let o;if(e=jt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;o=new((r=class extends Us{apply(u,c){const d=i.apply([a]),h=(new QF).apply([a]),f=i.apply([2*a]);return YF(YF(d,h),f)}}).className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return U(()=>{const s=r.training??!1;if(3!==e.length)throw new L(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ia({ones:()=>gs(e),rate:this.dropout,training:s,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ia({ones:()=>gs(o),rate:this.recurrentDropout,training:s,count:4}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=V(e,this.dropoutMask[0]));let f=Po(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=V(o,l[0])),f=me(f,Po(o,this.recurrentKernel.read())),this.useBias&&(f=Lo(f,this.bias.read()));const[p,m,g,y]=ys(f,4,f.rank-1);u=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(m),d=me(V(c,i),V(u,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const b=V(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:sa(this.activation),recurrentActivation:sa(this.recurrentActivation),useBias:this.useBias,kernelInitializer:dn(this.kernelInitializer),recurrentInitializer:dn(this.recurrentInitializer),biasInitializer:dn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:Hn(this.kernelConstraint),recurrentConstraint:Hn(this.recurrentConstraint),biasConstraint:Hn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,r)}}return t.className="LSTMCell",t})();le(PD),le((()=>{class t extends Kh{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new PD(e),super(e)}call(e,r){return U(()=>(null!=this.cell.dropoutMask&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="LSTM",t})());let qO=(()=>{class t extends Ey{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return U(()=>{let s=e.slice(1);const o=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?o.push(s.splice(0,l.stateSize.length)):o.push(s.splice(0,1));o.reverse();const i=[];let a;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];s=o[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=u.call(a,r),i.push(a.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;lD(e)&&(e=e[0]),this.cells.forEach((s,o)=>{rl(`RNNCell_${o}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),o={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign({},e,o)}static fromConfig(e,r,s={}){const o=[];for(const i of r.cells)o.push(Di(i,s));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return uD(e)}setWeights(e){const r=[];for(const s of this.cells){const i=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],i[a]])}cD(r)}}return t.className="StackedRNNCells",t})();function ia(t){const{ones:n,rate:e,training:r=!1,count:s=1}=t,o=()=>ZF(n(),e),i=()=>Wh(o,n,r);return!s||s<=1?ur(i().clone()):Array(s).fill(void 0).map(i).map(l=>ur(l.clone()))}le(qO);let zne=(()=>{class t extends Kh{constructor(e){if(e.unroll)throw new rt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new rt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new hr({ndim:5})]}call(e,r){return U(()=>{if(null!=this.cell.dropoutMask&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new L("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return U(()=>{const{stateSize:r}=this.cell,o=this.computeSingleOutputShape(e.shape),a=An([o[0],...o.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){U(()=>{if(!this.stateful)throw new Mo("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)];if(null==s[0])throw new L("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>An(i)):[An(i)];else if(null==e)ut(this.states_),null!=this.keptStates&&(ut(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>An(i)):this.states_[0]=An(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new L(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):ut(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],c=i;if(!zt(u.shape,c))throw new L(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>ur(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:o,padding:i,strides:a,dilationRate:l}=this.cell,u="channelsFirst"===r,d=e[u?4:3],h=yo(e[u?3:2],o[0],i,a[0],l[0]),f=yo(d,o[1],i,a[1],l[1]);return[...e.slice(0,2),...u?[s,h,f]:[h,f,s]]}}return t.className="ConvRNN2D",t})(),KO=(()=>{class t extends PD{constructor(e){const{filters:r,kernelSize:s,strides:o,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign({},e,{units:r})),this.filters=r,nr(this.filters,"filters"),this.kernelSize=Pu(s,2,"kernelSize"),this.kernelSize.forEach(u=>nr(u,"kernelSize")),this.strides=Pu(o||1,2,"strides"),this.strides.forEach(u=>nr(u,"strides")),this.padding=i||"valid",xs(this.padding),this.dataFormat=a||"channelsLast",Cn(this.dataFormat),this.dilationRate=Pu(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>nr(u,"dilationRate"))}build(e){var r;e=jt(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new L(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((r=class extends Us{apply(f,p){return oD([c.apply([d]),yi([d]),c.apply([2*d])])}}).className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return U(()=>{if(3!==e.length)throw new L(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,o=e[0],i=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ia({ones:()=>gs(o),rate:this.dropout,training:s,count:4}));const u=this.dropoutMask,c=(de,ge,pe)=>ge&&ge[pe]?V(ge[pe],de):de;let d=c(o,u,0),h=c(o,u,1),f=c(o,u,2),p=c(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ia({ones:()=>gs(i),rate:this.recurrentDropout,training:s,count:4}));const m=this.recurrentDropoutMask;let g=c(i,m,0),y=c(i,m,1),b=c(i,m,2),v=c(i,m,3);const[w,_,D,A]=ys(this.kernel.read(),4,3),[R,O,j,K]=this.useBias?ys(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,R,this.padding),h=this.inputConv(h,_,O,this.padding),f=this.inputConv(f,D,j,this.padding),p=this.inputConv(p,A,K,this.padding);const[G,Z,q,Y]=ys(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,G),y=this.recurrentConv(y,Z),b=this.recurrentConv(b,q),v=this.recurrentConv(v,Y);const re=this.recurrentActivation.apply(me(d,g)),ee=this.recurrentActivation.apply(me(h,y)),se=me(V(ee,a),V(re,this.activation.apply(me(f,b)))),ue=V(this.recurrentActivation.apply(me(p,v)),this.activation.apply(se));return[ue,ue,se]})}getConfig(){const s=function(t,n){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(t);s<r.length;s++)n.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(e[r[s]]=t[r[s]])}return e}(super.getConfig(),["units"]);return Object.assign({},s,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(e,r,s,o){const i=Zi(e,r,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?Lo(i,s,this.dataFormat):i}recurrentConv(e,r){return Zi(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return t.className="ConvLSTM2DCell",t})();le(KO),le((()=>{class t extends zne{constructor(e){const r=new KO(e);super(Object.assign({},e,{cell:r}))}static fromConfig(e,r){return new e(r)}}return t.className="ConvLSTM2D",t})());let XO=(()=>{class t extends Et{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(this.noiseShape[o]??r[o]);return s}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=ct(e);if(0<this.rate&&this.rate<1){const o=r.training??!1,i=this.getNoiseShape(s);return Wh(()=>ZF(s,this.rate,i,this.seed),()=>s,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return t.className="Dropout",t})();le(XO),le((()=>{class t extends XO{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return t.className="SpatialDropout1D",t})()),le((()=>{class t extends Et{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,nr(this.units,"units"),this.activation=oa(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Wn(e.kernelConstraint),this.biasConstraint=Wn(e.biasConstraint),this.kernelRegularizer=on(e.kernelRegularizer),this.biasRegularizer=on(e.biasRegularizer),this.activityRegularizer=on(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=jt(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=jt(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=ct(e),o=VF(this.activation.getClassName());let i;return null!=o?i=Po(s,this.kernel.read(),o,this.bias?this.bias.read():null):(i=Po(s,this.kernel.read()),null!=this.bias&&(i=Lo(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:sa(this.activation),useBias:this.useBias,kernelInitializer:dn(this.kernelInitializer),biasInitializer:dn(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:Hn(this.kernelConstraint),biasConstraint:Hn(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dense",t})()),le((()=>{class t extends Et{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=jt(e);for(const r of e.slice(1))if(null==r)throw new L(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ea(e,1)]}call(e,r){return U(()=>{this.invokeCallHook(e,r);let s=ct(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const o=[0];for(let i=2;i<s.rank;++i)o.push(i);o.push(1),s=s.transpose(o)}return function Cte(t){if(t.rank<=1)throw new L(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const n=[t.shape[0],ea(t.shape,1)];return t.reshape(n)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return t.className="Flatten",t})()),le((()=>{class t extends Et{constructor(e){super(e),this.supportsMasking=!0,this.activation=oa(e.activation)}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=ct(e);return this.activation.apply(s)})}getConfig(){const e={activation:sa(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Activation",t})()),le((()=>{class t extends Et{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return U(()=>function xte(t,n){return U(()=>{if(2!==t.shape.length)throw new L(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return iD(Uh(t,1),[1,n,1])})}(e=ct(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return t.className="RepeatVector",t})()),le((()=>{class t extends Et{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",o=r.slice();let i=1,a=null;for(let u=0;u<o.length;++u){const c=o[u];if(this.isUnknown(c)){if(null!==a)throw new L("Can only specifiy one unknown dimension.");a=u}else i*=c}const l=ea(e);if(null!==a){if(0===i||l%i!=0)throw new L(s);o[a]=l/i}else if(l!==i)throw new L(s);return o}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=ct(e),o=s.shape,i=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return s.reshape(i)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Reshape",t})()),le((()=>{class t extends Et{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=mo(1,e.dims.length+1);if(!zt(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new hr({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=jt(e)).slice();return this.dims.forEach((s,o)=>{r[o+1]=e[s]}),r}call(e,r){return Ht(ct(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Permute",t})()),le((()=>{class t extends Et{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?e.maskValue??0:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=ct(e);return $g(Su(s,this.maskValue),-1)}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=ct(e),a=$g(Su(s,this.maskValue),-1,!0);return s.mul(a.asType(s.dtype))})}}return t.className="Masking",t})()),le((()=>{class t extends Et{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(Yt(e.inputLength))}this.inputDim=e.inputDim,nr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,nr(this.outputDim,"outputDim"),this.embeddingsInitializer=sn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=on(e.embeddingsRegularizer),this.activityRegularizer=on(e.activityRegularizer),this.embeddingsConstraint=Wn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return U(()=>this.maskZero?(e=ct(e),Su(e,St(e))):null)}computeOutputShape(e){if(e=jt(e),null==this.inputLength)return[...e,this.outputDim];const r=Yt(this.inputLength);if(r.length!==e.length-1)throw new L(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let o=0;o<r.length;++o){const i=r[o],a=e[o+1];if(null!=i&&null!=a&&i!==a)throw new L(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==i&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return U(()=>{this.invokeCallHook(e,r);let s=ct(e);return"int32"!==s.dtype&&(s=Vh(s,"int32")),JF(this.embeddings.read(),s.as1D()).reshape(jt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:dn(this.embeddingsInitializer),embeddingsRegularizer:Gt(this.embeddingsRegularizer),activityRegularizer:Gt(this.activityRegularizer),embeddingsConstraint:Hn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Embedding",t})());class il extends Et{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new rt}computeElementwiseOpOutputShape(n,e){if(null==n||null==e)return null;if(n.length<e.length)return this.computeElementwiseOpOutputShape(e,n);if(0===e.length)return n;const r=n.slice(0,n.length-e.length);for(let s=0;s<e.length;++s){const o=n[n.length-e.length+s],i=e[s];if(null==o||null==i||o<0||i<0)r.push(null);else if(1===o)r.push(i);else if(1===i)r.push(o);else{if(o!==i)throw new L("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(e));r.push(o)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[jt(n)]),n.length<2)throw new L(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let e=[];for(const o of n)null!=o&&null!==o[0]&&e.push(o[0]);if(e=Qi(e),e.length>1)throw new L(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=null==n[0]?null:n[0].slice(1);for(let o=1;o<n.length;++o){const i=null==n[o]?null:n[o].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=n.map(o=>o.length);this.reshapeRequired=-1!==n.indexOf(null)||1!==Qi(s).length}call(n,e){return U(()=>{if(this.reshapeRequired){const r=[],s=n.map(o=>o.rank);if(-1===s.indexOf(null)){const o=ta(s);for(let i of n){const a=i.rank;for(let l=0;l<o-a;++l)i=Uh(i,1);r.push(i)}return this.mergeFunction(r)}{let o=!1;for(const l of n){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let f=l.reshape([d].concat(ea(c.slice(1))));f=Ht(f,[1,0]),f=f.reshape(h),r.push(f),o=!0}else if(u>1){const c=mo(1,u).concat([0]);r.push(Ht(l,c)),o=!0}else r.push(l)}let i=this.mergeFunction(r);const a=i.rank;if(o)if(null==a){const l=i.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));i=Ht(i.reshape([-1,c]),[1,0]).reshape(d)}else if(a>1){const l=[a-1].concat(mo(0,a-1));i=Ht(i,l)}return i}}return this.mergeFunction(n)})}computeOutputShape(n){let e;e=null==n[0]?null:n[0].slice(1);for(let s=1;s<n.length;++s){const o=null==n[s]?null:n[s].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let r=[];for(const s of n)null!=s&&null!==s[0]&&r.push(s[0]);return r=Qi(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(n,e){return U(()=>{if(null==e)return null;if(!Array.isArray(e))throw new L("`mask` should be an Array");if(!Array.isArray(n))throw new L("`inputs` should be an Array");if(e.length!==n.length)throw new L(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:Os(s,0)))[0];for(let s=1;s<e.length-1;++s)r=Oo(r,e[s]);return r})}}function Xh(t,n){for(;t<0;)t+=n;return t}function Yh(t,n,e,r,s,o=.001){let i;if(2===t.rank)i=G7(t,n,e,r,s,o);else if(3===t.rank)i=K7(t,n,e,r,s,o);else{if(4!==t.rank)throw new rt(`batchNormalization is not implemented for array of rank ${t.rank} yet`);i=Y7(t,n,e,r,s,o)}return i}function Ny(t,n,e,r,s,o){return U(()=>{let i;Cn(s),WF(o),xs(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),t=OD(t,s);const a="same"===r?"same":"valid";return i="max"===o?Bg(t,n,e,a):Mg(t,n,e,a),"channelsFirst"===s&&(i=Ht(i,[0,3,1,2])),i})}function YO(t,n,e,r,s,o){return U(()=>{let i;Cn(s),WF(o),xs(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),t=BO(t,s);const a="same"===r?"same":"valid";return i="max"===o?R2(t,n,e,a):T2(t,n,e,a),"channelsFirst"===s&&(i=Ht(i,[0,4,1,2,3])),i})}le((()=>{class t extends il{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=me(r,e[s]);return r})}}return t.className="Add",t})()),le((()=>{class t extends il{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=V(r,e[s]);return r})}}return t.className="Multiply",t})()),le((()=>{class t extends il{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=me(r,e[s]);return V(1/e.length,r)})}}return t.className="Average",t})()),le((()=>{class t extends il{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=gi(r,e[s]);return r})}}return t.className="Maximum",t})()),le((()=>{class t extends il{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Nh(r,e[s]);return r})}}return t.className="Minimum",t})()),le((()=>{class t extends il{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=e.axis??this.DEFAULT_AXIS,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new L("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const o of e)if(null!=o){r=!1;break}if(r)return;const s=[];for(let o=0;o<e.length;++o){const i=e[o].slice();i.splice(this.axis,1);let a=!1;for(const l of s)if(zt(l,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new L("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return U(()=>oD(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new L("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const i of r.slice(1)){if(null==s[o]||null==i[o]){s[o]=null;break}s[o]+=i[o]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new L("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new L("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new L(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return U(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const o=[];for(let a=0;a<e.length;++a)o.push(null==r[a]?gs(e[a]).asType("bool"):r[a].rank<e[a].rank?Os(r[a],-1):r[a]);const i=Tn(o,this.axis);return zC(i,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Concatenate",t})()),le((()=>{class t extends il{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize??!1,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new rt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);if(r[o[0]]!==s[o[1]])throw new L(`Dimension incompatibility: ${r[o[0]]} !== ${s[o[1]]}`)}mergeFunction(e){if(2!==e.length)throw new L(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let o,r=e[0],s=e[1];return o=Array.isArray(this.axes)?this.axes.map((i,a)=>Xh(i,e[a].shape.length)):[Xh(this.axes,r.shape.length),Xh(this.axes,s.shape.length)],this.normalize&&(r=yy(r,o[0]),s=yy(s,o[1])),function Vne(t,n,e){if(t.shape.length>3||n.shape.length>3)throw new rt("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),S(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===t.dtype||"complex64"===n.dtype)throw new rt("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,s=n.shape.length;null==e&&(e=[r-1,s-2]);const o=e;return U(()=>{let i,a;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);n=n.reshape(n.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);t=t.reshape(t.shape.concat(l))}else i=0;if(a=2===t.shape.length&&2===n.shape.length?o[0]===o[1]?t.mul(n).sum(o[0]):t.transpose([1,0]).mul(n).sum(o[1]):t.matMul(n,o[0]!==t.shape.length-1,o[1]===n.shape.length-1),i>0){let l;l=r>s?r+s-3:r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=a.squeeze(u)}return 1===a.shape.length&&(a=a.expandDims(1)),a})}(r,s,o)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[Xh(this.axes,e.length),Xh(this.axes,r.length)],s}computeOutputShape(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new rt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);r.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const i=r.concat(s);return 1===i.length&&i.push(1),i}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dot",t})()),le((()=>{class t extends Et{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=ct(e);return Wh(()=>cy(s.shape,0,this.stddev).add(s),()=>s,r.training||!1)})}}return t.className="GaussianNoise",t})()),le((()=>{class t extends Et{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=ct(e);return this.rate>0&&this.rate<1?Wh(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return s.mul(cy(s.shape,1,i))},()=>s,r.training||!1):s})}}return t.className="GaussianDropout",t})()),le((()=>{class t extends Et{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ct(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return U(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Wh(()=>{const i=ct(e),u=-1.7580993408473766;let c=Ya(Th(s),this.rate);c=Vh(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate;return i.mul(c).add(c.add(-1).mul(u)).mul(d).add(h)},()=>ct(e),r.training||!1)}return e})}}return t.className="AlphaDropout",t})()),le((()=>{class t extends Et{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis??-1,this.momentum=e.momentum??.99,this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=sn(e.betaInitializer||"zeros"),this.gammaInitializer=sn(e.gammaInitializer||"ones"),this.movingMeanInitializer=sn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=sn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Wn(e.betaConstraint),this.gammaConstraint=Wn(e.gammaConstraint),this.betaRegularizer=on(e.betaRegularizer),this.gammaRegularizer=on(e.gammaRegularizer)}build(e){e=jt(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new L(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new hr({ndim:e.length,axes:{[r]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return U(()=>{const s=r.training??!1,o=ct(e),i=o.shape,a=i.length,l=mo(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);const c=el(1,a);c[u]=i[u];const d=l.slice();d.sort();const h=!zt(d,mo(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const v=this.movingMean.read().reshape(c),x=this.movingVariance.read().reshape(c),w=this.center?this.beta.read().reshape(c):null,_=this.scale?this.gamma.read().reshape(c):null;return Yh(o,v,x,w,_,this.epsilon)}return Yh(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,m,g]=function Wne(t,n,e,r,s=.001){return zt(r.slice().sort(),mo(0,t.rank-1))?function Une(t,n,e,r,s=.001){return U(()=>{const o=XC(t,r),i=o.mean,a=o.variance;return[Yh(t,i,a,e,n,s),i,a]})}(t,n,e,r,s):function Hne(t,n,e,r,s=.001){return U(()=>{const o=XC(t,r),i=o.mean,a=o.variance,l=[];for(const p of mo(0,t.rank))-1!==r.indexOf(p)?l.push(1):l.push(t.shape[p]);const u=i.reshape(l),c=a.reshape(l),d=null==n?null:n.reshape(l),h=null==e?null:e.reshape(l);return[Yh(t,u,c,h,d,s),i,a]})}(t,n,e,r,s)}(o,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(v,x,w)=>{U(()=>{const _=1-w,D=v.read(),A=D.sub(x).mul(_);v.write(D.sub(A))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:dn(this.betaInitializer),gammaInitializer:dn(this.gammaInitializer),movingMeanInitializer:dn(this.movingMeanInitializer),movingVarianceInitializer:dn(this.movingVarianceInitializer),betaRegularizer:Gt(this.betaRegularizer),gammaRegularizer:Gt(this.gammaRegularizer),betaConstraint:Hn(this.betaConstraint),gammaConstraint:Hn(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BatchNormalization",t})()),le((()=>{class t extends Et{constructor(e){if(null==e&&(e={}),super(e),this.axis=e.axis??-1,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=sn(e.betaInitializer||"zeros"),this.gammaInitializer=sn(e.gammaInitializer||"ones"),this.betaRegularizer=on(e.betaRegularizer),this.gammaRegularizer=on(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=jt(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(const i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Qi(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=ct(e),o=s.shape,i=o.length;return U(()=>{let{mean:l,variance:u}=XC(s,this.axis,!0);const c=el(1,i);for(const g of this.axis)c[g]=o[g];const d=g=>null!=g&&g.shape.length!==i&&this.axis!==[i-1]?g.reshape(c):g;let h=d(this.gamma.read()),f=d(this.beta.read());const p=[],m=[];for(let g=0;g<i;++g)-1!==this.axis.indexOf(g)?(p.push(o[g]),m.push(1)):(p.push(1),m.push(o[g]));return l=l.tile(p),u=u.tile(p),h=h.tile(m),f=f.tile(m),Yh(s,l,u,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:dn(this.betaInitializer),gammaInitializer:dn(this.gammaInitializer),betaRegularizer:Gt(this.betaRegularizer),gammaRegularizer:Gt(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LayerNormalization",t})()),le((()=>{class t extends Et{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=e.dataFormat??"channelsLast",null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new L(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new L(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new L(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new hr({ndim:4})]}computeOutputShape(e){let r,s;return e=jt(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return U(()=>function jne(t,n,e){return U(()=>{if(4!==t.rank)throw new L(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new L("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new L(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],zg(t,r)})}(ct(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ZeroPadding2D",t})());class JO extends Et{constructor(n){if(null==n.poolSize&&(n.poolSize=2),super(n),"number"==typeof n.poolSize)this.poolSize=[n.poolSize];else{if(!Array.isArray(n.poolSize)||1!==n.poolSize.length||"number"!=typeof n.poolSize[0])throw new L(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);this.poolSize=n.poolSize}if(nr(this.poolSize,"poolSize"),null==n.strides)this.strides=this.poolSize;else if("number"==typeof n.strides)this.strides=[n.strides];else{if(!Array.isArray(n.strides)||1!==n.strides.length||"number"!=typeof n.strides[0])throw new L(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);this.strides=n.strides}nr(this.strides,"strides"),this.padding=n.padding??"valid",xs(this.padding),this.inputSpec=[new hr({ndim:3})]}computeOutputShape(n){const e=yo((n=jt(n))[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],e,n[2]]}call(n,e){return U(()=>{this.invokeCallHook(n,e),n=Uh(ct(n),2);const r=this.poolingFunction(ct(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Nu(r,[2])})}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(n,e),n}}le((()=>{class t extends JO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Cn(i),xs(o),Ny(e,r,s,o,i,"max")}}return t.className="MaxPooling1D",t})()),le((()=>{class t extends JO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Cn(i),xs(o),Ny(e,r,s,o,i,"avg")}}return t.className="AveragePooling1D",t})());class ZO extends Et{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(2!==n.strides.length)throw new L(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];nr(this.poolSize,"poolSize"),nr(this.strides,"strides"),this.padding=n.padding??"valid",this.dataFormat=n.dataFormat??"channelsLast",Cn(this.dataFormat),xs(this.padding),this.inputSpec=[new hr({ndim:4})]}computeOutputShape(n){n=jt(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2];return e=yo(e,this.poolSize[0],this.padding,this.strides[0]),r=yo(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r]:[n[0],e,r,n[3]]}call(n,e){return U(()=>(this.invokeCallHook(n,e),this.poolingFunction(ct(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}le((()=>{class t extends ZO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Cn(i),xs(o),Ny(e,r,s,o,i,"max")}}return t.className="MaxPooling2D",t})()),le((()=>{class t extends ZO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Cn(i),xs(o),Ny(e,r,s,o,i,"avg")}}return t.className="AveragePooling2D",t})());class QO extends Et{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(3!==n.strides.length)throw new L(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];nr(this.poolSize,"poolSize"),nr(this.strides,"strides"),this.padding=n.padding??"valid",this.dataFormat=n.dataFormat??"channelsLast",Cn(this.dataFormat),xs(this.padding),this.inputSpec=[new hr({ndim:5})]}computeOutputShape(n){n=jt(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2],s="channelsFirst"===this.dataFormat?n[4]:n[3];return e=yo(e,this.poolSize[0],this.padding,this.strides[0]),r=yo(r,this.poolSize[1],this.padding,this.strides[1]),s=yo(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r,s]:[n[0],e,r,s,n[4]]}call(n,e){return U(()=>(this.invokeCallHook(n,e),this.poolingFunction(ct(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}le((()=>{class t extends QO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Cn(i),xs(o),YO(e,r,s,o,i,"max")}}return t.className="MaxPooling3D",t})()),le((()=>{class t extends QO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Cn(i),xs(o),YO(e,r,s,o,i,"avg")}}return t.className="AveragePooling3D",t})());class eM extends Et{constructor(n){super(n),this.inputSpec=[new hr({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,e){throw new rt}}le((()=>{class t extends eM{constructor(e){super(e||{})}call(e,r){return U(()=>{const s=ct(e);return gn(s,1)})}}return t.className="GlobalAveragePooling1D",t})()),le((()=>{class t extends eM{constructor(e){super(e||{})}call(e,r){return U(()=>{const s=ct(e);return Ps(s,1)})}}return t.className="GlobalMaxPooling1D",t})());class tM extends Et{constructor(n){super(n),this.dataFormat=n.dataFormat??"channelsLast",Cn(this.dataFormat),this.inputSpec=[new hr({ndim:4})]}computeOutputShape(n){return"channelsLast"===this.dataFormat?[n[0],n[3]]:[n[0],n[1]]}call(n,e){throw new rt}getConfig(){const n={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}le((()=>{class t extends tM{call(e,r){return U(()=>{const s=ct(e);return gn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalAveragePooling2D",t})()),le((()=>{class t extends tM{call(e,r){return U(()=>{const s=ct(e);return Ps(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalMaxPooling2D",t})());class nM extends Et{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(n){null!=this.layer&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){const n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(n,e),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,e,r={}){const o=Di(e.layer,r);delete e.layer;const i={layer:o};return Object.assign(i,e),new n(i)}}le((()=>{class t extends nM{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=jt(e)).length<3)throw new L(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=jt(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return U(()=>WO((a,l)=>[ct(this.layer.call(a,r)),[]],e=ct(e),[],!1,null,null,!1,!0)[1])}}return t.className="TimeDistributed",t})()),le((()=>{class t extends nM{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=Di(s),r.goBackwards=!0!==r.goBackwards;const o={};if(o.className=e.layer.getClassName(),o.config=r,this.backwardLayer=Di(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Gne(t){nl(fte,"BidirectionalMergeMode",t)}(this.mergeMode),e.weights)throw new rt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,o,i,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(i=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,o=[s]):o=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?o.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Hr(o)}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=HO(e,s,o,this.numConstants);if(e=i.inputs,s=i.initialState,o=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==o)return super.apply(e,r);const a=[],l=[];if(null!=s){const c=s.length;if(c%2>0)throw new L("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new hr({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=o)throw new rt("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof zo;for(const c of a)if(c instanceof zo!==u)throw new L("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return U(()=>{const s=r.initialState;let o,i,a,l;if(null==s)o=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{const u=s.slice(0,s.length/2),c=s.slice(s.length/2);o=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:c}))}return this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(i.slice(1))),o=o[0],i=i[0]),this.returnSequences&&(i=vi(i,1)),"concat"===this.mergeMode?l=oD([o,i]):"sum"===this.mergeMode?l=me(o,i):"ave"===this.mergeMode?l=V(.5,me(o,i)):"mul"===this.mergeMode?l=V(o,i):null==this.mergeMode&&(l=[o,i]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){rl(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),rl(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=Di(r.layer);if(delete r.layer,null!=r.numConstants)throw new rt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=r;return o.layer=s,new e(o)}}return t.className="Bidirectional",t})());var aM,Hs=(()=>{return(t=Hs||(Hs={}))[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",Hs;var t})();!function(t){let n;var e;(e=n=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(aM||(aM={}));const WD={};function lM(t){return WD[t]}function C(t,n,e,r,s){const o=n.inputParams[t];if(o&&void 0!==o.inputIndexStart){const a=o.inputIndexStart,l=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?a+1:o.inputIndexEnd;if("tensor"===o.type)return Wr(n.inputNames[o.inputIndexStart],e,r,s);if("tensors"===o.type)return n.inputNames.slice(a,l).map(h=>Wr(h,e,r,s));const u=Wr(n.inputNames.slice(a)[0],e,r,s),c=u.dataSync();return"number"===o.type?c[0]:Rs(u.shape,c)}const i=n.attrParams[t];return i&&i.value}function Wr(t,n,e,r){const[s,o]=Qr(t);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const i=e.currentContextIds.find(a=>!!n[ky(s,a)]);return void 0!==i?n[ky(s,i)][o]:void 0}function _i(t,n){const[e,r]=Qr(t);return[ky(e,n&&n.currentContextId),r]}function ky(t,n){return n?`${t}-${n}`:t}function Qr(t){const n=t.split(":");return 1===n.length?[t,0]:[n[0],Number(n[n.length-1])]}function Ay(t,n,e){let r=C("pad",t,n,e);if("explicit"===r){r=C("explicitPaddings",t,n,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[2*o],s[o][1]=r[2*o+1];return s}return r}function Si(t){return t.kept?t:Ga(t)}const Zne=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Qne=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ere=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],tre=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],nre=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],rre=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],sre=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],ore=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],ire=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],are=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],lre=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ure=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cre=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],dre=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],hre=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],fre=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],pre=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class uM{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[Qe,be,Ce,ie,P,I,k,z,N,$,H,et,Mt,Dt,Dn,_n,E].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(n,e={}){const s=[],o=[],i=[],a=n.node.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):"Const"===g.op?o.push(m[g.name]):(null==g.input||0===g.input.length)&&i.push(m[g.name]),m),{});let l=[];const u=[];let c={},d={};null!=e&&(c=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const h=Object.keys(a);h.forEach(m=>{const g=a[m];g.inputNames.forEach(y=>{const[b]=_i(y);g.inputs.push(a[b]),a[b].children.push(g)})}),0===Object.keys(d).length?h.forEach(m=>{const g=a[m];0===g.children.length&&u.push(g)}):Object.keys(d).forEach(m=>{const[g]=_i(m),y=a[g];null!=y&&(y.signatureKey=d[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=_i(m),y=a[g];y&&(y.signatureKey=c[m],l.push(y))}):l=s;let f={};null!=n.library&&null!=n.library.function&&(f=n.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:u,weights:o,placeholders:s,signature:e,functions:f};return i.length>0&&(p.initNodes=i),p}mapSignatureEntries(n){return Object.keys(n||{}).reduce((e,r)=>(e[n[r].name]=r,e),{})}mapNode(n){const e=lM(n.op)||this.opMappers[n.op]||{};null==n.attr&&(n.attr={});const r={name:n.name,op:n.op,category:e.category,inputNames:(n.input||[]).map(s=>s.startsWith("^")?s.substr(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:n.attr};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=jD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=jD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=QD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=QD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=qD(n.attr,o.tfName,o.defaultValue||0),void 0===a&&o.tfDeprecatedName&&(a=qD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=ZD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=ZD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=GD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=GD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=t_(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=t_(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=JD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=JD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=e_(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=e_(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=XD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=XD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=YD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=YD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=dM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=dM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${n.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(n){const e=n.nodeDef,s=[];let o={};null!=e&&(o=e.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&s.push(d[h.name]),d),{}));const i=[],a=[];n.signature.inputArg.forEach(d=>{const[h]=_i(d.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:KD(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,i.push(f),o[h]=f}),Object.keys(o).forEach(d=>{const h=o[d];h.inputNames.forEach(f=>{const[p]=_i(f);h.inputs.push(o[p]),o[p].children.push(h)})});const u=n.ret;n.signature.outputArg.forEach(d=>{const[h,f]=_i(u[d.name]),p=o[h];null!=p&&(p.defaultOutput=f,a.push(p))});const c=this.mapArgsToSignature(n);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:[],signature:c}}mapArgsToSignature(n){return{methodName:n.signature.name,inputs:n.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:n.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,n.ret),e),{})}}mapArgToTensorInfo(n,e){let r=n.name;return null!=e&&(r=e[r]),{name:r,dtype:n.type}}}function cM(t,n){const e=Array.isArray(t)?String.fromCharCode.apply(null,t):function mre(t){const n=ne().global;if(typeof n.atob<"u")return n.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return n?e:e.toLowerCase()}function jD(t,n,e,r=!1){const s=t[n];return null!=s?cM(s.s,r):e}function GD(t,n,e){const r=t[n];return r?r.b:e}function qD(t,n,e){const r=t[n]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function KD(t){switch("string"==typeof t&&(t=Hs[t]),t){case Hs.DT_FLOAT:return"float32";case Hs.DT_INT32:case Hs.DT_INT64:case Hs.DT_INT8:case Hs.DT_UINT8:return"int32";case Hs.DT_BOOL:return"bool";case Hs.DT_DOUBLE:return"float32";case Hs.DT_STRING:return"string";default:return null}}function dM(t,n,e){const r=t[n];return r&&r.func?r.func.name:e}function XD(t,n,e){const r=t[n];return r&&r.type?KD(r.type):e}function YD(t,n,e){const r=t[n];return r&&r.list&&r.list.type?r.list.type.map(s=>KD(s)):e}function hM(t){if(!t.unknownRank)return null!=t.dim?t.dim.map(n=>"number"==typeof n.size?n.size:parseInt(n.size,10)):[]}function JD(t,n,e){const r=t[n];return r&&r.shape?hM(r.shape):e}function ZD(t,n,e){const r=t[n];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function QD(t,n,e,r=!1){const s=t[n];return s&&s.list&&s.list.s?s.list.s.map(o=>cM(o,r)):e}function e_(t,n,e){const r=t[n];return r&&r.list&&r.list.shape?r.list.shape.map(s=>hM(s)):e}function t_(t,n,e){const r=t[n];return r&&r.list&&r.list.b?r.list.b:e}class gre{constructor(n,e,r){this.node=n,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=n.inputNames.map(s=>this.getInput(s)),null!=n.rawAttrs&&(this.attrs=Object.keys(n.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(n){return Wr(n,this.tensorMap,this.context)}getAttr(n,e){const r=this.node.rawAttrs[n];if(null!=r.tensor)return Wr(n,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return qD(this.node.rawAttrs,n,e);if(null!=r.s)return jD(this.node.rawAttrs,n,e);if(null!=r.b)return GD(this.node.rawAttrs,n,e);if(null!=r.shape)return JD(this.node.rawAttrs,n,e);if(null!=r.type)return XD(this.node.rawAttrs,n,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return ZD(this.node.rawAttrs,n,e);if(null!=r.list.s)return QD(this.node.rawAttrs,n,e);if(null!=r.list.shape)return e_(this.node.rawAttrs,n,e);if(null!=r.list.b)return t_(this.node.rawAttrs,n,e);if(null!=r.list.type)return YD(this.node.rawAttrs,n,e)}return e}}const bre=M({addN_:function yre(t){S(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),S(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const n=t.map((s,o)=>T(s,`tensors${o}`,"addN")),e=n[0];return n.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),n.forEach(s=>{if(!zt(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),F.runKernel(ym,n)}});function Ws(t,n,e=""){if("number"!=typeof t&&"number"!=typeof n){S(t.length===n.length,()=>e+` Shapes ${t} and ${n} must match`);for(let r=0;r<t.length;r++){const s=t[r],o=n[r];S(s<0||o<0||s===o,()=>e+` Shapes ${t} and ${n} must match`)}}}function fM(t){return!("number"==typeof t||t.some(n=>n<0))}function Jh(t,n,e){let r=n_(t,e);const s=!fM(r);if(s&&0===n.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&n.forEach(o=>{r=n_(o.shape,r)}),!fM(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function n_(t,n){if("number"==typeof t)return n;if("number"==typeof n)return t;if(t.length!==n.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${n}`);const e=[];for(let r=0;r<t.length;++r){const s=t[r],o=n[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${n}`);e[r]=s>=0?s:o}return e}class wre{constructor(n,e,r,s,o,i,a){this.name=n,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Oe(0),ur(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(n){this.tensors.forEach(e=>{(null==n||!n.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||n>=this.size())throw new Error(`Tried to read from index ${n}, but array size is: ${this.size()}`);const e=this.tensors[n];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${n} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(n){return n.map(e=>this.read(e))}write(n,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||!this.dynamicSize&&n>=this.maxSize)throw new Error(`Tried to write to index ${n}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[n]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),Ws(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${n}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been written.`);r.tensor=e,ur(e),r.written=!0,this.tensors[n]=r}writeMany(n,e){if(n.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${n.length} is not the same as tensors size: ${e.length}.`);n.forEach((r,s)=>this.write(r,e[s]))}gather(n,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(n)n=n.slice(0,this.size());else{n=[];for(let s=0;s<this.size();s++)n.push(s)}if(0===n.length)return Ha([],[0].concat(this.elementShape));const r=this.readMany(n);return Ws(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Ls(r,0)}concat(n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${n}`);if(0===this.size())return Ha([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return Ws(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Tn(r,0)}scatter(n,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(n.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${e.shape[0]}`);const r=Math.max(...n);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(n,fo(e,0))}split(n,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=n.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&n.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${n.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===r?0:e.size/r,i=[];U(()=>{e=W(e,[1,r,o]);for(let l=0;l<n.length;++l)i[l]=W(Ot(e,[0,0===l?0:s[l-1],0],[1,n[l],o]),this.elementShape);return i});const a=[];for(let l=0;l<n.length;l++)a[l]=l;this.writeMany(a,i)}}class Bu{constructor(n,e,r,s=-1){this.tensors=n,this.elementShape=e,this.elementDtype=r,n?.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Ws(e,o.shape,"TensorList shape mismatch: "),ur(o)}),this.idTensor=Oe(0),this.maxNumElements=s,ur(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Bu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(n){this.tensors.forEach(e=>{(null==n||!n.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(n,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Ws(n,this.elementShape,"TensorList shape mismatch: ");const s=Jh(this.elementShape,this.tensors,n);return U(()=>{const o=this.tensors.map(i=>W(i,s));return Ls(o,0)})}popBack(n,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=Jh(this.elementShape,this.tensors,n),s=this.tensors.pop();return Ws(s.shape,n,"TensorList shape mismatch: "),W(s,r)}pushBack(n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(Ws(n.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ur(n),this.tensors.push(n)}resize(n){if(n<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${n}`);if(-1!==this.maxNumElements&&n>this.maxNumElements)throw new Error(`TensorListResize input size ${n} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=n}getItem(n,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(n<0||n>this.tensors.length)throw new Error(`Trying to access element ${n} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[n])throw new Error(`element at index ${n} is null.`);Ws(this.tensors[n].shape,e,"TensorList shape mismatch: ");const s=Jh(this.elementShape,this.tensors,e);return W(this.tensors[n],s)}setItem(n,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(n<0||-1!==this.maxNumElements&&n>=this.maxNumElements)throw new Error(`Trying to set element ${n} in a list with max ${this.maxNumElements} elements.`);Ws(this.elementShape,e.shape,"TensorList shape mismatch: "),ur(e),this.tensors[n]=e}gather(n,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Ws(this.elementShape,r,"TensorList shape mismatch: "),n=n.slice(0,this.size());const s=Jh(this.elementShape,this.tensors,r);return 0===n.length?Ha([],[0].concat(s)):U(()=>{const o=n.map(i=>W(this.tensors[i],s));return Ls(o,0)})}concat(n,e){if(n&&n!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${n}`);Ws(this.elementShape,e,"TensorList shape mismatch: ");const r=Jh(this.elementShape,this.tensors,e);return 0===this.size()?Ha([],[0].concat(r)):U(()=>{const s=this.tensors.map(o=>W(o,r));return Tn(s,0)})}}const Sre=function(){var t=Q(function*(n,e,r){switch(n.op){case"If":case"StatelessIf":{const s=C("thenBranch",n,e,r),o=C("elseBranch",n,e,r),i=C("cond",n,e,r),a=C("args",n,e,r);return(yield i.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[o].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=C("body",n,e,r),o=C("cond",n,e,r),i=C("args",n,e,r),a=yield r.functionMap[o].executeFunctionAsync(i,r.tensorArrayMap,r.tensorListMap),l=i.map(d=>d.id);let u=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let c=i;for(;u[0];){const d=c;c=yield r.functionMap[s].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);const h=c.map(p=>p.id);d.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()});const f=yield r.functionMap[o].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);u=yield f[0].data(),f.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()})}return c}case"LoopCond":return[Si(C("pred",n,e,r))];case"Switch":{const s=C("pred",n,e,r);let o=C("data",n,e,r);return o.kept||(o=Si(o)),(yield s.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const s=n.inputNames.find(o=>void 0!==Wr(o,e,r));return s?[Si(Wr(s,e,r))]:void 0}case"Enter":{const s=C("frameName",n,e,r),o=C("tensor",n,e,r);return r.enterFrame(s),[Si(o)]}case"Exit":{const s=C("tensor",n,e,r);return r.exitFrame(),[Si(s)]}case"NextIteration":{const s=C("tensor",n,e,r);return r.nextIteration(),[Si(s)]}case"TensorArrayV3":{const s=C("size",n,e,r),o=C("dtype",n,e,r),i=C("elementShape",n,e,r),a=C("dynamicSize",n,e,r),l=C("clearAfterRead",n,e,r),u=C("identicalElementShapes",n,e,r),c=C("name",n,e,r),d=new wre(c,o,s,i,u,a,l);return r.addTensorArray(d),[d.idTensor,Oe(1)]}case"TensorArrayWriteV3":{const s=C("tensorArrayId",n,e,r),o=C("index",n,e,r),i=C("tensor",n,e,r),a=r.getTensorArray(s.id);return a.write(o,i),[a.idTensor]}case"TensorArrayReadV3":{const s=C("tensorArrayId",n,e,r),o=C("index",n,e,r);return[r.getTensorArray(s.id).read(o)]}case"TensorArrayGatherV3":{const s=C("tensorArrayId",n,e,r),o=C("indices",n,e,r),i=C("dtype",n,e,r);return[r.getTensorArray(s.id).gather(o,i)]}case"TensorArrayScatterV3":{const s=C("tensorArrayId",n,e,r),o=C("indices",n,e,r),i=C("tensor",n,e,r),a=r.getTensorArray(s.id);return a.scatter(o,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=C("tensorArrayId",n,e,r),o=r.getTensorArray(s.id),i=C("dtype",n,e,r);return[o.concat(i)]}case"TensorArraySplitV3":{const s=C("tensorArrayId",n,e,r),o=C("tensor",n,e,r),i=C("lengths",n,e,r),a=r.getTensorArray(s.id);return a.split(i,o),[a.idTensor]}case"TensorArraySizeV3":{const s=C("tensorArrayId",n,e,r);return[Oe(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=C("tensorArrayId",n,e,r),o=r.getTensorArray(s.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const s=C("tensorListId",n,e,r),o=C("index",n,e,r),i=C("tensor",n,e,r),a=r.getTensorList(s.id);return a.setItem(o,i),[a.idTensor]}case"TensorListGetItem":{const s=C("tensorListId",n,e,r),o=C("index",n,e,r),i=C("elementShape",n,e,r),a=C("elementDType",n,e,r);return[r.getTensorList(s.id).getItem(o,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=C("indices",n,e,r),l=function Dre(t,n,e,r){if(n.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${t.shape[0]}`);const s=Math.max(...n);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Bu([],e,t.dtype,r),i=fo(t,0);return n.forEach((a,l)=>{o.setItem(a,i[l])}),o}(C("tensor",n,e,r),s,C("elementShape",n,e,r),C("numElements",n,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=C("elementShape",n,e,r),o=C("elementDType",n,e,r);let i;i="TensorListReserve"===n.op?"numElements":"maxNumElements";const l=function Ire(t,n,e){return new Bu([],t,n,e)}(s,o,C(i,n,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=C("tensorListId",n,e,r),o=C("indices",n,e,r),i=C("elementShape",n,e,r),a=C("elementDType",n,e,r);return[r.getTensorList(s.id).gather(o,a,i)]}case"TensorListStack":{const s=C("tensorListId",n,e,r),o=C("elementShape",n,e,r),i=C("elementDType",n,e,r),a=C("numElements",n,e,r);return[r.getTensorList(s.id).stack(o,i,a)]}case"TensorListFromTensor":{const a=function Cre(t,n,e){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==e)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${e}`);Ws(t.shape.slice(1),n,"TensorList shape mismatch: ");const o=fo(t);return new Bu(o,n,r)}(C("tensor",n,e,r),C("elementShape",n,e,r),C("elementDType",n,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":{const s=C("tensorListId",n,e,r),o=r.getTensorList(s.id),i=C("dtype",n,e,r),a=C("elementShape",n,e,r);return[o.concat(i,a)]}case"TensorListPushBack":{const s=C("tensorListId",n,e,r),o=C("tensor",n,e,r),i=r.getTensorList(s.id);return i.pushBack(o),[i.idTensor]}case"TensorListPopBack":{const s=C("tensorListId",n,e,r),o=C("elementShape",n,e,r),i=C("elementDType",n,e,r);return[r.getTensorList(s.id).popBack(o,i)]}case"TensorListSplit":{const s=C("tensor",n,e,r),o=C("elementShape",n,e,r),a=function _re(t,n,e){let r=0;const s=n.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${t.shape}`);const i=n_(t.shape.slice(1),e),a=0===r?0:t.size/r,l=U(()=>{const c=[];t=W(t,[1,r,a]);for(let d=0;d<n.length;++d)c[d]=W(Ot(t,[0,0===d?0:s[d-1],0],[1,n[d],a]),i);return t.dispose(),c}),u=new Bu([],e,t.dtype,n.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}(s,C("lengths",n,e,r),o);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(e,r,s){return t.apply(this,arguments)}}(),Nre=M({maxPoolWithArgmax_:function Ere(t,n,e,r,s=!1){const i={x:T(t,"x","maxPoolWithArgmax")},l=F.runKernel(W0,i,{filterSize:n,strides:e,pad:r,includeBatchInIndex:s});return{result:l[0],indexes:l[1]}}});function pM(t,n,e){const[r,s]=C("fusedOps",t,n,e),o="biasadd"===r,i="prelu"===s,a="fusedbatchnorm"===r,l=C("numArgs",t,n,e);if(o){if(i&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(a)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const u=C("strides",t,n,e),c=Ay(t,n,e),d=C("dataFormat",t,n,e).toUpperCase(),h=C("dilations",t,n,e),[f,p]=C("args",t,n,e);return{stride:u,pad:c,dataFormat:d,dilations:h,biasArg:f,preluArg:p,activationFunc:s,leakyreluAlpha:C("leakyreluAlpha",t,n,e)}}function kre(t,n,e){if(e<=0)throw new Error("The number of values should be positive.");return F.runKernel(z0,{},{start:t,stop:n,num:e})}const Rre=M({multinomial_:function Are(t,n,e,r=!1){const s=T(t,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();const l={logits:1===i?W(s,[1,-1]):s},c=F.runKernel(j0,l,{numSamples:n,seed:e,normalized:r});return 1===i?W(c,[c.size]):c}});function r_(){return(r_=Q(function*(t){const n=T(t,"condition","whereAsync","bool"),e=yield n.data(),r=HI(n.shape,e);return t!==n&&n.dispose(),r})).apply(this,arguments)}const Ore=function Fre(t){return r_.apply(this,arguments)};function s_(){return(s_=Q(function*(t,n){const e=T(t,"x","setdiff1d"),r=T(n,"y","setdiff1d");S(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),S(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),S(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),o=yield r.data(),i=new Set(o);let a=0;for(let c=0;c<s.length;c++)i.has(s[c])||a++;const l=new Zn([a],e.dtype),u=new Zn([a],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]})).apply(this,arguments)}function o_(t,n,e){return{boxes:C("boxes",t,n,e),scores:C("scores",t,n,e),maxOutputSize:C("maxOutputSize",t,n,e),iouThreshold:C("iouThreshold",t,n,e),scoreThreshold:C("scoreThreshold",t,n,e),softNmsSigma:C("softNmsSigma",t,n,e)}}const Lre=function(){var t=Q(function*(n,e,r){switch(n.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=o_(n,e,r),c=yield Za.nonMaxSuppressionWithScoreAsync(s,o,i,a,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=o_(n,e,r),u=C("padToMaxOutputSize",n,e,r),c=yield Za.nonMaxSuppressionPaddedAsync(s,o,i,a,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=o_(n,e,r);return[yield Za.nonMaxSuppressionAsync(s,o,i,a,l)]}case"Where":{const s=Ae(C("condition",n,e,r),"bool"),o=[yield Ore(s)];return s.dispose(),o}case"ListDiff":return function Mre(t,n){return s_.apply(this,arguments)}(C("x",n,e,r),C("y",n,e,r));default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(e,r,s){return t.apply(this,arguments)}}();class Vre{constructor(n,e){this.keyDType=n,this.valueDType=e,this.handle=Oe(0),this.tensorMap=new Map,ur(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Oe(this.size(),"int32")}import(n,e){var r=this;return Q(function*(){r.checkKeyAndValueTensor(n,e);const s=yield n.data();return r.tensorMap.forEach(o=>o.dispose()),r.tensorMap.clear(),U(()=>{const o=fo(e),i=s.length,a=o.length;S(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let l=0;l<i;l++){const u=s[l],c=o[l];ur(c),r.tensorMap.set(u,c)}return r.handle})})()}find(n,e){var r=this;return Q(function*(){r.checkKeyAndValueTensor(n,e);const s=yield n.data();return U(()=>{const o=[];for(let i=0;i<s.length;i++){const l=r.findWithDefault(s[i],e);o.push(l)}return Ls(o)})})()}findWithDefault(n,e){return this.tensorMap.get(n)??e}checkKeyAndValueTensor(n,e){if(n.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${n.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const Ure=function(){var t=Q(function*(n,e,r,s){switch(n.op){case"HashTable":case"HashTableV2":{const o=C("keyDType",n,e,r),i=C("valueDType",n,e,r),a=new Vre(o,i);return s.addHashTable(n.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const o=C("tableHandle",n,e,r,s),i=C("keys",n,e,r),a=C("values",n,e,r);return[yield s.getHashTableById(o.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const o=C("tableHandle",n,e,r,s),i=C("keys",n,e,r),a=C("defaultValue",n,e,r);return[yield s.getHashTableById(o.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const o=C("tableHandle",n,e,r,s);return[s.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(e,r,s,o){return t.apply(this,arguments)}}(),mM=M({sparseToDense_:function qre(t,n,e,r=0){const s=T(t,"sparseIndices","sparseToDense","int32"),o=T(n,"sparseValues","sparseToDense"),i=T(r,"defaultValue","sparseToDense",o.dtype);return function Gre(t,n,e,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(e.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${o}.`);if(0!==n.rank&&(1!==n.rank||n.size!==s))throw new Error(`sparseValues has incorrect shape ${n.shape}, should be [] or [${s}]`);if(n.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,e,i),F.runKernel(nC,{sparseIndices:s,sparseValues:o,defaultValue:i},{outputShape:e})}}),Yre=M({bincount_:function Xre(t,n,e){const r=T(t,"x","bincount"),s=T(n,"weights","bincount");return S("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),F.runKernel(w0,{x:r,weights:s},{size:e})}}),Zre=M({denseBincount_:function Jre(t,n,e,r=!1){const s=T(t,"x","denseBincount"),o=T(n,"weights","denseBincount");return S("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),F.runKernel(E0,{x:s,weights:o},{size:e,binaryOutput:r})}}),tse=M({scatterND_:function ese(t,n,e){const r=T(t,"indices","scatterND","int32"),s=T(n,"updates","scatterND");return Y2(s,r,e),F.runKernel(eC,{indices:r,updates:s},{shape:e})}}),rse=M({gatherND_:function nse(t,n){const e=T(n,"indices","gatherND","int32"),s={params:T(t,"x","gatherND"),indices:e};return F.runKernel(P0,s)}});function gM(t,n,e,r){const s=((o,i,a)=>{switch(o.category){case"arithmetic":return U(()=>((t,n,e)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[me(C("a",t,n,e),C("b",t,n,e))];case"AddN":return[bre(C("tensors",t,n,e))];case"FloorMod":case"Mod":return[AF(C("a",t,n,e),C("b",t,n,e))];case"Mul":return[V(C("a",t,n,e),C("b",t,n,e))];case"RealDiv":case"Div":return[Le(C("a",t,n,e),C("b",t,n,e))];case"DivNoNan":return[SF(C("a",t,n,e),C("b",t,n,e))];case"FloorDiv":return[GC(C("a",t,n,e),C("b",t,n,e))];case"Sub":return[Fe(C("a",t,n,e),C("b",t,n,e))];case"Minimum":return[Nh(C("a",t,n,e),C("b",t,n,e))];case"Maximum":return[gi(C("a",t,n,e),C("b",t,n,e))];case"Pow":return[Ja(C("a",t,n,e),C("b",t,n,e))];case"SquaredDifference":return[bI(C("a",t,n,e),C("b",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"basic_math":return U(()=>((t,n,e)=>{switch(t.op){case"Abs":case"ComplexAbs":return[Qn(C("x",t,n,e))];case"Acos":return[mF(C("x",t,n,e))];case"Acosh":return[gF(C("x",t,n,e))];case"Asin":return[bF(C("x",t,n,e))];case"Asinh":return[vF(C("x",t,n,e))];case"Atan":return[xF(C("x",t,n,e))];case"Atan2":return[wF(C("x",t,n,e),C("y",t,n,e))];case"Atanh":return[CF(C("x",t,n,e))];case"Ceil":return[IF(C("x",t,n,e))];case"Complex":return[Ua(C("real",t,n,e),C("imag",t,n,e))];case"Cos":return[sy(C("x",t,n,e))];case"Cosh":return[XI(C("x",t,n,e))];case"Elu":return[Ih(C("x",t,n,e))];case"Erf":return[EF(C("x",t,n,e))];case"Exp":return[Ms(C("x",t,n,e))];case"Expm1":return[NF(C("x",t,n,e))];case"Floor":return[_h(C("x",t,n,e))];case"Log":return[ms(C("x",t,n,e))];case"Log1p":return[vI(C("x",t,n,e))];case"Imag":return[sI(C("x",t,n,e))];case"Neg":return[yn(C("x",t,n,e))];case"Reciprocal":return[RF(C("x",t,n,e))];case"Real":return[jg(C("x",t,n,e))];case"Relu":return[bi(C("x",t,n,e))];case"Round":return[$F(C("x",t,n,e))];case"Selu":return[QC(C("x",t,n,e))];case"Sigmoid":return[Eu(C("x",t,n,e))];case"Sin":return[WI(C("x",t,n,e))];case"Sign":return[FF(C("x",t,n,e))];case"Sinh":return[jI(C("x",t,n,e))];case"Softplus":return[kh(C("x",t,n,e))];case"Sqrt":return[wr(C("x",t,n,e))];case"Square":return[Wt(C("x",t,n,e))];case"Tanh":return[nI(C("x",t,n,e))];case"Tan":return[MF(C("x",t,n,e))];case"ClipByValue":return[Jr(C("x",t,n,e),C("clipValueMin",t,n,e),C("clipValueMax",t,n,e))];case"Relu6":return[aI(C("x",t,n,e))];case"Rsqrt":return[qI(Wr(t.inputNames[0],n,e))];case"Prod":return[JI(C("x",t,n,e),C("axes",t,n,e))];case"LeakyRelu":return[Lg(C("x",t,n,e),C("alpha",t,n,e))];case"Prelu":return[Vg(C("x",t,n,e),C("alpha",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"control":return Sre(o,i,a);case"convolution":return U(()=>((t,n,e)=>{switch(t.op){case"Conv1D":{const r=C("stride",t,n,e),s=C("pad",t,n,e),o=C("dataFormat",t,n,e).toUpperCase(),i=C("dilation",t,n,e);return[HC(C("x",t,n,e),C("filter",t,n,e),r,s,o,i)]}case"Conv2D":{const r=C("strides",t,n,e),s=Ay(t,n,e),o=C("dataFormat",t,n,e).toUpperCase(),i=C("dilations",t,n,e);return[Zi(C("x",t,n,e),C("filter",t,n,e),[r[1],r[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:l,activationFunc:u,leakyreluAlpha:c}=pM(t,n,e);return[P2({x:C("x",t,n,e),filter:C("filter",t,n,e),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:l,activationFunc:u,leakyreluAlpha:c}=pM(t,n,e);return[zY({x:C("x",t,n,e),filter:C("filter",t,n,e),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=C("outputShape",t,n,e),s=C("strides",t,n,e),o=Ay(t,n,e);return[jC(C("x",t,n,e),C("filter",t,n,e),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=C("strides",t,n,e),s=Ay(t,n,e),o=C("dilations",t,n,e),i=C("dataFormat",t,n,e).toUpperCase();return[Ch(C("input",t,n,e),C("filter",t,n,e),[r[1],r[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("dataFormat",t,n,e).toUpperCase(),i=C("dilations",t,n,e);return[k2(C("x",t,n,e),C("filter",t,n,e),[r[1],r[2],r[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e);return[Mg(C("x",t,n,e),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e);return[Bg(C("x",t,n,e),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e),i=C("includeBatchInIndex",t,n,e),{result:a,indexes:l}=Nre(C("x",t,n,e),[o[1],o[2]],[r[1],r[2]],s,i);return[a,l]}case"AvgPool3D":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e);return[T2(C("x",t,n,e),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e);return[R2(C("x",t,n,e),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("dilations",t,n,e),i=r[1],a=r[2],l=o[1],u=o[2];return[_F(C("x",t,n,e),C("filter",t,n,e),[i,a],s,[l,u],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"creation":return U(()=>((t,n,e)=>{switch(t.op){case"Fill":{const r=C("shape",t,n,e),s=C("dtype",t,n,e);return[Pg(r,C("value",t,n,e),s)]}case"LinSpace":return[kre(C("start",t,n,e),C("stop",t,n,e),C("num",t,n,e))];case"Multinomial":{const r=C("logits",t,n,e),s=C("numSamples",t,n,e),o=C("seed",t,n,e);return[Rre(r,s,o)]}case"OneHot":{const r=C("indices",t,n,e),s=C("depth",t,n,e),o=C("onValue",t,n,e),i=C("offValue",t,n,e);return[YC(r,s,o,i)]}case"Ones":return[yi(C("shape",t,n,e),C("dtype",t,n,e))];case"OnesLike":return[gs(C("x",t,n,e))];case"RandomUniform":return[Th(C("shape",t,n,e),C("minval",t,n,e),C("maxval",t,n,e),C("dtype",t,n,e))];case"Range":return[gI(C("start",t,n,e),C("stop",t,n,e),C("step",t,n,e),C("dtype",t,n,e))];case"TruncatedNormal":{const r=C("shape",t,n,e),s=C("mean",t,n,e),o=C("stdDev",t,n,e),i=C("seed",t,n,e);return[rI(r,s,o,C("dtype",t,n,e),i)]}case"Zeros":return[An(C("shape",t,n,e),C("dtype",t,n,e))];case"ZerosLike":return[St(C("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"dynamic":return Lre(o,i,a);case"evaluation":return U(()=>((t,n,e)=>{switch(t.op){case"TopKV2":{const r=C("x",t,n,e),s=C("k",t,n,e),o=C("sorted",t,n,e),i=PF(r,s,o);return[i.values,i.indices]}case"Unique":{const r=C("x",t,n,e),s=ZI(r);return[s.values,s.indices]}case"UniqueV2":{const r=C("x",t,n,e),s=C("axis",t,n,e),o=ZI(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"image":return U(()=>((t,n,e)=>{switch(t.op){case"ResizeBilinear":{const r=C("images",t,n,e),s=C("size",t,n,e),o=C("alignCorners",t,n,e),i=C("halfPixelCenters",t,n,e);return[Za.resizeBilinear(r,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const r=C("images",t,n,e),s=C("size",t,n,e),o=C("alignCorners",t,n,e),i=C("halfPixelCenters",t,n,e);return[Za.resizeNearestNeighbor(r,[s[0],s[1]],o,i)]}case"CropAndResize":{const r=C("image",t,n,e),s=C("boxes",t,n,e),o=C("boxInd",t,n,e),i=C("cropSize",t,n,e),a=C("method",t,n,e),l=C("extrapolationValue",t,n,e);return[Za.cropAndResize(r,s,o,i,a,l)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"graph":return U(()=>((t,n,e)=>{switch(t.op){case"Const":return n[t.name];case"PlaceholderWithDefault":const r=C("default",t,n,e);return[Wr(t.name,n,e)||r];case"Placeholder":return[Wr(t.name,n,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Si(C("x",t,n,e))];case"IdentityN":return C("x",t,n,e).map(u=>Si(u));case"Shape":return[Bs(C("x",t,n,e).shape,"int32")];case"ShapeN":return C("x",t,n,e).map(u=>Bs(u.shape));case"Size":return[Oe(C("x",t,n,e).size,"int32")];case"Rank":return[Oe(C("x",t,n,e).rank,"int32")];case"NoOp":return[Oe(1)];case"Print":const o=C("x",t,n,e),i=C("data",t,n,e),a=C("message",t,n,e),l=C("summarize",t,n,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let u=0;u<i.length;u++)console.log(Array.prototype.slice.call(i[u].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"logical":return U(()=>((t,n,e)=>{switch(t.op){case"Equal":return[Ka(C("a",t,n,e),C("b",t,n,e))];case"NotEqual":return[Su(C("a",t,n,e),C("b",t,n,e))];case"Greater":return[Fo(C("a",t,n,e),C("b",t,n,e))];case"GreaterEqual":return[Ya(C("a",t,n,e),C("b",t,n,e))];case"Less":return[KI(C("a",t,n,e),C("b",t,n,e))];case"LessEqual":return[ku(C("a",t,n,e),C("b",t,n,e))];case"LogicalAnd":return[Oo(C("a",t,n,e),C("b",t,n,e))];case"LogicalNot":return[ry(C("a",t,n,e))];case"LogicalOr":return[YI(C("a",t,n,e),C("b",t,n,e))];case"Select":case"SelectV2":return[bs(C("condition",t,n,e),C("a",t,n,e),C("b",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"matrices":return U(()=>((t,n,e)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[At(C("a",t,n,e),C("b",t,n,e),C("transposeA",t,n,e),C("transposeB",t,n,e))];case"Transpose":return[Ht(C("x",t,n,e),C("perm",t,n,e))];case"_FusedMatMul":const[r,s]=C("fusedOps",t,n,e),o="biasadd"===r,i="prelu"===s,a=C("numArgs",t,n,e),l=C("leakyreluAlpha",t,n,e);if(o){if(i&&2!==a)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==a)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,c]=C("args",t,n,e);return[lI({a:C("a",t,n,e),b:C("b",t,n,e),transposeA:C("transposeA",t,n,e),transposeB:C("transposeB",t,n,e),bias:u,activation:s,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"normalization":return U(()=>((t,n,e)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Du(C("x",t,n,e),C("mean",t,n,e),C("variance",t,n,e),C("offset",t,n,e),C("scale",t,n,e),C("epsilon",t,n,e))];case"LRN":return[TF(C("x",t,n,e),C("radius",t,n,e),C("bias",t,n,e),C("alpha",t,n,e),C("beta",t,n,e))];case"Softmax":return[Hg(C("x",t,n,e))];case"LogSoftmax":return[qC(C("x",t,n,e))];case"SparseToDense":return[mM(C("sparseIndices",t,n,e),C("outputShape",t,n,e),C("sparseValues",t,n,e),C("defaultValue",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"reduction":return U(()=>((t,n,e)=>{switch(t.op){case"Max":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[Ps(C("x",t,n,e),i,a)]}case"Mean":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[gn(C("x",t,n,e),i,a)]}case"Min":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[Eh(C("x",t,n,e),i,a)]}case"Sum":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[Pe(C("x",t,n,e),i,a)]}case"All":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[zC(C("x",t,n,e),i,a)]}case"Any":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[$g(C("x",t,n,e),i,a)]}case"ArgMax":{const i=C("axis",t,n,e);return[Fg(C("x",t,n,e),i)]}case"ArgMin":{const i=C("axis",t,n,e);return[yF(C("x",t,n,e),i)]}case"Prod":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[JI(C("x",t,n,e),i,a)]}case"Cumsum":{const i=C("axis",t,n,e),a=C("exclusive",t,n,e),l=C("reverse",t,n,e);return[GI(C("x",t,n,e),i,a,l)]}case"Bincount":const r=C("x",t,n,e),s=C("weights",t,n,e),o=C("size",t,n,e);return[Yre(r,s,o)];case"DenseBincount":{const i=C("x",t,n,e),a=C("weights",t,n,e),l=C("size",t,n,e),u=C("binaryOutput",t,n,e);return[Zre(i,a,l,u)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"slice_join":return U(()=>((t,n,e)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=C("n",t,n,e),s=C("axis",t,n,e);let o=C("tensors",t,n,e);return o=o.slice(0,r),[Tn(o,s)]}case"Gather":{const r=C("x",t,n,e),s=C("indices",t,n,e);return[Sh(r,Ae(s,"int32"),0)]}case"GatherV2":{const r=C("axis",t,n,e),s=C("batchDims",t,n,e),o=C("x",t,n,e),i=C("indices",t,n,e);return[Sh(o,Ae(i,"int32"),r,s)]}case"Reverse":{const r=C("dims",t,n,e),s=[];for(let i=0;i<r.length;i++)r[i]&&s.push(i);const o=C("x",t,n,e);return[vi(o,s)]}case"ReverseV2":{const r=C("axis",t,n,e),s=C("x",t,n,e);return[vi(s,r)]}case"Slice":{const r=C("begin",t,n,e),s=C("size",t,n,e);return[Ot(C("x",t,n,e),r,s)]}case"StridedSlice":{const r=C("begin",t,n,e),s=C("end",t,n,e),o=C("strides",t,n,e),i=C("beginMask",t,n,e),a=C("endMask",t,n,e),l=C("ellipsisMask",t,n,e),u=C("newAxisMask",t,n,e),c=C("shrinkAxisMask",t,n,e),d=C("x",t,n,e);return[OF(d,r,s,o,i,a,l,u,c)]}case"Pack":return U(()=>{const r=C("axis",t,n,e),s=C("tensors",t,n,e),o=s[0].shape,i=Nu(s[0]).shape,a=s.map(l=>{const u=zt(l.shape,o);if(!u&&!zt(Nu(l).shape,i))throw new Error("the input tensors shape does not match");return u?l:W(l,o)});return[Ls(a,r)]});case"Unpack":{const r=C("axis",t,n,e),s=C("tensor",t,n,e);return fo(s,r)}case"Tile":{const r=C("reps",t,n,e);return[Xa(C("x",t,n,e),r)]}case"Split":case"SplitV":{const r=C("axis",t,n,e),s=C("numOrSizeSplits",t,n,e),o=C("x",t,n,e);return ys(o,s,r)}case"ScatterNd":{const r=C("indices",t,n,e),s=C("values",t,n,e),o=C("shape",t,n,e);return[tse(r,s,o)]}case"GatherNd":{const r=C("x",t,n,e),s=C("indices",t,n,e);return[rse(r,s)]}case"SparseToDense":{const r=C("sparseIndices",t,n,e),s=C("outputShape",t,n,e),o=C("sparseValues",t,n,e),i=C("defaultValue",t,n,e);return[mM(r,o,s,o.dtype===i.dtype?i:Ae(i,o.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"spectral":return U(()=>((t,n,e)=>{switch(t.op){case"FFT":return[Gg(C("x",t,n,e))];case"IFFT":return[Rh(C("x",t,n,e))];case"RFFT":return[qg(C("x",t,n,e))];case"IRFFT":return[oI(C("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"transformation":return U(()=>((t,n,e)=>{switch(t.op){case"Cast":return[Ae(C("x",t,n,e),C("dtype",t,n,e))];case"ExpandDims":{const r=C("axis",t,n,e);return[Os(C("x",t,n,e),r)]}case"Squeeze":{const r=C("axis",t,n,e);return[Nu(C("x",t,n,e),r)]}case"Reshape":return[W(C("x",t,n,e),C("shape",t,n,e))];case"MirrorPad":return[kF(C("x",t,n,e),C("padding",t,n,e),C("mode",t,n,e))];case"PadV2":case"Pad":return[zg(C("x",t,n,e),C("padding",t,n,e),C("constantValue",t,n,e))];case"SpaceToBatchND":{const r=C("blockShape",t,n,e),s=C("paddings",t,n,e);return[ny(C("x",t,n,e),r,s)]}case"BatchToSpaceND":{const r=C("blockShape",t,n,e),s=C("crops",t,n,e);return[oy(C("x",t,n,e),r,s)]}case"DepthToSpace":{const r=C("blockSize",t,n,e),s=C("dataFormat",t,n,e).toUpperCase();return[DF(C("x",t,n,e),r,s)]}case"BroadcastTo":return[Wg(C("x",t,n,e),C("shape",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"hash_table":return Ure(o,i,a,r);case"custom":const l=lM(o.op);if(l&&l.customExecutor)return l.customExecutor(new gre(o,i,a));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,n,e);return bd(s)?s.then(o=>[].concat(o)):[].concat(s)}class yM{constructor(n={},e={},r={},s={}){this.weightMap=n,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(n,e){return{id:n,frameName:e,iterationId:0}}set currentContext(n){this.contexts!==n&&(this.contexts=n,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const n=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);n.push(this.contextIdforContexts(r))}n.push(""),this._currentContextIds=n}contextIdforContexts(n){return n?n.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(n){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,n)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const n=Object.assign({},this.contexts[this.contexts.length-1]);n.iterationId+=1,n.id=this.lastId,this.contexts.splice(-1,1,n),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(n){return this.weightMap[n]}addTensorArray(n){this.tensorArrayMap[n.id]=n}getTensorArray(n){return this.tensorArrayMap[n]}addTensorList(n){this.tensorListMap[n.id]=n}getTensorList(n){return this.tensorListMap[n]}dispose(n){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(n);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(n)}}function bM(t,n,e,r){const s=new Set,o=[];let i=null,a=null;const l=new Set,u=Object.keys(t).map(h=>Qr(h)[0]);let c=[];null!=r&&(c=r.map(h=>Qr(h.name)[0]));const d=[...n];for(;d.length>0;){const h=d.pop();if((vM(h)||dse(h)||hse(h))&&null==i&&(i=h,a=i.children.map(f=>f.name).filter(f=>s.has(f))),s.add(h.name),null==e[h.name]&&-1===u.indexOf(h.name)&&-1===c.indexOf(h.name)){if(0===h.inputs.length){o.push(h.name);continue}h.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:t,outputs:n,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}const lse=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],use=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],cse=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function vM(t){return lse.indexOf(t.op)>=0}function dse(t){return use.indexOf(t.op)>=0}function hse(t){return cse.indexOf(t.op)>=0}class Ry{constructor(n,e){this.graph=n,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=n.outputs,this._inputs=n.inputs,this._initNodes=n.initNodes,this._signature=n.signature,this._functions=n.functions,null!=n.functions&&Object.keys(n.functions).forEach(r=>{this._functionExecutorMap[r]=new Ry(n.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(n){const e=Object.keys(n).map(r=>n[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=n}set resourceManager(n){this._resourceManager=n}get inputs(){return this._inputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(n=>n.signatureKey||n.name)}get outputNodes(){return this._outputs.map(n=>{const e=n.signatureKey||n.name;return n.defaultOutput?`${e}:${n.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((n,e)=>(n[e]=this._functions[e].signature,n),{})}getCompilationKey(n,e){const r=n.map(o=>o.name).sort(),s=e.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(n,e){const r=bM(n,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const a=e.map(u=>u.name),l=Object.keys(n);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}return function ase(t,n,e){const{usedNodes:r,inputs:s}=e,o=[],i=Object.keys(s).map(c=>Qr(c)[0]).map(c=>t.nodes[c]),a=t.initNodes;i.forEach(c=>{r.has(c.name)&&o.push(c)}),t.weights.forEach(c=>{r.has(c.name)&&o.push(c)}),a?.forEach(c=>{r.has(c.name)&&o.push(c)});const l=new Set,u=[];for(;o.length>0;){const c=o.pop();l.add(c.name),n[c.name]||u.push(c),c.children.forEach(d=>{!l.has(d.name)&&r.has(d.name)&&d.inputs.every(h=>l.has(h.name))&&o.push(d)})}return u}(this.graph,this.weightMap,r)}execute(n,e){n=this.mapInputs(n);const r=Object.keys(n).sort();this.checkInputs(n),this.checkInputShapeAndType(n),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(d=>this.graph.nodes[Qr(d)[0]]),o=e.map(d=>Qr(d)[0]);let i=o.map(d=>this.graph.nodes[d]);0===i.length&&(i=this._outputs);const a=this.getCompilationKey(s,i);let l=this.compiledMap.get(a);null==l&&(l=this.compile(n,i),this.compiledMap.set(a,l));const u={},c={};return U(()=>{const d=new yM(this.weightMap,u,c,this.functionExecutorMap),h=Object.assign({},this.weightMap);Object.keys(n).forEach(m=>{const[g,y]=Qr(m),b=[];b[y]=n[m],h[g]=b});const f=this.getFrozenTensorIds(h),p={};for(let m=0;m<l.length;m++){const g=l[m];if(!h[g.name]){const y=gM(g,h,d,this._resourceManager);if(bd(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);h[g.name]=y,this.checkTensorForDisposal(g.name,g,h,d,f,o,p)}}return null==this.parent&&d.dispose(f),e.map(m=>Wr(m,h,d))})}getFrozenTensorIds(n){const e=[].concat.apply([],Object.keys(n).map(r=>n[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(n,e,r,s,o,i,a){"control"===e.category||-1!==i.indexOf(n)||(r[n].forEach(l=>{null!=l&&(a[l.id]=(a[l.id]||0)+e.children.length)}),e.inputs.forEach(l=>{if("control"!==l.category){const u=function Jne(t,n,e){return n[ky(t,e.currentContextId)]}(l.name,r,s);u?.forEach(c=>{if(c&&!o.has(c.id)){const d=a[c.id];1===d?(c.dispose(),delete a[c.id]):null!=d&&a[c.id]--}})}}))}executeAsync(n,e){var r=this;return Q(function*(){return r._executeAsync(n,e)})()}_executeAsync(n,e,r=!1,s={},o={}){var i=this;return Q(function*(){r||(n=i.mapInputs(n),i.checkInputs(n),i.checkInputShapeAndType(n),e=i.mapOutputs(e),i.checkOutputs(e));const a=new yM(i.weightMap,s,o,i.functionExecutorMap),l=yield i.executeWithControlFlow(n,a,e,r),u=e.map(f=>Wr(f,l,a)),c=u.map(f=>f.id),d=Object.keys(n).map(f=>n[f].id),h=new Set([...c,...d,...i.weightIds]);return Object.keys(l).forEach(f=>{l[f].forEach(m=>{m&&!m.isDisposed&&!h.has(m.id)&&m.dispose()})}),null==i.parent&&a.dispose(h),u})()}executeFunctionAsync(n,e,r){var s=this;return Q(function*(){const o=n.reduce((i,a,l)=>(i[s.inputs[l].name]=a,i),{});return s._executeAsync(o,s.outputNodes,!0,e,r)})()}executeWithControlFlow(n,e,r,s){var o=this;return Q(function*(){const i=Object.keys(n),a=i.map(x=>o.graph.nodes[Qr(x)[0]]),l=r.map(x=>Qr(x)[0]);let u=l.map(x=>o.graph.nodes[x]);0===u.length&&(u=o._outputs);const{usedNodes:c,missingInputs:d,dynamicNode:h,syncInputs:f}=bM(n,u,o.weightMap,o._initNodes),p=[...a,...o.graph.weights,...o._initNodes||[]].map(x=>({node:x,contexts:e.currentContext})),m=Object.assign({},o.weightMap);Object.keys(n).forEach(x=>{const[w,_]=Qr(x),D=[];D[_]=n[x],m[w]=D});const g={},y=o.getFrozenTensorIds(m),b={};for(;p.length>0;){const x=o.processStack(a,p,e,m,b,y,l,g,c);yield Promise.all(x)}null==h&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=u.filter(x=>!vM(x)&&!Wr(x.name,m,e)).map(x=>x.name);if(v.length>0){let x="";throw null!=h&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${i}]. Consider providing the following inputs: [${d}]. ${x}`)}return m})()}processStack(n,e,r,s,o,i,a,l,u){const c=[];for(;e.length>0;){const d=e.pop();r.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&C("isConstant",d.node,s,r)&&([h]=_i(d.node.name,r)),null==s[d.node.name]){const f=gM(d.node,s,r,this._resourceManager);h||([h]=_i(d.node.name,r));const p=r.currentContext;bd(f)?c.push(f.then(m=>(s[h]=m,r.currentContext=p,this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,e,r,s,o,u),m))):(s[h]=f,this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,e,r,s,o,u))}else this.processChildNodes(d.node,e,r,s,o,u)}return c}processChildNodes(n,e,r,s,o,i){n.children.forEach(a=>{const[l]=_i(a.name,r);o[l]||!i.has(a.name)||("Merge"===a.op?a.inputNames.some(u=>!!Wr(u,s,r))&&(o[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!Wr(u,s,r))&&(o[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(n=>this.weightMap[n].forEach(e=>e.dispose()))}checkInputShapeAndType(n){Object.keys(n).forEach(e=>{const r=n[e],[s]=Qr(e),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value;S(i.length===r.shape.length&&r.shape.every((l,u)=>-1===i[u]||i[u]===l),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&S(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(n){const e={};for(const r in n)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[r]?e[this._signature.inputs[r].name]=n[r]:e[r]=n[r];return e}checkInputs(n){const e=Object.keys(n).filter(r=>{const[s]=Qr(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(n){return n.map(e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e,{})}checkOutputs(n){n.forEach(e=>{const[r]=Qr(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class fse{constructor(n={},e={}){this.hashTableNameToHandle=n,this.hashTableMap=e}addHashTable(n,e){this.hashTableNameToHandle[n]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(n){return this.hashTableNameToHandle[n]}getHashTableById(n){return this.hashTableMap[n]}dispose(){for(const n in this.hashTableMap)this.hashTableMap[n].clearAndClose(),delete this.hashTableMap[n];for(const n in this.hashTableNameToHandle)this.hashTableNameToHandle[n].dispose(),delete this.hashTableNameToHandle[n]}}const pse="?tfjs-format=file",mse="model.json";class gse{constructor(n,e={}){this.modelUrl=n,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={}),this.resourceManager=new fse}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const n=this.modelUrl;if(null!=n.load)this.handler=n;else if(null!=this.loadOptions.requestInit)this.handler=m2(n,this.loadOptions);else{const e=((t,n)=>cn.getLoadHandlers(t,this.loadOptions))(n);if(0===e.length)e.push(m2(n,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[n]}'`);this.handler=e[0]}}load(){var n=this;return Q(function*(){if(n.findIOHandler(),null==n.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=yield n.handler.load();return n.loadSync(e)})()}loadSync(n){this.artifacts=n;const e=this.artifacts.modelTopology;let r;r=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const s=function Z$(t,n){const e={};let r,s=0;for(const o of n){const i=o.name,a=o.dtype,l=o.shape,u=te(l);let c;if("quantization"in o){const d=o.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=gC[d.dtype],f=t.slice(s,s+u*h),p="uint8"===d.dtype?new Uint8Array(f):new Uint16Array(f);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){c=new Float32Array(p.length);for(let m=0;m<p.length;m++)c[m]=p[m]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=jX()),c=r(p)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(p.length);for(let m=0;m<p.length;m++)c[m]=Math.round(p[m]*d.scale+d.min)}s+=u*h}else if("string"===a){const d=te(o.shape);c=[];for(let h=0;h<d;h++){const f=new Uint32Array(t.slice(s,s+4))[0];s+=4;const p=new Uint8Array(t.slice(s,s+f));c.push(p),s+=f}}else{const d=gC[a],h=t.slice(s,s+u*d);if("float32"===a)c=new Float32Array(h);else if("int32"===a)c=new Int32Array(h);else if("bool"===a)c=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);{c=new Float32Array(h);const f=new Float32Array(c.length/2),p=new Float32Array(c.length/2);for(let y=0;y<f.length;y++)f[y]=c[2*y],p[y]=c[2*y+1];const m=Ha(f,l,"float32"),g=Ha(p,l,"float32");e[i]=Ua(m,g),m.dispose(),g.dispose()}}s+=u*d}"complex64"!==a&&(e[i]=Ha(c,l,a))}return e}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Ry(uM.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,null!=n.modelInitializer&&null!=n.modelInitializer.node){const o=uM.Instance.transformGraph(n.modelInitializer);this.initializer=new Ry(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(n,e){var r=this;return Q(function*(){if("string"==typeof n){const s=t2(n);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${n}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${n}'`);n=s[0]}if(null==n.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return n.save(r.artifacts)})()}predict(n,e){return this.execute(n,this.outputNodes)}normalizeInputs(n){if(!(n instanceof un||Array.isArray(n)))return n;if((n=Array.isArray(n)?n:[n]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${n.length} input tensors.`);return this.inputNodes.reduce((e,r,s)=>(e[r]=n[s],e),{})}normalizeOutputs(n){return n=n||this.outputNodes,Array.isArray(n)?n:[n]}execute(n,e){n=this.normalizeInputs(n),e=this.normalizeOutputs(e);const r=this.executor.execute(n,e);return r.length>1?r:r[0]}executeAsync(n,e){var r=this;return Q(function*(){n=r.normalizeInputs(n),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(n,e);return s.length>1?s:s[0]})()}convertTensorMapToTensorsMap(n){return Object.keys(n).reduce((e,r)=>(e[r]=[n[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function i_(){return(i_=Q(function*(t,n={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t=`${t}${mse}${pse}`);const e=new gse(t,n);return yield e.load(),e})).apply(this,arguments)}function Ee(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the CPU backend.`)})}B(340),Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const jse=HI;let Gse=(()=>{class t extends l0{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new D$(this,Ki())}nextDataId(){return t.nextDataId++}write(e,r,s){this.firstUse&&(this.firstUse=!1,ne().get("IS_NODE")&&Ru("\n============================\nHi there \u{1f44b}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&md(s[0])){const i=s.map(a=>mh(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,i){this.data.set(e,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return Q(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?Ci(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.data.get(e).values}bufferSync(e){const r=this.readSync(e.dataId);let s=r;if("string"===e.dtype)try{s=r.map(o=>mu(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xt(e.shape,e.dtype,s)}makeOutput(e,r,s){const o=this.write(e,r,s);return Ki().makeTensorFromDataId(o,r,s,this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return Q(function*(){const r=Ur();return e(),{kernelMs:Ur()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ee([e],"where");const r=this.readSync(e.dataId);return jse(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();function Vt(t,n,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(Ee(i,t),"string"===i.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=o,l=a.data.get(i.dataId).values,u=te(i.shape),c=e||i.dtype,d=hu(c,u);for(let h=0;h<u;++h)d[h]=n(l[h],s);return a.makeTensorInfo(i.shape,c,d)}}function zu(t,n,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(Ee(i,t),"string"===i.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=o,l=a.data.get(i.dataId).values,u=e||i.dtype,c=n(l,u,s);return a.makeTensorInfo(i.shape,u,c)}}N2("cpu",()=>new Gse,1);const kM=Vt(Rd,t=>t>=0?t:Math.exp(t)-1),Kse={kernelName:Rd,backendName:"cpu",kernelFunc:kM};function Vo(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Xse={kernelName:Bd,backendName:"cpu",kernelFunc:Vo};function AM(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r;Ee([s],"leakyRelu");const i=te(s.shape),a=e.data.get(s.dataId).values,l=lr("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return e.makeTensorInfo(s.shape,"float32",l)}const Yse={kernelName:Pm,backendName:"cpu",kernelFunc:AM};function Rn(t){return(n,e,r,s,o)=>{const i=wt(n,e),a=i.length,l=Ve(i),c=lr(o,te(i)),d=n.length,h=e.length,f=Ve(n),p=Ve(e),m=Dh(n,i),g=Dh(e,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=t(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const b=yd(y,a,l),v=b.slice(-d);m.forEach(D=>v[D]=0);const x=Ao(v,d,f),w=b.slice(-h);g.forEach(D=>w[D]=0);const _=Ao(w,h,p);c[y]=t(r[x],s[_])}return[c,i]}}const Jse=Rn((t,n)=>t<0?n*t:t);function RM(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n;Ee([r,s],"prelu");const o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,[a,l]=Jse(r.shape,s.shape,o,i,r.dtype);return e.makeTensorInfo(l,r.dtype,a)}const Zse={kernelName:ng,backendName:"cpu",kernelFunc:RM},$M=Vt(Jd,t=>Math.max(0,t)),Qse={kernelName:Jd,backendName:"cpu",kernelFunc:$M},FM=Vt(Zd,t=>Math.min(Math.max(0,t),6)),eoe={kernelName:Zd,backendName:"cpu",kernelFunc:FM};function f_(t,n,e,r,s){if("linear"===e)return Vo({inputs:{x:n},backend:t});if("relu"===e)return $M({inputs:{x:n},backend:t});if("elu"===e)return kM({inputs:{x:n},backend:t});if("relu6"===e)return FM({inputs:{x:n},backend:t});if("prelu"===e)return RM({inputs:{x:n,alpha:r},backend:t});if("leakyrelu"===e)return AM({inputs:{x:n},backend:t,attrs:{alpha:s}});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function es(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",i)},a}const toe={kernelName:C0,backendName:"cpu",kernelFunc:es};function My(t,n,e="float32"){if("complex64"===e)return es({inputs:{real:My(t,n,"float32"),imag:My(t,n,"float32")},backend:t});const r=xr(te(n),e);return t.makeTensorInfo(n,e,r)}function al(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const noe={kernelName:J0,backendName:"cpu",kernelFunc:al};function aa(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Vo({inputs:{x:s},backend:e});const i=My(e,s.shape,s.dtype),a=aa({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=es({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=al({inputs:{input:s},backend:e}),a=aa({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!T$(s.dtype,o)){const i=Vo({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if("int32"===o){const i=e.data.get(s.dataId).values,a=Int32Array.from(i);return e.makeTensorInfo(s.shape,"int32",a)}if("bool"===o){const i=e.data.get(s.dataId).values,a=Va([0],s.dtype),[l,u]=Rn((c,d)=>c!==d?1:0)(s.shape,[],i,a,"bool");return e.makeTensorInfo(u,"bool",l)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const roe={kernelName:Sd,backendName:"cpu",kernelFunc:aa};function rr(t,n,e,r){return null==e?({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;Ee([i,a],t);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,f]=n(i.shape,a.shape,u,c,d);return l.makeTensorInfo(f,d,h)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if("complex64"===i.dtype||"complex64"===a.dtype){const u=aa({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,f=l.data.get(c.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,m=aa({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),b=g.complexTensorInfos.imag,v=l.data.get(g.complexTensorInfos.real.dataId).values,x=l.data.get(b.dataId).values,[w,_,D]=e(i.shape,a.shape,f,p,v,x),A=l.makeTensorInfo(D,"float32",w),R=l.makeTensorInfo(D,"float32",_),O=es({inputs:{real:A,imag:R},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(R),O}{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,f]=n(i.shape,a.shape,u,c,d);return l.makeTensorInfo(f,d,h)}}}function p_(t){return(n,e,r,s,o,i)=>{const a=wt(n,e),l=te(a),u=a.length,c=Ve(a),d=lr("float32",l),h=lr("float32",l),f=Dh(n,a),p=Dh(e,a),m=Ci(r,s),g=Ci(o,i),y=n.length,b=Ve(n),v=e.length,x=Ve(e);if(f.length+p.length===0)for(let w=0;w<d.length;w++){const _=w%m.length,D=w%g.length,A=t(m[2*_],m[2*_+1],g[2*D],g[2*D+1]);d[w]=A.real,h[w]=A.imag}else for(let w=0;w<d.length;w++){const _=yd(w,u,c),D=_.slice(-y);f.forEach(K=>D[K]=0);const A=Ao(D,y,b),R=_.slice(-v);p.forEach(K=>R[K]=0);const O=Ao(R,v,x),j=t(m[2*A],m[2*A+1],g[2*O],g[2*O+1]);d[w]=j.real,h[w]=j.imag}return[d,h,a]}}const OM=Rn((t,n)=>t+n),soe=p_((t,n,e,r)=>({real:t+e,imag:n+r})),ef=rr(fu,OM,soe),ooe={kernelName:fu,backendName:"cpu",kernelFunc:ef};function an(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=te(s.shape),a=N$(o,i),l=te(a);S(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const u=e.data.get(s.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const ioe={kernelName:rg,backendName:"cpu",kernelFunc:an};function MM(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;Ee([s,o],"matMul");const l=s.shape.length,u=o.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=a?o.shape[u-1]:o.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],f=a?o.shape[u-2]:o.shape[u-1],p=s.shape.slice(0,-2),m=o.shape.slice(0,-2),g=te(p),y=te(m);S(l>=2&&u>=2&&(g===y||1===g||1===y),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${p}) and (${m}).`);const x=(g>y?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([h,f]);S(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const _=a?[y,f,d]:[y,d,f],D=an({inputs:{x:s},backend:e,attrs:{shape:i?[g,c,h]:[g,h,c]}}),A=an({inputs:{x:o},backend:e,attrs:{shape:_}}),R=i?D.shape[1]:D.shape[2],O=i?D.shape[2]:D.shape[1],j=a?A.shape[1]:A.shape[2],K=Math.max(g,y),G=e.data.get(D.dataId).values,Z=e.data.get(A.dataId).values,q=Ve(D.shape),Y=Ve(A.shape),[re,ee,se]=i?[q[0],1,q[1]]:[q[0],q[1],1],[ue,de,ge]=a?[1,Y[1],Y[0]]:[Y[1],1,Y[0]],pe=O*j,ye=xt([K,O,j],D.dtype),ve=ye.values,De=e.blockSize;for(let Te=0;Te<K;Te++)for(let Be=0;Be<O;Be+=De)for(let Ue=0;Ue<j;Ue+=De)for(let st=0;st<R;st+=De){const Ct=Math.min(Be+De,O),Ut=Math.min(Ue+De,j),hn=Math.min(st+De,R);for(let nn=Be;nn<Ct;nn++)for(let Jt=Ue;Jt<Ut;Jt++){let Zt=0;for(let rn=st;rn<hn;rn++){const In=Math.min(Te,g-1)*re,Ni=Math.min(Te,y-1)*ge;Zt+=G[In+nn*ee+rn*se]*Z[rn*ue+Jt*de+Ni]}ve[Te*pe+(nn*j+Jt)]+=Zt}}return e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(A),e.makeTensorInfo(x,ye.dtype,ye.values)}const aoe={kernelName:Cm,backendName:"cpu",kernelFunc:MM},uoe={kernelName:yg,backendName:"cpu",kernelFunc:function loe(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,f,p;const m=[];h=MM({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(f=ef({inputs:{a:h,b:i},backend:e}),m.push(h),h=f),c&&(p=f_(e,h,c,a,d),m.push(h),h=p);for(const y of m)e.disposeIntermediateTensorInfo(y);return h}};function PM(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}const coe={kernelName:gm,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend;Ee(n,"abs");let r=new Float32Array(te(n.shape));return r=PM(e.data.get(n.dataId).values),e.makeOutput(r,n.shape,"float32")}},doe=Vt(vd,t=>Math.acos(t)),hoe={kernelName:vd,backendName:"cpu",kernelFunc:doe},foe=Vt(xd,t=>Math.acosh(t)),poe={kernelName:xd,backendName:"cpu",kernelFunc:foe},goe={kernelName:ym,backendName:"cpu",kernelFunc:function moe(t){const{inputs:n,backend:e}=t,r=n;Ee(n,"addN");const s=r.map(a=>e.data.get(a.dataId).values),o=xt(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function m_(t,n,e,r,s){const o=n.length,i=te(n),a=Ve(n),l=Ve(s),u=lr(e,te(s));for(let c=0;c<i;++c){const d=yd(c,o,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[r[p]];u[Ao(h,o,l)]=t[c]}return u}function js(t){const{inputs:n,attrs:e,backend:r}=t,{x:s}=n,{perm:o}=e;Ee(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[o[d]];const u=m_(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const yoe={kernelName:fg,backendName:"cpu",kernelFunc:js},voe={kernelName:"All",backendName:"cpu",kernelFunc:function boe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ee(s,"all");const a=mt(o,s.shape);let l=a;const u=wn(l,s.shape.length);let c=s;null!=u&&(c=js({inputs:{x:s},backend:e,attrs:{perm:u}}),l=kn(l.length,s.shape.length)),dr("all",l,c.shape.length);const[d,h]=tr(c.shape,l),f=te(h),p=xr(te(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=m[b];for(let x=0;x<f;++x){const w=m[b+x];v=v&&w}p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,p);if(i){const b=an({inputs:{x:g},backend:e,attrs:{shape:xn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},woe={kernelName:"Any",backendName:"cpu",kernelFunc:function xoe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ee(s,"any");const a=mt(o,s.shape);let l=a;const u=wn(l,s.shape.length);let c=s;null!=u&&(c=js({inputs:{x:s},backend:e,attrs:{perm:u}}),l=kn(l.length,s.shape.length)),dr("any",l,c.shape.length);const[d,h]=tr(c.shape,l),f=te(h),p=xr(te(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=m[b];for(let x=0;x<f;++x){const w=m[b+x];v=v||w}p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,p);if(i){const b=an({inputs:{x:g},backend:e,attrs:{shape:xn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},Ioe={kernelName:bm,backendName:"cpu",kernelFunc:function Coe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;Ee(s,"argMax");let i=mt(o,s.shape);const a=wn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=js({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=kn(i.length,l.shape.length)),i=[i[0]],dr("argMax",i,l.shape.length);const[c,d]=tr(l.shape,i),f=xr(te(c),"int32"),p=te(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],v=0;for(let x=0;x<p;++x){const w=m[y+x];w>b&&(b=w,v=x)}f[g]=v}return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}},_oe={kernelName:vm,backendName:"cpu",kernelFunc:function Doe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;Ee(s,"argMin");let i=mt(o,s.shape);const a=wn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=js({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=kn(i.length,l.shape.length)),i=[i[0]],dr("argMin",i,l.shape.length);const[c,d]=tr(l.shape,i),f=xr(te(c),"int32"),p=te(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],v=0;for(let x=0;x<p;++x){const w=m[y+x];w<b&&(b=w,v=x)}f[g]=v}return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}},Soe=Vt(wd,t=>Math.asin(t)),Eoe={kernelName:wd,backendName:"cpu",kernelFunc:Soe},Noe=Vt(Cd,t=>Math.asinh(t)),Toe={kernelName:Cd,backendName:"cpu",kernelFunc:Noe},koe=Vt(Id,t=>Math.atan(t)),Aoe={kernelName:Id,backendName:"cpu",kernelFunc:koe},Roe=Rn((t,n)=>Math.atan2(t,n)),$oe=rr(_d,Roe),Foe={kernelName:_d,backendName:"cpu",kernelFunc:$oe},Ooe=Vt(Dd,t=>Math.atanh(t)),Moe={kernelName:Dd,backendName:"cpu",kernelFunc:Ooe};function g_(t,n,e,r,s,o){const i=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,p="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=xt(s.outShape,e),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let x=0;x<s.batchSize;++x){const w=x*y,_=x*r[0];for(let D=0;D<s.inChannels;++D)for(let A=0;A<s.outHeight;++A){const R=A*i-h,O=Math.max(0,R),j=Math.min(s.inHeight,c+R),K=w+A*b;for(let G=0;G<s.outWidth;++G){const Z=G*a-f,q=Math.max(0,Z),Y=Math.min(s.inWidth,d+Z);let re=p,ee=0,se=0;for(let de=O;de<j;de+=l){const ge=_+de*r[1];for(let pe=q;pe<Y;pe+=u){const ve=t[ge+pe*r[2]+D];"max"===o&&ve>re?re=ve:"avg"===o&&(ee+=ve,se++)}if(isNaN(re))break}g[K+G*v+D]="avg"===o?ee/se:re}}}return m}function LM(t,n,e,r,s=!1,o=!1){const i=xt(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,m=xt(n,e,t);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const v=b*a-f;let x=v;for(;x<0;)x+=u;const w=Math.min(r.inHeight,d+v);for(let _=0;_<r.outWidth;++_){const D=_*l-p;let A=D;for(;A<0;)A+=c;const R=Math.min(r.inWidth,h+D);let O=Number.NEGATIVE_INFINITY,j=-1;for(let K=x;K<w;K+=u){const G=K-v;for(let Z=A;Z<R;Z+=c){const q=Z-D,Y=m.get(g,K,Z,y);Y>O&&(O=Y,j=s?o?((g*r.inHeight+K)*r.inWidth+Z)*r.inChannels+y:(K*r.inWidth+Z)*r.inChannels+y:G*h+q)}}i.set(j,g,b,_,y)}}return i}function BM(t,n,e,r,s,o){const i=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=xt(s.outShape,e),x=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],_=s.outShape[2]*s.outShape[3]*s.outShape[4],D=s.outShape[3]*s.outShape[4],A=s.outShape[4];for(let R=0;R<s.batchSize;++R){const O=R*w,j=R*r[0];for(let K=0;K<s.inChannels;++K)for(let G=0;G<s.outDepth;++G){const Z=G*i-m;let q=Z;for(;q<0;)q+=u;const Y=Math.min(s.inDepth,h+Z),re=O+G*_;for(let ee=0;ee<s.outHeight;++ee){const se=ee*a-g;let ue=se;for(;ue<0;)ue+=c;const de=Math.min(s.inHeight,f+se),ge=re+ee*D;for(let pe=0;pe<s.outWidth;++pe){const ye=pe*l-y;let ve=ye;for(;ve<0;)ve+=d;const De=Math.min(s.inWidth,p+ye),Te=ge+pe*A;let Be=b,Ue=0,st=0;for(let Ut=q;Ut<Y;Ut+=u){const hn=j+Ut*r[1];for(let nn=ue;nn<de;nn+=c){const Jt=hn+nn*r[2];for(let Zt=ve;Zt<De;Zt+=d){const In=t[Jt+Zt*r[3]+K];if("max"===o&&In>Be?Be=In:"avg"===o&&(Ue+=In,st++),isNaN(Be))break}if(isNaN(Be))break}if(isNaN(Be))break}x[Te+K]="avg"===o?Ue/st:Be}}}}return v}const Boe={kernelName:xm,backendName:"cpu",kernelFunc:function Loe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Ee(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(cr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Fs(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&zt(c.inShape,c.outShape))d=Vo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Ve(s.shape),p=g_(h,0,s.dtype,f,c,"avg");d=e.makeTensorInfo(c.outShape,s.dtype,p.values)}return d}},Voe={kernelName:wm,backendName:"cpu",kernelFunc:function zoe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Ee(s,"avgPool3d");const c=pi(s.shape,o,i,1,a,l,u),h=BM(e.data.get(s.dataId).values,0,s.dtype,Ve(s.shape),c,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},Hoe={kernelName:x0,backendName:"cpu",kernelFunc:function Uoe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Ee([s,o],"avgPool3DGrad");const c=pi(o.shape,i,a,1,l,u),d=c.strideDepth,h=c.strideHeight,f=c.strideWidth,p=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,_=c.effectiveFilterWidth,D=x-1-c.padInfo.front,A=_-1-c.padInfo.left,R=w-1-c.padInfo.top,O=xt(o.shape,"float32"),j=1/(p*m*g),K=e.bufferSync(s);for(let G=0;G<c.batchSize;++G)for(let Z=0;Z<c.inChannels;++Z)for(let q=0;q<c.inDepth;++q)for(let Y=0;Y<c.inHeight;++Y)for(let re=0;re<c.inWidth;++re){const ee=q-D,se=Y-R,ue=re-A;let de=0;for(let ge=0;ge<x;ge+=y){const pe=(ee+ge)/d;if(!(pe<0||pe>=c.outDepth||Math.floor(pe)!==pe))for(let ye=0;ye<w;ye+=b){const ve=(se+ye)/h;if(!(ve<0||ve>=c.outHeight||Math.floor(ve)!==ve))for(let De=0;De<_;De+=v){const Te=(ue+De)/f;Te<0||Te>=c.outWidth||Math.floor(Te)!==Te||(de+=K.get(G,pe,ve,Te,Z))}}}O.set(de*j,G,q,Y,re,Z)}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},joe={kernelName:v0,backendName:"cpu",kernelFunc:function Woe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;Ee([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Fs(i.shape,a,l,1,u),d=c.strideHeight,h=c.strideWidth,f=c.filterHeight,p=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=xt(i.shape,"float32"),_=1/(f*p),D=e.data.get(s.dataId).values,A=xt(s.shape,"float32",D);for(let R=0;R<c.batchSize;++R)for(let O=0;O<c.inChannels;++O)for(let j=0;j<c.inHeight;++j)for(let K=0;K<c.inWidth;++K){const G=j-x,Z=K-v;let q=0;for(let Y=0;Y<y;Y+=m){const re=(G+Y)/d;if(!(re<0||re>=c.outHeight||Math.floor(re)!==re))for(let ee=0;ee<b;ee+=g){const se=(Z+ee)/h;se<0||se>=c.outWidth||Math.floor(se)!==se||(q+=A.get(R,re,se,O))}}w.set(q*_,R,j,K,O)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},qoe={kernelName:Fm,backendName:"cpu",kernelFunc:function Goe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,scale:o,offset:i,mean:a,variance:l}=n;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ee([s,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,f=o?e.data.get(o.dataId).values:new Float32Array([1]),p=i?e.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=p.length,y=f.length,b=h.length,v=d.length;let x=0,w=0,_=0,D=0;for(let A=0;A<c.length;++A)m[A]=p[x++]+(c[A]-d[w++])*f[_++]/Math.sqrt(h[D++]+u),x>=g&&(x=0),w>=v&&(w=0),_>=y&&(_=0),D>=b&&(D=0);return e.makeTensorInfo(s.shape,s.dtype,m)}};function zM(t,n,e,r,s){const o=MC(r,n,e),i=te(e),a=Ve(r);if(o){const d=PC(n,a);return"string"===s?t.slice(d,d+i):t.subarray(d,d+i)}const u=xt(r,s,"string"===s?UI(t):t),c=xt(e,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),f=h.map((p,m)=>p+n[m]);c.set(u.get(...f),...h)}return"string"===s?oF(c.values):c.values}function ll(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r;Ee(s,"slice");const[a,l]=Ag(s,o,i);OC(s,a,l);const c=zM(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,c)}const Koe={kernelName:lg,backendName:"cpu",kernelFunc:ll},Yoe={kernelName:Im,backendName:"cpu",kernelFunc:function Xoe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;Ee([s],"batchToSpaceND");const a=o.reduce((y,b)=>y*b),l=Fh(s.shape,o,a),u=Oh(l.length,o.length),c=Mh(s.shape,o,a),d=kI(i,o.length),h=AI(c,i,o.length),f=an({inputs:{x:s},backend:e,attrs:{shape:l}}),p=js({inputs:{x:f},backend:e,attrs:{perm:u}}),m=an({inputs:{x:p},backend:e,attrs:{shape:c}}),g=ll({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}};function y_(t,n,e,r,s){const o=te(r),i=xr(s,e);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i[l]+=o>0?n[a]:1)}return i}function VM(t,n,e,r=!1){const s=t.shape[0],o=t.shape[1],i=xt([s,e],n.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const u=t.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||i.set(r?1:n.size>0?i.get(a,u)+n.get(a,l):i.get(a,u)+1,a,u)}return i}const Zoe={kernelName:w0,backendName:"cpu",kernelFunc:function Joe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,u=y_(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}};function Vu(t){return(n,e,r)=>{const s=lr(e,n.length);for(let o=0;o<n.length;++o)s[o]=t(n[o],r);return s}}const UM=Vu(t=>Math.ceil(t)),Qoe=zu(Ed,UM),eie={kernelName:Ed,backendName:"cpu",kernelFunc:Qoe},tie=Vt(Nd,(t,n)=>t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t),nie={kernelName:Nd,backendName:"cpu",kernelFunc:tie},rie={kernelName:Dm,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend,r=new Float32Array(te(n.shape)),s=e.data.get(n.dataId),i=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],l[u]);return e.makeOutput(r,n.shape,"float32")}};function HM(t,n,e,r){const s=hu(e,te(n));if(r&&"string"!==e){let o=0;t.forEach(i=>{const a=te(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a="string"===e?UI(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*n[1]+o;for(let d=0;d<i.shape[1];++d)s[c+d]=a[l++]}o+=i.shape[1]})}return s}function Uu(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const sie={kernelName:B0,backendName:"cpu",kernelFunc:Uu};function Hu(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=mt(s,n[0].shape)[0];let i=wi(n.map(m=>m.shape),o);if(0===te(i))return e.makeTensorInfo(i,n[0].dtype,[]);const a=n.filter(m=>te(m.shape)>0);if(1===a.length)return Vo({inputs:{x:a[0]},backend:e});if(EI(a.map(m=>m.shape),o),"complex64"===a[0].dtype){const m=a.map(x=>al({inputs:{input:x},backend:e})),g=a.map(x=>Uu({inputs:{input:x},backend:e})),y=Hu({inputs:m,backend:e,attrs:{axis:o}}),b=Hu({inputs:g,backend:e,attrs:{axis:o}}),v=es({inputs:{real:y,imag:b},backend:e});return m.forEach(x=>e.disposeIntermediateTensorInfo(x)),g.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),v}const u=a.map(m=>{const y=[-1,te(m.shape.slice(o))];return an({inputs:{x:m},backend:e,attrs:{shape:y}})}),c=u.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));i=wi(u.map(m=>m.shape),1);const h=HM(c,i,n[0].dtype,1===u[0].shape[0]),f=wi(a.map(m=>m.shape),o),p=e.makeTensorInfo(f,n[0].dtype,h);return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}const oie={kernelName:_m,backendName:"cpu",kernelFunc:Hu};function WM(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Ee([s,o],"conv2d");const d=mi(l),h=er(s.shape,o.shape,i,u,a,c,!1,d),f=h.filterHeight,p=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new Zn(h.outShape,s.dtype),w=Ve(s.shape),_=Ve(o.shape),D=w[0],A=v?w[1]:w[2],R=v?w[2]:1,O=v?1:w[1],j=x.strides[0],K=v?x.strides[1]:x.strides[2],G=v?x.strides[2]:1,Z=v?1:x.strides[1],q=e.data.get(s.dataId).values,Y=e.data.get(o.dataId).values,re=x.values;for(let ee=0;ee<h.batchSize;++ee){const se=ee*D,ue=ee*j;for(let de=0;de<h.outHeight;++de){const ge=ue+de*K,pe=de*h.strideHeight-b;for(let ye=0;ye<f;++ye){const ve=pe+ye*m;if(ve<0||ve>=h.inHeight)continue;const De=ye*_[0],Te=se+ve*A;for(let Be=0;Be<h.outWidth;++Be){const Ue=ge+Be*G,st=Be*h.strideWidth-y;for(let Ct=0;Ct<p;++Ct){const Ut=st+Ct*g;if(Ut<0||Ut>=h.inWidth)continue;const nn=Te+Ut*R;let Jt=De+Ct*_[1];for(let Zt=0;Zt<h.inChannels;++Zt){const rn=q[nn+Zt*O];for(let In=0;In<h.outChannels;++In)re[Ue+In*Z]+=rn*Y[Jt+In];Jt+=h.outChannels}}}}}}return e.makeTensorInfo(x.shape,x.dtype,re)}const iie={kernelName:Sm,backendName:"cpu",kernelFunc:WM},lie={kernelName:I0,backendName:"cpu",kernelFunc:function aie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Ee([s,o],"conv2dBackpropFilter");const d=mi(l),h=er(s.shape,c,i,1,a,u,!1,d),{strideHeight:f,strideWidth:p,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new Zn(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=e.data.get(s.dataId).values,_=e.data.get(o.dataId).values,D=new Zn(s.shape,s.dtype,w),A=new Zn(o.shape,o.dtype,_);for(let R=0;R<m;++R){const O=Math.max(0,Math.ceil((x-R)/f)),j=Math.min(h.outHeight,(h.inHeight+x-R)/f);for(let K=0;K<g;++K){const G=Math.max(0,Math.ceil((v-K)/p)),Z=Math.min(h.outWidth,(h.inWidth+v-K)/p);for(let q=0;q<h.inChannels;++q)for(let Y=0;Y<h.outChannels;++Y){let re=0;for(let ee=0;ee<h.batchSize;++ee)for(let se=O;se<j;++se){const ue=R+se*f-x;for(let de=G;de<Z;++de){const ge=K+de*p-v;re+=y?D.get(ee,ue,ge,q)*A.get(ee,se,de,Y):D.get(ee,q,ue,ge)*A.get(ee,Y,se,de)}}b.set(re,R,K,q,Y)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},cie={kernelName:Em,backendName:"cpu",kernelFunc:function uie(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Ee([s,o],"conv2dBackpropInput");const d=Ve(o.shape),h=Ve(s.shape);let f=mi(u);const p=er(i,o.shape,a,1,l,c,!1,f),m=new Zn(p.inShape,"float32"),g=m.values,y=e.data.get(s.dataId).values,b=e.data.get(o.dataId).values,[v,x,w]=d,{batchSize:_,filterHeight:D,filterWidth:A,inChannels:R,inHeight:O,inWidth:j,outChannels:K,outHeight:G,outWidth:Z,strideHeight:q,strideWidth:Y}=p;f=p.dataFormat;const re=D-1-p.padInfo.top,ee=A-1-p.padInfo.left,se="channelsLast"===f,ue=m.strides[0],de=se?m.strides[1]:m.strides[2],ge=se?m.strides[2]:1,pe=se?1:m.strides[1],ye=h[0],ve=se?h[1]:h[2],De=se?h[2]:1,Te=se?1:h[1];for(let Be=0;Be<_;++Be)for(let Ue=0;Ue<R;++Ue)for(let st=0;st<O;++st){const Ct=st-re,Ut=Math.max(0,Math.ceil(Ct/q)),hn=Math.min(G,(D+Ct)/q);for(let nn=0;nn<j;++nn){const Jt=nn-ee,Zt=Math.max(0,Math.ceil(Jt/Y)),rn=Math.min(Z,(A+Jt)/Y);let In=0;for(let pr=Ut;pr<hn;++pr){const Ho=pr*q-Ct;for(let Cs=Zt;Cs<rn;++Cs){const bo=ye*Be+ve*pr+De*Cs,Ti=v*(D-1-Ho)+x*(A-1-(Cs*Y-Jt))+w*Ue;for(let da=0;da<K;++da)In+=y[bo+Te*da]*b[Ti+da]}}g[ue*Be+de*st+ge*nn+pe*Ue]=In}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},hie={kernelName:Nm,backendName:"cpu",kernelFunc:function die(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r;Ee([s,o],"conv3d");const u=Yi(s.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new Zn(u.outShape,s.dtype),w=e.data.get(s.dataId).values,_=e.data.get(o.dataId).values,D=x.values,A=Ve(s.shape),R=Ve(o.shape);for(let O=0;O<u.batchSize;++O){const j=O*A[0],K=O*x.strides[0];for(let G=0;G<u.outDepth;++G){const Z=K+G*x.strides[1],q=G*u.strideDepth-y;for(let Y=0;Y<c;++Y){const re=q+Y*f;if(re<0||re>=u.inDepth)continue;const ee=Y*R[0],se=j+re*A[1];for(let ue=0;ue<u.outHeight;++ue){const de=Z+ue*x.strides[2],ge=ue*u.strideHeight-v;for(let pe=0;pe<d;++pe){const ye=ge+pe*p;if(ye<0||ye>=u.inHeight)continue;const ve=ee+pe*R[1],De=se+ye*A[2];for(let Te=0;Te<u.outWidth;++Te){const Be=de+Te*u.outChannels,Ue=Te*u.strideWidth-b;for(let st=0;st<h;++st){const Ct=Ue+st*m;if(Ct<0||Ct>=u.inWidth)continue;const hn=De+Ct*u.inChannels;let nn=ve+st*R[2];for(let Jt=0;Jt<u.inChannels;++Jt){const Zt=w[hn+Jt];for(let rn=0;rn<u.outChannels;++rn)D[Be+rn]+=Zt*_[nn+rn];nn+=u.outChannels}}}}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},pie={kernelName:D0,backendName:"cpu",kernelFunc:function fie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r;Ee([s,o],"conv3dBackpropFilterV2");const u=Ve(s.shape),c=Ve(o.shape),d=Yi(s.shape,l,i,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Zn(d.filterShape,"float32"),v=b.values,[x,w,_,D]=b.strides,A=e.data.get(o.dataId).values,[R,O,j,K]=c,G=e.data.get(s.dataId).values,[Z,q,Y,re]=u,ee=d.padInfo.front,se=d.padInfo.left,ue=d.padInfo.top;for(let de=0;de<m;++de){const ge=Math.max(0,Math.ceil((ee-de)/h)),pe=Math.min(d.outDepth,(d.inDepth+ee-de)/h),ye=de*x;for(let ve=0;ve<g;++ve){const De=Math.max(0,Math.ceil((ue-ve)/f)),Te=Math.min(d.outHeight,(d.inHeight+ue-ve)/f),Be=ve*w+ye;for(let Ue=0;Ue<y;++Ue){const st=Math.max(0,Math.ceil((se-Ue)/p)),Ct=Math.min(d.outWidth,(d.inWidth+se-Ue)/p),Ut=Ue*_+Be;for(let hn=0;hn<d.inChannels;++hn){const nn=hn*D+Ut;for(let Jt=0;Jt<d.outChannels;++Jt){let Zt=0;for(let rn=0;rn<d.batchSize;++rn){const In=rn*Z,Ni=rn*R;for(let pr=ge;pr<pe;++pr){const Cs=(de+pr*h-ee)*q+In,hl=pr*O+Ni;for(let bo=De;bo<Te;++bo){const da=(ve+bo*f-ue)*Y+Cs,ha=bo*j+hl;for(let fa=st;fa<Ct;++fa)Zt+=G[(Ue+fa*p-se)*re+da+hn]*A[fa*K+ha+Jt]}}}v[nn+Jt]=Zt}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},gie={kernelName:_0,backendName:"cpu",kernelFunc:function mie(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r;Ee([s],"conv3dBackpropInputV2");const u=Ve(s.shape),c=Ve(o.shape),d=Yi(l,o.shape,a,1,i),h=new Zn(d.inShape,"float32"),f=h.values,[p,m,g,y]=h.strides,b=e.data.get(s.dataId).values,[v,x,w,_]=u,D=e.data.get(o.dataId).values,[A,R,O,j]=c,{batchSize:K,filterDepth:G,filterHeight:Z,filterWidth:q,inChannels:Y,inDepth:re,inHeight:ee,inWidth:se,outChannels:ue,outDepth:de,outHeight:ge,outWidth:pe,strideDepth:ye,strideHeight:ve,strideWidth:De}=d,Te=G-1-d.padInfo.front,Be=Z-1-d.padInfo.top,Ue=q-1-d.padInfo.left;for(let st=0;st<K;++st)for(let Ct=0;Ct<Y;++Ct)for(let Ut=0;Ut<re;++Ut){const hn=Ut-Te,nn=Math.max(0,Math.ceil(hn/ye)),Jt=Math.min(de,(G+hn)/ye);for(let Zt=0;Zt<ee;++Zt){const rn=Zt-Be,In=Math.max(0,Math.ceil(rn/ve)),Ni=Math.min(ge,(Z+rn)/ve);for(let pr=0;pr<se;++pr){const Ho=pr-Ue,Cs=Math.max(0,Math.ceil(Ho/De)),hl=Math.min(pe,(q+Ho)/De);let bo=0;for(let Ti=nn;Ti<Jt;++Ti){const da=Ti*ye-hn;for(let ha=In;ha<Ni;++ha){const fa=ha*ve-rn;for(let ff=Cs;ff<hl;++ff){const U_=v*st+x*Ti+w*ha+_*ff,Fxe=A*(G-1-da)+R*(Z-1-fa)+O*(q-1-(ff*De-Ho))+j*Ct;for(let rb=0;rb<ue;++rb)bo+=b[U_+rb]*D[Fxe+rb]}}}f[p*st+m*Ut+g*Zt+y*pr+Ct]=bo}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},yie=Vt(Td,t=>Math.cos(t)),bie={kernelName:Td,backendName:"cpu",kernelFunc:yie},vie=Vt(kd,t=>Math.cosh(t)),xie={kernelName:kd,backendName:"cpu",kernelFunc:vie},Cie={kernelName:S0,backendName:"cpu",kernelFunc:function wie(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,[c,d,h,f]=s.shape,p=o.shape[0],[m,g]=a,y=xt([p,m,g,f],"float32"),b=e.data.get(o.dataId).values,v=e.data.get(i.dataId).values,x=e.data.get(s.dataId).values,w=Ve(s.shape),_=Ve(y.shape);for(let D=0;D<p;D++){const A=4*D,R=b[A],O=b[A+1],j=b[A+2],K=b[A+3],G=v[D];if(G>=c)continue;const Z=m>1?(j-R)*(d-1)/(m-1):0,q=g>1?(K-O)*(h-1)/(g-1):0;for(let Y=0;Y<m;Y++){const re=m>1?R*(d-1)+Y*Z:.5*(R+j)*(d-1);if(re<0||re>d-1)for(let ee=0;ee<g;ee++)for(let se=0;se<f;se++)y.values[se+ee*_[2]+Y*_[1]+D*_[0]]=u;else if("bilinear"===l){const ee=Math.floor(re),se=Math.ceil(re),ue=re-ee;for(let de=0;de<g;de++){const ge=g>1?O*(h-1)+de*q:.5*(O+K)*(h-1);if(ge<0||ge>h-1){for(let De=0;De<f;De++)y.values[De+de*_[2]+Y*_[1]+D*_[0]]=u;continue}const pe=Math.floor(ge),ye=Math.ceil(ge),ve=ge-pe;for(let De=0;De<f;De++){let Te=De+pe*w[2]+ee*w[1]+G*w[0];const Be=x[Te];Te=De+ye*w[2]+ee*w[1]+G*w[0];const Ue=x[Te];Te=De+pe*w[2]+se*w[1]+G*w[0];const st=x[Te];Te=De+ye*w[2]+se*w[1]+G*w[0];const Ct=x[Te],Ut=Be+(Ue-Be)*ve;Te=De+de*_[2]+Y*_[1]+D*_[0],y.values[Te]=Ut+(st+(Ct-st)*ve-Ut)*ue}}}else for(let ee=0;ee<g;++ee){const se=g>1?O*(h-1)+ee*q:.5*(O+K)*(h-1);if(se<0||se>h-1){for(let ge=0;ge<f;ge++)y.values[ge+ee*_[2]+Y*_[1]+D*_[0]]=u;continue}const ue=Math.round(se),de=Math.round(re);for(let ge=0;ge<f;ge++)y.values[ge+ee*_[2]+Y*_[1]+D*_[0]]=x[ge+ue*w[2]+de*w[1]+G*w[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},Die={kernelName:Tm,backendName:"cpu",kernelFunc:function Iie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;Ee(s,"cumsum");const l=wn([o],s.shape.length);let u=s;null!=l&&(u=js({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=kn(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=ps(u.dtype,"int32"),h=xr(te(u.shape),d),f=e.data.get(u.dataId).values,p=u.shape[u.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const v=m(y,b);if(0===b)h[v]=i?0:f[v];else{const x=m(y,b-1);h[v]=i?f[x]+h[x]:f[v]+h[x]}}const g=e.makeTensorInfo(u.shape,d,h);if(null!=l){const b=js({inputs:{x:g},backend:e,attrs:{perm:_u(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(u),b}return g}},Sie={kernelName:E0,backendName:"cpu",kernelFunc:function _ie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const c=y_(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const c=VM(e.bufferSync(s),e.bufferSync(o),i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},Nie={kernelName:N0,backendName:"cpu",kernelFunc:function Eie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r;S("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`),S(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*o,h=u*o,f=c/(o*o),p=e.data.get(s.dataId).values,m=new Float32Array(a*d*h*f);let g=0;for(let y=0;y<a;++y)for(let b=0;b<d;++b){const v=Math.floor(b/o),x=b%o;for(let w=0;w<h;++w){const _=Math.floor(w/o),A=(x*o+w%o)*f;for(let R=0;R<f;++R)m[g++]=p[R+A+c*(_+u*(v+l*y))]}}return e.makeTensorInfo([a,d,h,f],s.dtype,m)}};function jM(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;Ee([s,o],"depthwiseConv2DNative");const c=Ve(s.shape),d=Ve(o.shape);let h=l;null==h&&(h=[1,1]),S(cr(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const f=er(s.shape,o.shape,i,h,a,u,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=f,v=b.left,x=b.top,w=f.outChannels/f.inChannels,_=new Zn(f.outShape,s.dtype),D=e.data.get(s.dataId).values,A=e.data.get(o.dataId).values,R=_.values;for(let O=0;O<f.batchSize;++O){const j=O*c[0],K=O*_.strides[0];for(let G=0;G<f.outHeight;++G){const Z=K+G*_.strides[1],q=G*f.strideHeight-v;for(let Y=0;Y<p;++Y){const re=q+Y*g;if(re<0||re>=f.inHeight)continue;const ee=Y*d[0],se=j+re*c[1];for(let ue=0;ue<f.outWidth;++ue){const de=Z+ue*_.strides[2],ge=ue*f.strideWidth-x;for(let pe=0;pe<m;++pe){const ye=ge+pe*y;if(ye<0||ye>=f.inWidth)continue;const De=se+ye*f.inChannels;let Te=de,Be=ee+pe*d[1];for(let Ue=0;Ue<f.inChannels;++Ue){const st=D[De+Ue];for(let Ct=0;Ct<w;++Ct)R[Te+Ct]+=st*A[Be+Ct];Te+=w,Be+=w}}}}}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const Tie={kernelName:km,backendName:"cpu",kernelFunc:jM},Aie={kernelName:T0,backendName:"cpu",kernelFunc:function kie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Ee([s,o],"depthwiseConv2dNativeBackpropFilter");const d=er(s.shape,c,i,a,l,u,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:m}=d,g=new Zn(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=e.data.get(s.dataId).values,w=new Zn(s.shape,s.dtype,x),_=e.data.get(o.dataId).values,D=new Zn(o.shape,o.dtype,_);for(let A=0;A<p;++A){const R=Math.max(0,Math.ceil((b-A)/h)),O=Math.min(d.outHeight,(d.inHeight+b-A)/h);for(let j=0;j<m;++j){const K=Math.max(0,Math.ceil((y-j)/f)),G=Math.min(d.outWidth,(d.inWidth+y-j)/f);for(let Z=0;Z<d.outChannels;++Z){const q=Math.trunc(Z/v),Y=Z%v;let re=0;for(let ee=0;ee<d.batchSize;++ee)for(let se=R;se<O;++se){const ue=A+se*h-b;for(let de=K;de<G;++de)re+=w.get(ee,ue,j+de*f-y,q)*D.get(ee,se,de,Z)}g.set(re,A,j,q,Y)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},$ie={kernelName:k0,backendName:"cpu",kernelFunc:function Rie(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Ee([s,o],"depthwiseConv2DNativeBackpropInput");const d=Ve(s.shape),h=Ve(o.shape),f=er(c,o.shape,i,a,l,u,!0),p=new Zn(f.inShape,"float32"),m=p.values,[g,y,b]=p.strides,v=e.data.get(s.dataId).values,[x,w,_]=d,D=e.data.get(o.dataId).values,[A,R,O]=h,{batchSize:j,filterHeight:K,filterWidth:G,inChannels:Z,inHeight:q,inWidth:Y,outChannels:re,outHeight:ee,outWidth:se,strideHeight:ue,strideWidth:de}=f,ge=K-1-f.padInfo.top,pe=G-1-f.padInfo.left,ye=re/Z;for(let ve=0;ve<j;++ve)for(let De=0;De<Z;++De)for(let Te=0;Te<q;++Te){const Be=Te-ge,Ue=Math.max(0,Math.ceil(Be/ue)),st=Math.min(ee,(K+Be)/ue);for(let Ct=0;Ct<Y;++Ct){const Ut=Ct-pe,hn=Math.max(0,Math.ceil(Ut/de)),nn=Math.min(se,(G+Ut)/de);let Jt=0;for(let Zt=Ue;Zt<st;++Zt){const rn=Zt*ue-Be;for(let In=hn;In<nn;++In){const pr=x*ve+w*Zt+_*In,Ho=A*(K-1-rn)+R*(G-1-(In*de-Ut))+O*De;for(let Cs=0;Cs<ye;++Cs)Jt+=v[pr+(De*ye+Cs)]*D[Ho+Cs]}}m[g*ve+y*Te+b*Ct+De]=Jt}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},Oie={kernelName:"Diag",backendName:"cpu",kernelFunc:function Fie(t){const{inputs:n,backend:e}=t,{x:r}=n,s=te(r.shape),o=e.data.get(r.dataId).values,i=xt([s,s],r.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*s+u]=o[u];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}},Mie={kernelName:Am,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s}=t,{strides:o,pad:i,dilations:a}=e,l=n,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:f,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:_,filterWidth:D,dilationHeight:A,dilationWidth:R,outShape:O}=wh(r.shape,s.shape,o,i,"NHWC",a),j=te(O),K=O.length,G=hu(r.dtype,j);for(let q=0;q<f;++q)for(let Y=0;Y<y;++Y){const re=Y*x-v.top;for(let ee=0;ee<b;++ee){const se=ee*w-v.left;for(let ue=0;ue<g;++ue){let de=Number.MIN_SAFE_INTEGER;for(let pe=0;pe<_;++pe){const ye=re+pe*A;if(ye>=0&&ye<p)for(let ve=0;ve<D;++ve){const De=se+ve*R;if(De>=0&&De<m){const Te=Ao([q,ye,De,ue],c,Ve(r.shape)),Be=Ao([pe,ve,ue],h,Ve(s.shape)),Ue=u[Te]+d[Be];Ue>de&&(de=Ue)}}}G[Ao([q,Y,ee,ue],K,Ve(O))]=de}}}return{dataId:l.write(Va(G,r.dtype),O,r.dtype),shape:O,dtype:r.dtype}}},Pie={kernelName:R0,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=Rs(r.shape,u.data.get(r.dataId).values),d=Rs(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:_,dilationHeight:D,dilationWidth:A,outShape:R}=wh(r.shape,s.shape,i,a,"NHWC",l);S(o.rank===R.length,()=>`Error in ${R0}, dy must have the same rank as output ${R.length}, but got ${o.rank}`);const O=Rs(R,u.data.get(o.dataId).values),j=R$(s.shape,s.dtype);for(let G=0;G<h;++G)for(let Z=0;Z<g;++Z){const q=Z*v-b.top;for(let Y=0;Y<y;++Y){const re=Y*x-b.left;for(let ee=0;ee<m;++ee){let se=Number.MIN_SAFE_INTEGER,ue=0,de=0;for(let ge=0;ge<w;++ge){const pe=q+ge*D;if(pe>=0&&pe<f)for(let ye=0;ye<_;++ye){const ve=re+ye*A;if(ve>=0&&ve<p){const De=c[G][pe][ve][ee]+d[ge][ye][ee];De>se&&(se=De,ue=ge,de=ye)}}}j[ue][de][ee]+=O[G][Z][Y][ee]}}}return{dataId:u.write(Va(j,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Lie={kernelName:A0,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=Rs(r.shape,u.data.get(r.dataId).values),d=Rs(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:_,dilationHeight:D,dilationWidth:A,outShape:R}=wh(r.shape,s.shape,i,a,"NHWC",l);S(o.rank===R.length,()=>`Error in ${A0}, dy must have the same rank as output ${R.length}, but got ${o.rank}`);const O=Rs(R,u.data.get(o.dataId).values),j=R$(r.shape,r.dtype);for(let G=0;G<h;++G)for(let Z=0;Z<g;++Z){const q=Z*v-b.top;for(let Y=0;Y<y;++Y){const re=Y*x-b.left;for(let ee=0;ee<m;++ee){let se=Number.MIN_SAFE_INTEGER,ue=q<0?0:q,de=re<0?0:re;for(let ge=0;ge<w;++ge){const pe=q+ge*D;if(pe>=0&&pe<f)for(let ye=0;ye<_;++ye){const ve=re+ye*A;if(ve>=0&&ve<p){const De=c[G][pe][ve][ee]+d[ge][ye][ee];De>se&&(se=De,ue=pe,de=ve)}}}j[G][ue][de][ee]+=O[G][Z][Y][ee]}}}return{dataId:u.write(Va(j,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},zie={kernelName:$0,backendName:"cpu",kernelFunc:function Bie(t){const{inputs:n,backend:e}=t,{dy:r,y:s}=n;Ee([r,s],"eluGrad");const o=new Float32Array(te(s.shape)),i=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];o[l]=u>=1?a[l]:a[l]*(u+1)}return e.makeTensorInfo(s.shape,"float32",o)}},Vie=Rn((t,n)=>t===n?1:0),GM=rr(Rm,Vie,null,"bool"),Uie={kernelName:Rm,backendName:"cpu",kernelFunc:GM},Hie=$I,Wie=FI,jie=OI,Gie=MI,qie=PI,Kie=LI,Xie=Vt($d,t=>{const n=Math.sign(t),e=Math.abs(t),r=1/(1+Hie*e);return n*(1-((((Kie*r+qie)*r+Gie)*r+jie)*r+Wie)*r*Math.exp(-e*e))}),Yie={kernelName:$d,backendName:"cpu",kernelFunc:Xie},qM=Vu(t=>Math.exp(t)),KM=zu(Fd,qM),Jie={kernelName:Fd,backendName:"cpu",kernelFunc:KM};function Py(t){const{inputs:n,backend:e,attrs:r}=t,{input:s}=n,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let l=o;return o<0&&(S(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),an({inputs:{x:s},backend:e,attrs:{shape:a}})}const Zie={kernelName:$m,backendName:"cpu",kernelFunc:Py},XM=Vu(t=>Math.expm1(t)),Qie=zu(Od,XM),eae={kernelName:Od,backendName:"cpu",kernelFunc:Qie},b_=Rn((t,n)=>t*n),tae=p_((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),v_=rr(Kd,b_,tae),nae={kernelName:Kd,backendName:"cpu",kernelFunc:v_},rae=Rn((t,n)=>t/n),x_=rr(Ad,rae),w_={kernelName:Ad,backendName:"cpu",kernelFunc:x_},YM=Rn((t,n)=>t-n),sae=p_((t,n,e,r)=>({real:t-e,imag:n-r})),C_=rr(uh,YM,sae),oae={kernelName:uh,backendName:"cpu",kernelFunc:C_};function JM(t,n,e){const r=t.shape,s=r[0],o=r[1],i=e.data.get(t.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,o],c=te(u),d=lr("float32",c),h=lr("float32",c);for(let g=0;g<s;g++){const y=ll({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,o]}}),b=ll({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,o]}}),v=es({inputs:{real:y,imag:b},backend:e}),{real:x,imag:w}=iae(v,n,e),_=Ci(x,w);for(let D=0;D<o;D++){const A=BI(_,D);d[g*o+D]=A.real,h[g*o+D]=A.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(v)}const f=e.makeTensorInfo(u,"float32",d),p=e.makeTensorInfo(u,"float32",h),m=es({inputs:{real:f,imag:p},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),m}function iae(t,n,e){const r=te(t.shape),s=e.data.get(t.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,i=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function aae(t){return 0==(t&t-1)}(r)){const a=I_(o,i,r,n,e),l=[t.shape[0],t.shape[1]];if(n){const u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",Gi(r,"float32")),h=Vo({inputs:{x:d},backend:e}),f=w_.kernelFunc({inputs:{a:u,b:d},backend:e}),p=w_.kernelFunc({inputs:{a:c,b:h},backend:e}),m=e.data.get(f.dataId).values,g=e.data.get(p.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}{const l=function lae(t,n,e){const r=new Float32Array(2*n);for(let s=0;s<n;s++){let o=0,i=0;for(let a=0;a<n;a++){const l=nF(s*a,n,e),u=BI(t,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(o/=n,i/=n),eF(r,o,i,s)}return r}(Ci(o,i),r,n);return J2(l)}}function I_(t,n,e,r,s){if(1===e)return{real:t,imag:n};const o=Ci(t,n),i=e/2,a=Z2(o),l=a.real,u=a.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),f=es({inputs:{real:d,imag:h},backend:s}),p=Q2(o),m=p.real,g=p.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),v=s.makeTensorInfo(y,"float32",g),x=es({inputs:{real:b,imag:v},backend:s}),w=I_(l,u,i,r,s),_=w.real,D=w.imag,A=[_.length],R=s.makeTensorInfo(A,"float32",_),O=s.makeTensorInfo(A,"float32",D),j=es({inputs:{real:R,imag:O},backend:s}),K=I_(m,g,i,r,s),G=K.real,Z=K.imag,q=[G.length],Y=s.makeTensorInfo(q,"float32",G),re=s.makeTensorInfo(q,"float32",Z),ee=es({inputs:{real:Y,imag:re},backend:s}),se=tF(e,r),ue=[se.real.length],de=s.makeTensorInfo(ue,"float32",se.real),ge=s.makeTensorInfo(ue,"float32",se.imag),pe=es({inputs:{real:de,imag:ge},backend:s}),ye=v_({inputs:{a:pe,b:ee},backend:s}),ve=ef({inputs:{a:j,b:ye},backend:s}),De=C_({inputs:{a:j,b:ye},backend:s}),Te=al({inputs:{input:ve},backend:s}),Be=al({inputs:{input:De},backend:s}),Ue=Uu({inputs:{input:ve},backend:s}),st=Uu({inputs:{input:De},backend:s}),Ct=Hu({inputs:[Te,Be],backend:s,attrs:{axis:0}}),Ut=Hu({inputs:[Ue,st],backend:s,attrs:{axis:0}}),hn=s.data.get(Ct.dataId).values,nn=s.data.get(Ut.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ge),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(ye),s.disposeIntermediateTensorInfo(ve),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(Te),s.disposeIntermediateTensorInfo(Ue),s.disposeIntermediateTensorInfo(Be),s.disposeIntermediateTensorInfo(st),s.disposeIntermediateTensorInfo(Ct),s.disposeIntermediateTensorInfo(Ut),{real:hn,imag:nn}}const cae={kernelName:"FFT",backendName:"cpu",kernelFunc:function uae(t){const{inputs:n,backend:e}=t,{input:r}=n,s=te(r.shape),o=r.shape[r.shape.length-1],a=an({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=JM(a,!1,e),u=an({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}};function D_(t){const{backend:n,attrs:e}=t,{shape:r,value:s,dtype:o}=e,i=o||gd(s),a=hu(i,te(r));return function hae(t,n,e){t.fill(n)}(a,s),n.makeTensorInfo(r,i,a)}const dae={kernelName:O0,backendName:"cpu",kernelFunc:D_},fae={kernelName:M0,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:r}=t,s=e,o=lr(r.dtype,te(r.shape)),[i,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const f=h*l*a*u;for(let p=0;p<a;p++){const m=p*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let b=0;b<u;b++){const w=Math.round(l-[i,p,g,b][2]),_=f+m+y+b;let D=c[_];w>=0&&w<l&&(D=c[f+m+w*u+b]),o[_]=D}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},ZM=Vu(t=>Math.floor(t)),pae=zu(Md,ZM),mae={kernelName:Md,backendName:"cpu",kernelFunc:pae},gae=Rn((t,n)=>Math.floor(t/n)),yae=rr(Pd,gae,null,"int32"),bae={kernelName:Pd,backendName:"cpu",kernelFunc:yae},xae={kernelName:bg,backendName:"cpu",kernelFunc:function vae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=WM({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=ef({inputs:{a:m,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=f_(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}},Cae={kernelName:vg,backendName:"cpu",kernelFunc:function wae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=jM({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=ef({inputs:{a:m,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=f_(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}},Dae={kernelName:P0,backendName:"cpu",kernelFunc:function Iae(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=te(r.shape),i=s.shape,a=i[i.length-1],[l,u,c,d]=RI(r,s);if(0===u)return e.makeTensorInfo(l,r.dtype,[]);const h=xt([u,c],r.dtype),f=e.data.get(s.dataId).values,p=e.data.get(r.dataId).values;for(let m=0;m<u;m++){const g=[];let y=0;for(let b=0;b<a;b++){const v=f[m*a+b];y+=v*d[b],g.push(v)}if(y<0||y>=o/c)throw new Error(`Invalid indices: ${g} does not index into ${r.shape}`);for(let b=0;b<c;b++)h.values[m*c+b]=p[y*c+b]}return e.makeTensorInfo(l,h.dtype,h.values)}};function QM(t,n,e){const r=xt(e,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),u=n.locToIndex([i[0],i[2]]);i[2]=n.values[u];const c=t.locToIndex(i);r.values[s]=t.values[c]}return r}const Sae={kernelName:Om,backendName:"cpu",kernelFunc:function _ae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r;Ee([s,o],"gatherV2");let l=a;null==a&&(l=0);const u=te(o.shape),d=VI(s,o,mt(i,s.shape)[0],l),h=an({inputs:{x:s},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),f=an({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,u/d.batchSize]}}),p=[d.batchSize,d.outerSize,u/d.batchSize,d.sliceSize],m=e.bufferSync(f),y=QM(e.bufferSync(h),m,p);return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.makeTensorInfo(d.outputShape,y.dtype,y.values)}},eP=Rn((t,n)=>t>n?1:0),Eae=rr(Mm,eP,null,"bool"),Nae={kernelName:Mm,backendName:"cpu",kernelFunc:Eae},Tae=Rn((t,n)=>t>=n?1:0),kae=rr(Ld,Tae,null,"bool"),Aae={kernelName:Ld,backendName:"cpu",kernelFunc:kae},$ae={kernelName:L0,backendName:"cpu",kernelFunc:function Rae(t){const{inputs:n,backend:e}=t,{input:r}=n,s=te(r.shape),o=r.shape[r.shape.length-1],a=an({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=JM(a,!0,e),u=an({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}},Fae=Vt(zd,t=>Number.isFinite(t)?1:0,"bool"),Oae={kernelName:zd,backendName:"cpu",kernelFunc:Fae},Mae=Vt(Vd,t=>Math.abs(t)===1/0?1:0,"bool"),Pae={kernelName:Vd,backendName:"cpu",kernelFunc:Mae},Lae=Vt(Ud,t=>Number.isNaN(t)?1:0,"bool"),Bae={kernelName:Ud,backendName:"cpu",kernelFunc:Lae},tP=Rn((t,n)=>t<n?1:0),zae=rr(Lm,tP,null,"bool"),Vae={kernelName:Lm,backendName:"cpu",kernelFunc:zae},Uae=Rn((t,n)=>t<=n?1:0),Hae=rr(Bm,Uae,null,"bool"),Wae={kernelName:Bm,backendName:"cpu",kernelFunc:Hae};function nP(t,n,e){const r=(n-t)/(e-1),s=xr(e,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const Gae={kernelName:z0,backendName:"cpu",kernelFunc:function jae(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=nP(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},rP=Vu(t=>Math.log(t)),qae=zu(Hd,rP),Kae={kernelName:Hd,backendName:"cpu",kernelFunc:qae},Xae=Vt(Wd,t=>Math.log1p(t)),Yae={kernelName:Wd,backendName:"cpu",kernelFunc:Xae},Jae=Rn((t,n)=>t&&n),Zae=rr(zm,Jae,null,"bool"),Qae={kernelName:zm,backendName:"cpu",kernelFunc:Zae},ele=Vt(Vm,t=>t?0:1,"bool"),tle={kernelName:Vm,backendName:"cpu",kernelFunc:ele},nle=Rn((t,n)=>t||n),rle=rr(Um,nle,null,"bool"),sle={kernelName:Um,backendName:"cpu",kernelFunc:rle},ile={kernelName:Hm,backendName:"cpu",kernelFunc:function ole(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r;Ee(s,"LRN");const u=s.shape[3],c=u-1,d=e.data.get(s.dataId).values,h=te(s.shape),f=new Float32Array(h);function p(m){const g=m%u;let y=m-g+Math.max(0,g-o);const b=m-g+Math.min(g+o,c);let v=0;for(;y<=b;y++){const x=d[y];v+=x*x}return v}for(let m=0;m<h;m++){const g=p(m),y=d[m]*Math.pow(i+a*g,-l);f[m]=y}return e.makeTensorInfo(s.shape,s.dtype,f)}},lle={kernelName:V0,backendName:"cpu",kernelFunc:function ale(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Ee(i,"LRNGrad");const d=te(i.shape),h=i.shape[3],f=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,m=e.data.get(o.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const v=b%h,x=b-v+Math.max(0,v-a),w=b-v+Math.min(h,v+a+1);let _=0;for(let D=x;D<w;D++)_+=Math.pow(p[D],2);_=u*_+l;for(let D=x;D<w;D++){let A=-2*u*c*p[D]*m[b]/_;b===D&&(A+=Math.pow(_,-c)),A*=f[b],g[D]+=A}}return e.makeTensorInfo(i.shape,s.dtype,g)}};function sP(t,n,e,r){const s=lr(r,te(e));for(let o=0;o<s.length;++o){const i=o*n;let a=t[i];for(let l=0;l<n;++l){const u=t[i+l];u>a&&(a=u)}s[o]=a}return s}function oP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=e;let l=s.shape;const u=l.length,c=mt(o,l);let d=c;const h=wn(d,u);let f=a.data.get(s.dataId).values;if(null!=h){const x=new Array(u);for(let w=0;w<x.length;w++)x[w]=l[h[w]];f=m_(f,l,s.dtype,h,x),d=kn(d.length,u),l=x}Ee(s,"max"),dr("max",d,u);const[p,m]=tr(l,d),y=sP(f,te(m),p,s.dtype),b=a.write(y,p,s.dtype);let v=p;return i&&(v=xn(p,c)),{dataId:b,shape:v,dtype:s.dtype}}const ule={kernelName:Wm,backendName:"cpu",kernelFunc:oP},iP=Rn((t,n)=>Math.max(t,n)),cle=rr(jd,iP),dle={kernelName:jd,backendName:"cpu",kernelFunc:cle},fle={kernelName:jm,backendName:"cpu",kernelFunc:function hle(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Ee(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(cr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Fs(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&zt(c.inShape,c.outShape))d=Vo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Ve(s.shape),p=g_(h,0,s.dtype,f,c,"max");d=e.makeTensorInfo(c.outShape,s.dtype,p.values)}return d}},mle={kernelName:Gm,backendName:"cpu",kernelFunc:function ple(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Ee(s,"maxPool3d");const c=pi(s.shape,o,i,1,a,l,u),h=BM(e.data.get(s.dataId).values,0,s.dtype,Ve(s.shape),c,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},yle={kernelName:H0,backendName:"cpu",kernelFunc:function gle(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Ee([s,o],"maxPool3DGrad");const c=pi(o.shape,i,a,1,l,u),h=function Poe(t,n){const e=xt(n.outShape,"int32"),r=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,d=n.effectiveFilterWidth,h=n.padInfo.front,f=n.padInfo.top,p=n.padInfo.left;for(let m=0;m<n.batchSize;++m)for(let g=0;g<n.inChannels;++g)for(let y=0;y<n.outDepth;++y){const b=y*r-h;let v=b;for(;v<0;)v+=i;const x=Math.min(n.inDepth,u+b);for(let w=0;w<n.outHeight;++w){const _=w*s-f;let D=_;for(;D<0;)D+=a;const A=Math.min(n.inHeight,c+_);for(let R=0;R<n.outWidth;++R){const O=R*o-p;let j=O;for(;j<0;)j+=l;const K=Math.min(n.inWidth,d+O);let G=Number.NEGATIVE_INFINITY,Z=-1;for(let q=v;q<x;q+=i){const Y=q-b;for(let re=D;re<A;re+=a){const ee=re-_;for(let se=j;se<K;se+=l){const ue=se-O,de=t.get(m,q,re,se,g);de>=G&&(G=de,Z=Y*c*d+ee*c+ue)}}}e.set(Z,m,y,w,R,g)}}}return e}(e.bufferSync(o),c),f=c.strideDepth,p=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,x=c.effectiveFilterHeight,w=c.effectiveFilterWidth,_=v-1-c.padInfo.front,D=w-1-c.padInfo.left,A=x-1-c.padInfo.top,R=xt(o.shape,"float32"),O=e.bufferSync(s);for(let j=0;j<c.batchSize;++j)for(let K=0;K<c.inChannels;++K)for(let G=0;G<c.inDepth;++G)for(let Z=0;Z<c.inHeight;++Z)for(let q=0;q<c.inWidth;++q){const Y=G-_,re=Z-A,ee=q-D;let se=0;for(let ue=0;ue<v;ue+=g){const de=(Y+ue)/f;if(!(de<0||de>=c.outDepth||Math.floor(de)!==de))for(let ge=0;ge<x;ge+=y){const pe=(re+ge)/p;if(!(pe<0||pe>=c.outHeight||Math.floor(pe)!==pe))for(let ye=0;ye<w;ye+=b){const ve=(ee+ye)/m;if(ve<0||ve>=c.outWidth||Math.floor(ve)!==ve)continue;const Be=v*x*w-1-h.get(j,de,pe,ve,K)===ue*x*w+ge*w+ye?1:0;0!==Be&&(se+=O.get(j,de,pe,ve,K)*Be)}}}R.set(se,j,G,Z,q,K)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}},vle={kernelName:U0,backendName:"cpu",kernelFunc:function ble(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;Ee([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Fs(a.shape,l,u,1,c,d),f=e.data.get(a.dataId).values,p=xt(h.outShape,a.dtype,LM(f,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,_=v-1-h.padInfo.top,D=xt(a.shape,"float32"),A=e.data.get(s.dataId).values,R=xt(s.shape,"float32",A);for(let O=0;O<h.batchSize;++O)for(let j=0;j<h.inChannels;++j)for(let K=0;K<h.inHeight;++K)for(let G=0;G<h.inWidth;++G){const Z=K-_,q=G-w;let Y=0;for(let re=0;re<v;re+=y){const ee=(Z+re)/m;if(!(ee<0||ee>=h.outHeight||Math.floor(ee)!==ee))for(let se=0;se<x;se+=b){const ue=(q+se)/g;if(ue<0||ue>=h.outWidth||Math.floor(ue)!==ue)continue;const pe=v*x-1-p.get(O,ee,ue,j)===re*x+se?1:0;0!==pe&&(Y+=R.get(O,ee,ue,j)*pe)}}D.set(Y,O,K,G,j)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}},wle={kernelName:W0,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=e;Ee(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=Fs(r.shape,s,o,[1,1],i),[d,h]=function xle(t,n,e,r,s){const i=g_(t,0,e,Ve(n),s,"max"),a=LM(t,n,e,s,!0,r);return[i.values,a.values]}(u,r.shape,r.dtype,a,c),f=l.write(d,c.outShape,r.dtype),p=l.write(h,c.outShape,r.dtype);return[{dataId:f,shape:c.outShape,dtype:r.dtype},{dataId:p,shape:c.outShape,dtype:"int32"}]}};function Ly(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;let a;Ee(s,"sum"),a="bool"===s.dtype?aa({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):Vo({inputs:{x:s},backend:e});const l=a.shape.length,u=mt(o,a.shape),c=wn(u,l);let d=u,h=a;null!=c&&(h=js({inputs:{x:a},backend:e,attrs:{perm:c}}),d=kn(d.length,l)),dr("sum",d,h.shape.length);const[f,p]=tr(h.shape,d);let g=My(e,f,ps(h.dtype,"int32"));const y=te(p),b=e.data.get(g.dataId).values,v=e.data.get(h.dataId).values;for(let x=0;x<b.length;++x){const w=x*y;let _=0;for(let D=0;D<y;++D)_+=v[w+D];b[x]=_}if(i){const w=g;g=an({inputs:{x:g},backend:e,attrs:{shape:xn(g.shape,u)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=c&&e.disposeIntermediateTensorInfo(h),g}const Cle={kernelName:ug,backendName:"cpu",kernelFunc:Ly},Dle={kernelName:qm,backendName:"cpu",kernelFunc:function Ile(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=mt(o,s.shape),c=te(tr(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const f=aa({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(f);const p=x_({inputs:{a:f,b:h},backend:e});d.push(p);const m=Ly({inputs:{x:p},backend:e,attrs:{axis:o,keepDims:i}});return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}},Sle={kernelName:Km,backendName:"cpu",kernelFunc:function _le(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ee(s,"min");const a=mt(o,s.shape);let l=a;const u=wn(l,s.shape.length);let c=s;null!=u&&(c=js({inputs:{x:s},backend:e,attrs:{perm:u}}),l=kn(l.length,s.shape.length)),dr("min",l,c.shape.length);const[d,h]=tr(c.shape,l),f=te(h),p=xr(te(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=m[b];for(let x=0;x<f;++x){const w=m[b+x];w<v&&(v=w)}p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,p);if(i){const b=an({inputs:{x:g},backend:e,attrs:{shape:xn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},aP=Rn((t,n)=>Math.min(t,n)),Ele=rr(Gd,aP),Nle={kernelName:Gd,backendName:"cpu",kernelFunc:Ele},kle={kernelName:Xm,backendName:"cpu",kernelFunc:function Tle(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,mode:i}=r;Ee(s,"mirrorPad");const a=o.map((v,x)=>v[0]+s.shape[x]+v[1]),l=o.map(v=>v[0]),u=o.map((v,x)=>v[0]+s.shape[x]),c="reflect"===i?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,f=Ve(s.shape),p=te(a),m=a.length,g=Ve(a),y=lr(s.dtype,p);for(let v=0;v<p;v++){let x=yd(v,m,g);for(let _=0;_<m;_++)x[_]<l[_]?x[_]=2*l[_]-x[_]-c:x[_]>=u[_]&&(x[_]=2*(u[_]-1)-x[_]+c);x=x.map((_,D)=>_-l[D]);const w=Ao(x,h,f);y[v]=d[w]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},Ale=Rn((t,n)=>{const e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),Rle=rr(qd,Ale),$le={kernelName:qd,backendName:"cpu",kernelFunc:Rle};var Fle=B(537);function lP(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=mt([a],s.shape),u=oP({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=xn(u.shape,l),d=an({inputs:{x:u},backend:e,attrs:{shape:c}}),h=C_({inputs:{a:s,b:d},backend:e}),f=KM({inputs:{x:h},backend:e}),p=Ly({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),m=an({inputs:{x:p},backend:e,attrs:{shape:c}}),g=x_({inputs:{a:f,b:m},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}const Ole={kernelName:hg,backendName:"cpu",kernelFunc:lP},Ple={kernelName:j0,backendName:"cpu",kernelFunc:function Mle(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r;Ee(s,"multinomial");const l=a?s:lP({inputs:{logits:s},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=e.data.get(l.dataId).values,h=[u,o],f=xr(te(h),"int32");for(let p=0;p<u;++p){const m=p*c,g=new Float32Array(c-1);g[0]=d[m];for(let v=1;v<g.length;++v)g[v]=g[v-1]+d[m+v];const y=Fle.alea(i.toString()),b=p*o;for(let v=0;v<o;++v){const x=y();f[b+v]=g.length;for(let w=0;w<g.length;w++)if(x<g[w]){f[b+v]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",f)}};function uP(t,n,e){const r=Gi(-1,e);return b_([],n,r,t,e)}const Ble={kernelName:Ym,backendName:"cpu",kernelFunc:function Lle(t){const{inputs:n,backend:e}=t,{x:r}=n;Ee(r,"neg");const s=e.data.get(r.dataId).values,[o,i]=uP(s,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}},zle=uI,Ule={kernelName:G0,backendName:"cpu",kernelFunc:function Vle(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;Ee(s,"NonMaxSuppression");const u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,{selectedIndices:d}=zle(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Hle=cI,jle={kernelName:q0,backendName:"cpu",kernelFunc:function Wle(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Ee(s,"NonMaxSuppressionPadded");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,{selectedIndices:h,validOutputs:f}=Hle(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},Gle=dI,Kle={kernelName:K0,backendName:"cpu",kernelFunc:function qle(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Ee(s,"NonMaxSuppressionWithScore");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,h=i,f=a,p=l,m=u,{selectedIndices:g,selectedScores:y}=Gle(c,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},cP=Rn((t,n)=>t!==n?1:0),Xle=rr(Jm,cP,null,"bool"),Yle={kernelName:Jm,backendName:"cpu",kernelFunc:Xle},Zle={kernelName:Qm,backendName:"cpu",kernelFunc:function Jle(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{depth:o,onValue:i,offValue:a}=r;Ee(s,"oneHot");const l=te(s.shape),u=new Float32Array(l*o);u.fill(a);const c=e.data.get(s.dataId).values;for(let d=0;d<l;++d)c[d]>=0&&c[d]<o&&(u[d*o+c[d]]=i);return e.makeTensorInfo([...s.shape,o],"int32",u)}};function By(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=al({inputs:{input:r},backend:e}),o=By({inputs:{x:s},backend:e}),i=Uu({inputs:{input:r},backend:e}),a=By({inputs:{x:i},backend:e}),l=es({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return D_({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Qle={kernelName:gg,backendName:"cpu",kernelFunc:By},eue={kernelName:Zm,backendName:"cpu",kernelFunc:function dP(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=al({inputs:{input:r},backend:e}),o=dP({inputs:{x:s},backend:e}),i=Uu({inputs:{input:r},backend:e}),a=By({inputs:{x:i},backend:e}),l=es({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return D_({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function hP(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return Py({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{fs(o,c.shape,"All tensors passed to stack must have matching shapes"),S(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=Hu({inputs:n.map(c=>{const d=Py({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const tue={kernelName:eg,backendName:"cpu",kernelFunc:hP},fP={kernelName:tg,backendName:"cpu",kernelFunc:function nue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r;Ee(s,"pad");const a=o.map((b,v)=>b[0]+s.shape[v]+b[1]),l=o.map(b=>b[0]),u=e.data.get(s.dataId).values,c=te(s.shape),d=s.shape.length,h=Ve(s.shape),f=te(a),p=a.length,m=Ve(a),g=lr(s.dtype,f);0!==i&&g.fill(i);for(let b=0;b<c;b++)g[Ao(yd(b,d,h).map((_,D)=>_+l[D]),p,m)]=u[b];return{dataId:e.write(g,a,s.dtype),shape:a,dtype:s.dtype}}},rue=Rn((t,n)=>Math.pow(t,n)),sue=rr(Xd,rue),oue={kernelName:Xd,backendName:"cpu",kernelFunc:sue};function pP(t,n,e,r){const[s,o]=tr(t,r),i=ps(n,"int32"),a=xr(te(s),i),l=te(o);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=e[c+h];a[u]=d}return{outVals:a,outShape:s,outDtype:i}}const aue={kernelName:X0,backendName:"cpu",kernelFunc:function iue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ee(s,"prod");const a=s.shape.length,l=mt(o,s.shape),u=wn(l,a);let c=l,d=s;const h=[];null!=u&&(d=js({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),c=kn(c.length,a));const f=e.data.get(d.dataId).values,{outVals:p,outShape:m,outDtype:g}=pP(d.shape,d.dtype,f,c);let y=m;return i&&(y=xn(m,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,p)}};function mP(t,n,e,r){if(t===n||t<n&&e<0||n<t&&e>1)return xr(0,r);const l=xr(Math.abs(Math.ceil((n-t)/e)),r);n<t&&1===e&&(e=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}const uue={kernelName:Y0,backendName:"cpu",kernelFunc:function lue(t){const{backend:n,attrs:e}=t,{start:r,stop:s,dtype:o,step:i}=e,a=mP(r,s,i,o);return n.makeTensorInfo([a.length],o,a)}},cue=Vt(Yd,t=>1/t),due={kernelName:Yd,backendName:"cpu",kernelFunc:cue},fue={kernelName:og,backendName:"cpu",kernelFunc:function hue(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;Ee(s,"resizeBilinear");const l=Ve(s.shape),[u,c]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(te([d,u,c,p])),y=[o&&u>1?h-1:h,o&&c>1?f-1:f],b=[o&&u>1?u-1:u,o&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let _=0;_<d;_++)for(let D=0;D<u;D++){let A;A=i?x*(D+.5)-.5:x*D;const R=Math.max(0,Math.floor(A)),O=A-R,j=Math.min(h-1,Math.ceil(A)),K=_*l[0]+R*l[1],G=_*l[0]+j*l[1];for(let Z=0;Z<c;Z++){let q;q=i?w*(Z+.5)-.5:w*Z;const Y=Math.max(0,Math.floor(q)),re=q-Y,ee=Math.min(f-1,Math.ceil(q)),se=K+Y*l[2],ue=G+Y*l[2],de=K+ee*l[2],ge=G+ee*l[2];for(let pe=0;pe<p;pe++){const ye=m[se+pe],ve=m[ue+pe],Be=ye+(m[de+pe]-ye)*re;g[v++]=Be+(ve+(m[ge+pe]-ve)*re-Be)*O}}}return e.makeTensorInfo([d,u,c,p],"float32",g)}},mue={kernelName:Q0,backendName:"cpu",kernelFunc:function pue(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;Ee([o,s],"resizeBilinearGrad");const a=Ve(s.shape),[l,u,c,d]=s.shape,[,h,f]=o.shape,p=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&f>1?c-1:c],g=[i&&h>1?h-1:h,i&&f>1?f-1:f],y=m[0]/g[0],b=m[1]/g[1],v=e.data.get(o.dataId).values;let x=0;for(let w=0;w<l;w++){const _=w*a[0];for(let D=0;D<h;D++){const A=D*y,R=Math.floor(A),O=Math.min(Math.ceil(A),u-1),j=_+R*a[1],K=_+O*a[1],G=A-R,Z=1-G;for(let q=0;q<f;q++){const Y=q*b,re=Math.floor(Y),ee=Math.min(Math.ceil(Y),c-1),se=Y-re,ue=1-se,de=j+re*a[2],ge=j+ee*a[2],pe=K+re*a[2],ye=K+ee*a[2],ve=Z*ue,De=Z*se,Te=G*ue,Be=G*se;for(let Ue=0;Ue<d;Ue++){const st=v[x++];p[de+Ue]+=st*ve,p[ge+Ue]+=st*De,p[pe+Ue]+=st*Te,p[ye+Ue]+=st*Be}}}}return e.makeTensorInfo([l,c,u,d],"float32",p)}},yue={kernelName:sg,backendName:"cpu",kernelFunc:function gue(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;Ee(s,"resizeNearestNeighbor");const l=Ve(s.shape),[u,c]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(d*u*c*p),y=[o&&u>1?h-1:h,o&&c>1?f-1:f],b=[o&&u>1?u-1:u,o&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let _=0;_<d;_++){const D=_*l[0];for(let A=0;A<u;A++){const R=i?v*(A+.5):v*A;let O=Math.min(h-1,o?Math.round(R):Math.floor(R));i&&(O=Math.max(0,O));const j=D+O*l[1];for(let K=0;K<c;K++){const G=i?x*(K+.5):x*K;let Z=Math.min(f-1,o?Math.round(G):Math.floor(G));i&&(Z=Math.max(0,Z));const q=j+Z*l[2];for(let Y=0;Y<p;Y++)g[w++]=m[q+Y]}}}return e.makeTensorInfo([d,u,c,p],s.dtype,g)}},vue={kernelName:Z0,backendName:"cpu",kernelFunc:function bue(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;Ee([o,s],"resizeNearestNeighborGrad");const a=Ve(s.shape),l=Ve(o.shape),[u,c,d,h]=s.shape,[,f,p]=o.shape,m=new Float32Array(u*c*d*h),g=e.data.get(o.dataId).values,y=[i&&f>1?c-1:c,i&&p>1?d-1:d],b=[i&&f>1?f-1:f,i&&p>1?p-1:p],v=y[0]/b[0],x=y[1]/b[1],w=1/v,_=1/x,D=2*Math.ceil(w)+2,A=2*Math.ceil(_)+2;for(let R=0;R<u;R++){const O=R*a[0];for(let j=0;j<c;j++){const K=O+j*a[1],G=Math.floor(j*w),Z=Math.floor(G-D/2);for(let q=0;q<d;q++){const Y=K+q*a[2],re=Math.floor(q*_),ee=Math.floor(re-A/2);for(let se=0;se<h;se++){let ue=0;for(let de=0;de<D;de++){const ge=de+Z;if(ge<0||ge>=f)continue;const pe=O+ge*l[1],ye=ge*v;if(j===Math.min(c-1,i?Math.round(ye):Math.floor(ye)))for(let De=0;De<A;De++){const Te=De+ee;if(Te<0||Te>=p)continue;const Be=pe+Te*l[2],Ue=Te*x;q===Math.min(d-1,i?Math.round(Ue):Math.floor(Ue))&&(ue+=g[Be+se])}}m[Y+se]=ue}}}}return e.makeTensorInfo(s.shape,s.dtype,m)}},wue={kernelName:ig,backendName:"cpu",kernelFunc:function xue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r;Ee(s,"reverse");const i=s.shape.length,a=mt(o,s.shape);if(0===i)return Vo({inputs:{x:s},backend:e});const l=new Zn(s.shape,s.dtype),u=e.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();a.forEach(f=>h[f]=s.shape[f]-1-h[f]),l.set(u.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},Cue={kernelName:lC,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,l=lr(r.dtype,te(r.shape)),[u,c,d,h]=r.shape,[f,p]=TI(i,c,d),g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let x=0;x<u;x++){const w=x*d*c*h;for(let _=0;_<c;_++){const D=_*(d*h);for(let A=0;A<d;A++){const R=A*h;for(let O=0;O<h;O++){const j=[u,_,A,O],K=j[2],G=j[1];let Z=(K-f)*y-(G-p)*g,q=(K-f)*g+(G-p)*y;Z=Math.round(Z+f),q=Math.round(q+p);let Y=o;"number"!=typeof o&&(Y=3===O?255:o[O]),Z>=0&&Z<d&&q>=0&&q<c&&(Y=b[w+q*(d*h)+Z*h+O]),l[w+D+R+O]=Y}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Iue=Vt(Qd,t=>{const n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2==0?n:n+1}),Due={kernelName:Qd,backendName:"cpu",kernelFunc:Iue},gP=Vu(t=>1/Math.sqrt(t)),_ue=zu(eh,gP),Sue={kernelName:eh,backendName:"cpu",kernelFunc:_ue};function yP(t,n,e,r,s,o,i,a,l,u){const c=[r/s,s],d=t.values,h=n.values;if(0===r)return xt(e,n.dtype);const f=xt(c,n.dtype);f.values.fill(l);for(let p=0;p<o;p++){const m=[];let g=0;for(let y=0;y<i;y++){const b=d[p*i+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<s;y++)u?f.values[g*s+y]+=h[p*s+y]:f.values[g*s+y]=0===n.rank?h[0]:h[p*s+y]}return f}const Nue={kernelName:eC,backendName:"cpu",kernelFunc:function Eue(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Ph(0,s,i),m=yP(e.bufferSync(s),e.bufferSync(o),i,d,u,l,a,c,0,!0);return e.makeTensorInfo(i,m.dtype,m.values)}},kue={kernelName:ag,backendName:"cpu",kernelFunc:function Tue(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n;Ee([r,s,o],"select");const i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=ps(s.dtype,o.dtype),d=xr(te(s.shape),c);let h=0;const f=0===i||i>1||1===s.shape.length?1:te(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<f;m++)d[h++]=1===a[p]?l[p]:u[p];return e.makeTensorInfo(s.shape,c,d)}},Aue=ey,Rue=ty,$ue=Vt(th,t=>t>=0?Rue*t:Aue*(Math.exp(t)-1)),Fue={kernelName:th,backendName:"cpu",kernelFunc:$ue},Oue=Vt(oh,t=>1/(1+Math.exp(-t))),Mue={kernelName:oh,backendName:"cpu",kernelFunc:Oue},Pue=Vt(sh,t=>t<0?-1:t>0?1:0),Lue={kernelName:sh,backendName:"cpu",kernelFunc:Pue},Bue=Vt(nh,t=>Math.sin(t)),zue={kernelName:nh,backendName:"cpu",kernelFunc:Bue},Vue=Vt(rh,t=>Math.sinh(t)),Uue={kernelName:rh,backendName:"cpu",kernelFunc:Vue},bP=Math.log(1.1920928955078125e-7)+2,Hue=Vt(ih,t=>{const n=t>-bP,e=t<bP,r=Math.exp(t);let s;return s=e?r:n?t:Math.log(1+r),s}),Wue={kernelName:ih,backendName:"cpu",kernelFunc:Hue},Gue={kernelName:cg,backendName:"cpu",kernelFunc:function jue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;Ee([s],"spaceToBatchND");const a=te(o),l=[[0,0]];l.push(...i);for(let _=1+o.length;_<s.shape.length;++_)l.push([0,0]);const u=fP.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),c=Fh(u.shape,o,a,!1),d=Oh(c.length,o.length,!1),h=Mh(u.shape,o,a,!1),m=an({inputs:{x:u},backend:e,attrs:{shape:c}}),b=js({inputs:{x:m},backend:e,attrs:{perm:d}}),w=an({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),w}},Kue={kernelName:nC,backendName:"cpu",kernelFunc:function que(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Ph(0,s,a),y=yP(e.bufferSync(s),e.bufferSync(o),a,h,c,u,l,d,e.data.get(i.dataId).values[0],!1);return e.makeTensorInfo(a,y.dtype,y.values)}},Yue={kernelName:dg,backendName:"cpu",kernelFunc:function Xue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=mt(i,s.shape)[0],l=zI(s,o,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[a]=d;const f=ll({inputs:{x:s},backend:e,attrs:{begin:u,size:h}});return u[a]+=d,f})}},Jue=Vt(ah,t=>Math.sqrt(t)),Zue={kernelName:ah,backendName:"cpu",kernelFunc:Jue},Que={kernelName:tC,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t,r=n;Ee(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];o[a]=l*l}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},vP=Rn((t,n)=>{const e=t-n;return e*e}),ece=rr(lh,vP),tce={kernelName:lh,backendName:"cpu",kernelFunc:ece},nce=Vt(fh,(t,n)=>{const e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),rce={kernelName:fh,backendName:"cpu",kernelFunc:nce};function xP(t,n,e,r){const s=xt(t,n.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];s.set(n.get(...a),...i)}return s}const oce={kernelName:rC,backendName:"cpu",kernelFunc:function sce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;Ee(s,"stridedSlice");const{nonStrided:f,$begin:p,$strides:m,size:g,newShape:y,outShape:b}=LC(s.shape,o,i,a,l,u,c,d,h),v=an({inputs:{x:s},backend:e,attrs:{shape:y}});let x;if(f){const _=ll({inputs:{x:v},backend:e,attrs:{begin:p,size:g}});x=an({inputs:{x:_},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(_)}else if(b.some(_=>0===_))x=e.makeTensorInfo(b,s.dtype,[]);else{const D=xP(b,e.bufferSync(v),m,p);x=e.makeTensorInfo(D.shape,D.dtype,D.values)}const w=an({inputs:{x},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),w}},ice=Vt(ch,t=>Math.tan(t)),ace={kernelName:ch,backendName:"cpu",kernelFunc:ice},lce=Vt(dh,t=>Math.tanh(t));function wP(t,n){const e=new Array(t.rank);for(let s=0;s<e.length;s++)e[s]=t.shape[s]*n[s];const r=xt(e,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%t.shape[l];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}function CP(t,n,e,r,s){const o=n[n.length-1],[i,a]=[t.length/o,o],l=lr(e,i*r),u=lr("int32",i*r);for(let d=0;d<i;d++){const h=d*a,f=t.subarray(h,h+a),p=[];for(let b=0;b<f.length;b++)p.push({value:f[b],index:b});p.sort((b,v)=>v.value-b.value);const m=d*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const c=n.slice();return c[c.length-1]=r,[xt(c,e,l),xt(c,"int32",u)]}function IP(t,n,e){switch(e){case"reflect":return function gce(t,n){let e=t;if(e<0)if(n<=1)e=0;else{const r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{const r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return Ba(0,e,n-1)}(t,n);case"wrap":return function yce(t,n){let e=t;return e<0?n<=1?e=0:e+=n*(Math.trunc(-e/(n-1))+1):e>n-1&&(n<=1?e=0:e-=n*Math.trunc(e/(n-1))),Ba(0,e,n-1)}(t,n);case"nearest":return function vce(t,n){return Ba(0,t,n-1)}(t,n);default:return function bce(t,n){return t}(t)}}function nf(t,n,e,r,s,o,i,a,l,u,c){return 0<=a&&a<n&&0<=l&&l<e?t[i*r+a*s+l*o+u]:c}function xce(t,n,e,r,s,o,i,a,l,u,c){return nf(t,n,e,r,s,o,i,Math.round(a),Math.round(l),u,c)}function wce(t,n,e,r,s,o,i,a,l,u,c){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*nf(t,n,e,r,s,o,i,d,h,u,c)+(l-h)*nf(t,n,e,r,s,o,i,d,p,u,c))+(a-d)*((p-l)*nf(t,n,e,r,s,o,i,f,h,u,c)+(l-h)*nf(t,n,e,r,s,o,i,f,p,u,c))}function DP(t,n,e,r){const s=mt(n,e)[0],o=[1,e[0],1];for(let p=0;p<s;p++)o[0]*=e[p];o[1]=e[s];for(let p=s+1;p<e.length;p++)o[2]*=e[p];const i={},a=new Int32Array(e[s]),l=new Zn(o,r,t),u=[],c=1===o[0]&&1===o[2];for(let p=0;p<e[s];p++){let m;if(c)m=t[p].toString();else{const g=[];for(let y=0;y<o[0];y++)for(let b=0;b<o[2];b++)g.push(l.get(y,p,b));m=g.join(",")}if(void 0!==i[m])a[p]=i[m];else{const g=Object.keys(i).length;i[m]=g,a[p]=g,u.push(p)}}const d=o.slice();d[1]=Object.keys(i).length;const h=new Zn(d,r);u.forEach((p,m)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)h.set(l.get(g,p,y),g,m,y)});const f=e.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const Nce=[uoe,coe,hoe,poe,ooe,goe,voe,woe,Ioe,_oe,Eoe,Toe,Aoe,Foe,Moe,Boe,Voe,Hoe,joe,aoe,qoe,Yoe,Zoe,roe,eie,nie,toe,rie,oie,lie,cie,iie,pie,gie,hie,bie,xie,Cie,Die,Sie,Nie,Tie,Aie,$ie,Oie,Mie,Lie,Pie,w_,Kse,zie,Uie,Yie,Jie,Zie,eae,cae,dae,fae,mae,bae,xae,Cae,Dae,Sae,Nae,Aae,Xse,$ae,sie,Oae,Pae,Bae,Yse,Vae,Wae,Gae,Kae,Yae,Qae,tle,sle,ile,lle,dle,fle,mle,yle,vle,wle,ule,Dle,Sle,Nle,kle,$le,Ple,nae,Ble,Ule,jle,Kle,Yle,Zle,eue,tue,fP,oue,Zse,aue,uue,noe,due,Qse,eoe,ioe,fue,mue,yue,vue,wue,Cue,Due,Sue,Nue,kue,Fue,Mue,Lue,zue,Uue,Koe,Ole,Wue,Gue,Kue,Yue,Zue,Que,tce,rce,oce,oae,Cle,ace,{kernelName:dh,backendName:"cpu",kernelFunc:lce},{kernelName:hh,backendName:"cpu",kernelFunc:function cce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;Ee(s,"tile");const i=wP(e.bufferSync(s),o);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:sC,backendName:"cpu",kernelFunc:function hce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o}=r;Ee(s,"topk");const a=e.data.get(s.dataId).values,[l,u]=CP(a,s.shape,s.dtype,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},yoe,{kernelName:oC,backendName:"cpu",kernelFunc:function pce(t){const{inputs:n,attrs:e,backend:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,d,h,f]=s.shape,[p,m]=u??[d,h],g=[c,p,m,f],y=Ve(s.shape),b=y[0],v=y[1],x=y[2],w=lr(s.dtype,te(g));w.fill(l);const _=r.data.get(s.dataId).values,D=r.data.get(o.dataId).values;for(let R=0;R<c;++R){const O=1===o.shape[0]?D:D.subarray(8*R,8*R+8);for(let j=0;j<p;++j)for(let K=0;K<m;++K)for(let G=0;G<f;++G){let Z;const q=O[6]*K+O[7]*j+1;if(0===q)continue;const re=(O[3]*K+O[4]*j+O[5])/q,ee=IP((O[0]*K+O[1]*j+O[2])/q,h,a),se=IP(re,d,a);switch(i){case"nearest":Z=xce(_,d,h,b,v,x,R,se,ee,G,l);break;case"bilinear":Z=wce(_,d,h,b,v,x,R,se,ee,G,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}w[R*b+j*v+K*x+G]=Z}return r.makeTensorInfo(g,s.dtype,w)}return{dataId:r.write(w,g,s.dtype),shape:s.shape,dtype:s.dtype}}},{kernelName:iC,backendName:"cpu",kernelFunc:function Cce(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;Ee(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=DP(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:pg,backendName:"cpu",kernelFunc:function Dce(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],l=new Array(i-1);let u=0;for(let f=0;f<i;f++)f!==o&&(l[u++]=s.shape[f]);const c=new Array(i).fill(0),d=s.shape.slice();d[o]=1;const h=new Array(a);for(let f=0;f<h.length;f++){c[o]=f;const p=ll({inputs:{x:s},backend:e,attrs:{begin:c,size:d}});h[f]=an({inputs:{x:p},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(p)}return h}},{kernelName:mg,backendName:"cpu",kernelFunc:function Sce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r;Ee(s,"unsortedSegmentSum");const u=[],c=[],d=s.shape.length-o.shape.length;let h=o;for(let p=0;p<d;++p){const m=Py({inputs:{input:h},backend:e,attrs:{dim:p+1}});h=m,c.push(m)}for(let p=0;p<i;++p){const m=Gi(p,"int32"),g=e.makeTensorInfo([],"int32",m),y=GM({inputs:{a:g,b:h},backend:e}),b=aa({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),v=v_({inputs:{a:b,b:s},backend:e}),x=Ly({inputs:{x:v},backend:e,attrs:{axis:0,keepDims:!1}});u.push(x),c.push(g),c.push(y),c.push(b),c.push(v),c.push(x)}const f=hP({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},Qle];for(const t of Nce)dC(t);const la={},__={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Uo(t){if(!(t in la)){const e=function Ace(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=function kce(t){if(typeof OffscreenCanvas<"u"&&2===t)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return n.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete la[t]},!1),1===t?n.getContext("webgl",__)||n.getContext("experimental-webgl",__):n.getContext("webgl2",__)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;la[t]=e}const n=la[t];return n.isContextLost()?(delete la[t],Uo(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),la[t])}var Wu=(()=>{return(t=Wu||(Wu={}))[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",Wu;var t})(),ts=(()=>{return(t=ts||(ts={}))[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD",ts;var t})(),sr=(()=>{return(t=sr||(sr={}))[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",sr;var t})();function rf(t,n){return[n,t]}function sf(t){const n=te(t);return c0(Math.ceil(n/4))}function ju(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function S_(t,n){const e=t;let r,s,o,i,a,l,u,c,d,h;return 2===ne().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,d=e.HALF_FLOAT,h=e.FLOAT):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=e.RGBA,a=t.RGBA,u=4,c=4,d=null!=n?n.HALF_FLOAT_OES:null,h=t.FLOAT),l=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function Ne(t,n){const e=n();return ne().getBool("DEBUG")&&function Fce(t){const n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+function Lce(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(t,n))}(t),e}function Pce(t){return!!(ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function zy(t,n){return Ei(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}const Vce=/ERROR: [0-9]+:([0-9]+):/g;function E_(t,n){if(Ne(t,()=>t.validateProgram(n)),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function _P(t,n,e,r,s,o,i){const a=t.getAttribLocation(n,e);return-1!==a&&(Ne(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Ne(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),Ne(t,()=>t.enableVertexAttribArray(a)),!0)}function Qce(t,n,e,r){Ne(t,()=>function Yce(t,n,e){(function EP(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(t,e),Ne(t,()=>t.activeTexture(t.TEXTURE0+e)),Ne(t,()=>t.bindTexture(t.TEXTURE_2D,n))}(t,n,r)),Ne(t,()=>t.uniform1i(e,r))}function N_(t,n,e){Ne(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Ne(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function SP(t,n){Ne(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Ne(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Vy(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function ede(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(t,n))}function Ei(t,n,e){const r=Ne(t,()=>n());if(null==r)throw new Error(e);return r}function Gu(t,n=2){return te(t.slice(0,t.length-n))}function qu(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function T_(t){let n=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(n=[Gu(t),...qu(t)]),n}function Uy(t){return t%2==0}function Hy(t,n){if(zt(t=t.slice(-2),n=n.slice(-2))||!t.length||!n.length||0===t[0]||0===t[1]||0===n[0]||0===n[1])return!0;if(t.length!==n.length){const e=t.slice(-1)[0],r=n.slice(-1)[0];if(e===r||Uy(e)&&Uy(r)&&(1===t[0]||1===n[0]))return!0}return t[1]===n[1]&&Uy(t[0])&&Uy(n[0])}let Wy,jy;function Gs(t,n){return null!=t.getExtension(n)}function NP(t){try{if(null!=Uo(t))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function k_(t){const n=S_(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(o),i}function af(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}const je=ne();function Rr(){let t,n,e,r,s,o,i,a,l,u;return 2===ne().getNumber("WEBGL_VERSION")?(t="#version 300 es",n="in",e="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",n="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function ul(t,n,e="index"){const r=Ve(n);return r.map((s,o)=>`int ${t[o]} = ${e} / ${s}; ${o===r.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`};`).join("")}function A_(t){const n=Ve(t).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}je.registerFlag("HAS_WEBGL",()=>je.getNumber("WEBGL_VERSION")>0),je.registerFlag("WEBGL_VERSION",()=>NP(2)?2:NP(1)?1:0),je.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),je.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===je.get("WEBGL_VERSION")),je.registerFlag("WEBGL_CPU_FORWARD",()=>!0),je.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),je.registerFlag("WEBGL_PACK",()=>je.getBool("HAS_WEBGL")),je.registerFlag("WEBGL_PACK_NORMALIZATION",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_PACK_CLIP",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),je.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_PACK_REDUCE",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_LAZILY_UNPACK",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_CONV_IM2COL",()=>je.getBool("WEBGL_PACK")),je.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function nde(t){if(null==Wy){const n=Uo(t);Wy=n.getParameter(n.MAX_TEXTURE_SIZE)}return Wy}(je.getNumber("WEBGL_VERSION"))),je.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function rde(t){if(null==jy){const n=Uo(t);jy=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,jy)}(je.getNumber("WEBGL_VERSION"))),je.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=je.getNumber("WEBGL_VERSION");return 0===t?0:function sde(t){if(0===t)return 0;let n;const e=Uo(t);return n=Gs(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:Gs(e,"EXT_disjoint_timer_query")?1:0,n}(t)}),je.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>je.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!G$()),je.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function ode(t){if(0===t)return!1;const n=Uo(t);if(1===t){if(!Gs(n,"OES_texture_float"))return!1}else if(!Gs(n,"EXT_color_buffer_float"))return!1;return k_(n)}(je.getNumber("WEBGL_VERSION"))),je.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!je.getBool("WEBGL_FORCE_F16_TEXTURES")&&je.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),je.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function ide(t){if(0===t)return!1;const n=Uo(t);if(1!==t){if(Gs(n,"EXT_color_buffer_float"))return k_(n);const r="EXT_color_buffer_half_float";if(Gs(n,r)){const s=n.getExtension(r);return function ade(t,n){const e=S_(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}(n,s)}return!1}return!(!Gs(n,"OES_texture_float")||!Gs(n,"WEBGL_color_buffer_float"))&&k_(n)}(je.getNumber("WEBGL_VERSION"))),je.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function lde(t){return 2===t&&null!=Uo(t).fenceSync}(je.getNumber("WEBGL_VERSION"))),je.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>je.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),je.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),je.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>G$()&&je.getBool("IS_CHROME")?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});const TP="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class ude{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Wu.DENSE;const e=sf(n),r=Rr();this.outputShape=n,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${ul(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${r.output} = result;\n      }\n    `}}class cde{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Wu.DENSE;const e=sf(n),r=Rr();this.outputShape=n,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${ul(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${r.output} = result;\n      }\n    `}}class dde{constructor(n){this.variableNames=["A"],this.outTexUsage=ts.DOWNLOAD;const e=Rr();this.outputShape=n,this.userCode=`\n      ${TP}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class hde{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ts.DOWNLOAD;const e=Rr();this.outputShape=n,this.userCode=`\n      ${TP}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class fde{constructor(n,e,r=!1){this.variableNames=["A"];const s=Rr(),[o,i]=e;this.outputShape=n;let a="result";r&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${A_(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${o}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class pde{constructor(n,e,r=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const s=Rr(),[o,i]=e;this.outputShape=n;let a="",l="result";r&&(l="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let c=0;c<=1;c++){const d=2*u+c;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${c} < ${n[2]}) {\n            localCoords[2] += ${c};\n            if(localCoords[1] + ${u} < ${n[1]}) {\n              localCoords[1] += ${u};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${o}.0);\n              values = ${s.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${d}] = values[0];\n              } else if(offset == 1) {\n                result[${d}] = values[1];\n              } else if(offset == 2) {\n                result[${d}] = values[2];\n              } else {\n                result[${d}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${A_(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${s.output} = ${l};\n      }\n    `}}function lf(t,n,e,r,s,o){!function Kce(t,n){const e=ne().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0)throw new Error(`Requested texture size [${t}x${n}] is invalid.`);if(t>e||n>e)throw new Error(`Requested texture size [${t}x${n}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(n,e);const i=function qce(t){return Ei(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return Ne(t,()=>t.bindTexture(a,i)),Ne(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Ne(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Ne(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Ne(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),Ne(t,()=>t.texImage2D(a,0,r,n,e,0,s,o,null)),Ne(t,()=>t.bindTexture(t.TEXTURE_2D,null)),i}function kP(t){return t.internalFormatFloat}function AP(t){return t.internalFormatHalfFloat}function RP(t){return t.downloadTextureFormat}function $P(t){return t.internalFormatPackedFloat}function FP(t){return t.internalFormatPackedHalfFloat}class Ade{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=ne().getNumber("WEBGL_VERSION");null!=n?(this.gl=n,function Tce(t,n){la[t]=n}(e,n)):this.gl=Uo(e);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(1===ne().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=zy(this.gl,"OES_texture_float"),Gs(this.gl,i))this.textureHalfFloatExtension=zy(this.gl,i);else if(ne().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Gs(this.gl,s))this.colorBufferHalfFloatExtension=zy(this.gl,s);else if(ne().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Gs(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Gs(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function gde(t){return function jce(t,n){const e=Ei(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ne(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),Ne(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function yde(t){return function Gce(t,n){const e=Ei(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ne(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),Ne(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function Xce(t){return Ei(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=S_(this.gl,this.textureHalfFloatExtension)}get debug(){return ne().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;Ne(n,()=>n.finish()),Ne(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Ne(n,()=>n.deleteFramebuffer(this.framebuffer)),Ne(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),Ne(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),Ne(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),function bde(t,n,e,r){const[s,o]=rf(n,e);return lf(t,s,o,kP(r),r.textureFormatFloat,t.FLOAT)}(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),function vde(t,n,e,r){const[s,o]=rf(n,e);return lf(t,s,o,AP(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),function xde(t,n,e,r){const[s,o]=rf(n,e);return lf(t,s,o,RP(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),function _de(t,n,e){Ne(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?Ne(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):Ne(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),Ne(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,s){this.throwIfDisposed(),function Dde(t,n,e,r,s,o){let i,a,l;Ne(t,()=>t.bindTexture(t.TEXTURE_2D,n)),s instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(e*r*4),a=t.FLOAT,l=o.internalFormatPackedFloat),i.set(s),Ne(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,e,r,0,t.RGBA,a,i)),Ne(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),function Cde(t,n,e,r){const[s,o]=ju(n,e);return lf(t,s,o,FP(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),function wde(t,n,e,r){const[s,o]=ju(n,e);return lf(t,s,o,$P(r),t.RGBA,t.FLOAT)}(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(SP(this.gl,this.framebuffer),this.outputTexture=null),Ne(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function Nde(t,n,e,r){const[s,o]=rf(n,e),a=new Uint8Array(function Rce(t,n){return t*n}(n*e,4));return Ne(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,s,o,i){return function Tde(t,n,e,r,s,o,i,a){const l=t,u=new Float32Array(function $ce(t,n){const[e,r]=ju(t,n);return e*r*4}(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,n),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,n,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(n,e){return function Ede(t,n,e){const r=t,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);const s=function Sde(t,n,e,r){const s=t.createBuffer();Ne(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=16*n*e;return Ne(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Ne(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),Ne(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if(ne().getBool("WEBGL_FENCE_API_ENABLED")){const s=n,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function kde(t,n,e){const r=new Float32Array(n*e*4);return Ne(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}(this.gl,e,r))}createProgram(n){this.throwIfDisposed();const e=this.gl,r=function zce(t,n){const e=Ei(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ne(t,()=>t.shaderSource(e,n)),Ne(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw function Uce(t,n){const e=Vce.exec(n);if(null==e)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(t);const r=+e[1],s=t.split("\n"),o=s.length.toString().length+2,i=s.map((d,h)=>du((h+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${du(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(e,n),s=function mde(t){const n=Rr();return function Bce(t,n){const e=Ei(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ne(t,()=>t.shaderSource(e,n)),Ne(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(t,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e),o=function Hce(t){return Ei(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return Ne(e,()=>e.attachShader(o,s)),Ne(e,()=>e.attachShader(o,r)),function Wce(t,n){if(Ne(t,()=>t.linkProgram(n)),!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(e,o),this.debug&&E_(e,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=function Ide(t,n,e){return Ne(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),_P(t,n,"clipSpacePos",e,3,20,0)&&_P(t,n,"uv",e,2,20,12)}(e,this.program,this.vertexBuffer)),o}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&Ne(this.gl,()=>this.gl.deleteProgram(n))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&this.debug&&E_(this.gl,this.program),Ne(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?function Jce(t,n,e){return Ei(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}(this.gl,n,e):function Zce(t,n,e){return t.getUniformLocation(n,e)}(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),Ne(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Qce(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();const[s,o]=ju(e,r);this.setOutputMatrixTextureDriver(n,s,o)}setOutputMatrixWriteRegion(n,e,r,s){this.setOutputMatrixWriteRegionDriver(r,n,s,e)}setOutputPackedMatrixWriteRegion(n,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&E_(this.gl,this.program),Vy(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;this.debug&&this.debugValidate(),Ne(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ne(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=zy(this.gl,2===ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var e=this;return Q(function*(){return yield E$(()=>e.disposed||e.isQueryAvailable(n,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(n,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){const n=function Rde(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),!(this.itemsToPoll.length>1)&&E$(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(n){this.throwIfDisposed(),N_(this.gl,n,this.framebuffer),this.debug&&Vy(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(N_(this.gl,this.outputTexture,this.framebuffer),this.debug&&Vy(this.gl)):SP(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();const s=this.gl;N_(s,n,this.framebuffer),this.debug&&Vy(s),this.outputTexture=n,Ne(s,()=>s.viewport(0,0,e,r)),Ne(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,s){this.throwIfDisposed(),Ne(this.gl,()=>this.gl.scissor(n,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:OP}=X;function $de(t,n,e,r){const s=[];t.forEach(p=>{const m=te(p.shapeInfo.logicalShape);p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${m>1?`[${m}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`))});const o=s.join("\n"),i=t.map(p=>function Fde(t,n,e=!1){let r="";return r+=e?MP(t):Ku(t),t.shapeInfo.logicalShape.length<=n.logicalShape.length&&(r+=e?function fhe(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=OP(t.shapeInfo.logicalShape,n.logicalShape),l=qt(i),u=i-o;let c;const d=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${d[b+u]} = 0;`).join("\n");let h="";h=i<2&&o>0?"coords":t.shapeInfo.logicalShape.map((b,v)=>`coords.${d[v+u]}`).join(", ");let f="return outputValue;";const m=1===te(t.shapeInfo.logicalShape),y=1===te(n.logicalShape);if(1!==o||m||y){if(m&&!y)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=o-2,v=o-1;a.indexOf(b)>-1&&a.indexOf(v)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(t,n):function phe(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&null==t.shapeInfo.flatOffset&&zt(t.shapeInfo.texShape,n.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=qt(l),c=OP(t.shapeInfo.logicalShape,n.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&c.length>=1?"coords = 0;":c.map(m=>`coords.${f[m+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":t.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+d]}`).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(t,n)),r}(p,n,r)).join("\n"),a=n.texShape,l=Rr(),u=function Pde(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let c,d,h=function zde(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Vde}\n    ${Ude}\n    ${Hde}\n  `}(l);return n.isPacked?(c=function Ode(t,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function jde(t,n){const e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===e[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${e[1]}.0);\n      }\n    `:1===e[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${e[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return 2 * (resTexRC.x * ${e[1]} + resTexRC.y);\n    }\n  `}(0,n);case 2:return function Qde(t,n){const e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(zt(t,n))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `;const r=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,n);case 3:return function qde(t,n){const e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(t[2]/2),s=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,n);default:return function Xde(t,n){const e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(t[t.length-1]/2),s=r*Math.ceil(t[t.length-2]/2);let o=s,i="",a="b, r, c";for(let l=2;l<t.length-1;l++)o*=t[t.length-l-1],i=`\n      int b${l} = index / ${o};\n      index -= b${l} * ${o};\n    `+i,a=`b${l}, `+a;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${a});\n    }\n  `}(t,n)}}(n.logicalShape,a),d=function Bde(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(l)):(c=function Mde(t,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Gde(t,n){return 1===n[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n);case 2:return function ehe(t,n){return zt(t,n)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,n);case 3:return function Kde(t,n){const e=ul(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${e}\n      return ivec3(r, c, d);\n    }\n  `}(t,n);case 4:return function Yde(t,n){const e=ul(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${e}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,n);case 5:return function Jde(t,n){const e=ul(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,n);case 6:return function Zde(t,n){const e=ul(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(n.logicalShape,a),d=function Lde(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),r&&(h+=Wde),[h,u,d,o,c,i,e].join("\n")}function Ku(t){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function nhe(t){const n=t.name,e="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${e}() {return ${n};}`;const[r,s]=t.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${e}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const[o,i]=t.shapeInfo.texShape;return`\n    float ${e}() {\n      vec2 uv = uvFromFlat(${o}, ${i}, ${cl(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 1:return function she(t){const n=t.name,e="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${e}(int index) {\n        ${Xu(t)}\n      }\n    `;const r=t.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${e}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=cl(n);return 1===o?`\n      float ${e}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?`\n      float ${e}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${e}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 2:return function ihe(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape;if(null!=s&&zt(n,s))return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `;const{newShape:o,keptDims:i}=za(n);if(o.length<n.length){const h=["row","col"];return`\n      ${Ku(Yu(t,o))}\n      float ${r}(int row, int col) {\n        return ${r}(${Ju(h,i)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${Xu(t)}\n      }\n    `;const l=s[0],u=s[1],c=cl(e);return 1===u?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `:1===l?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${l}, ${u}, index);\n    return sampleTexture(${e}, uv);\n  }\n`}(t);case 3:return function lhe(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:a}=za(n);if(i.length<n.length){const m=["row","col","depth"];return`\n        ${Ku(Yu(t,i))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${Ju(m,a)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${Xu(t)}\n      }\n    `;const u=t.shapeInfo.texShape,c=u[0],d=u[1],h=t.shapeInfo.flatOffset;if(d===s&&null==h)return`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${c}.0);\n          return sampleTexture(${e}, uv);\n        }\n      `;if(d===o&&null==h)return`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${c}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `;return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${cl(e)};\n        vec2 uv = uvFromFlat(${c}, ${d}, index);\n        return sampleTexture(${e}, uv);\n      }\n  `}(t);case 4:return function che(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:a,keptDims:l}=za(n);if(a.length<n.length){const m=["row","col","depth","depth2"];return`\n      ${Ku(Yu(t,a))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${Ju(m,l)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${s}, 1)));\n        ${Xu(t)}\n      }\n    `;const u=t.shapeInfo.flatOffset,c=t.shapeInfo.texShape,d=c[0],h=c[1];if(h===i&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(h===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${cl(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 5:return function dhe(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[4],o=n[3]*s,i=n[2]*o,a=n[1]*i,{newShape:l,keptDims:u}=za(n);if(l.length<n.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${Ku(Yu(t,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Ju(g,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${Xu(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${cl(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 6:return function hhe(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=za(n);if(s.length<n.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ku(Yu(t,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Ju(y,o)});\n      }\n    `}const i=n[5],a=n[4]*i,l=n[3]*a,u=n[2]*l,c=n[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Xu(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,f=h[0],p=h[1];if(p===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${cl(e)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function MP(t){switch(t.shapeInfo.logicalShape.length){case 0:return function the(t){const n=t.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${Rr().texture2D}(${n}, halfCR);\n    }\n  `}(t);case 1:return function rhe(t){const n=t.name,e="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],o=Rr();return`\n    vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(t);case 2:return function ohe(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,o=s[0],i=s[1],a=Rr();if(null!=s&&zt(n,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${a.texture2D}(${e}, uv);\n      }\n    `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${l[0]}, ${l[1]}, row, col);\n      return ${a.texture2D}(${e}, uv);\n    }\n  `}(t);case 3:return function ahe(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const h=[1,2],p=["b","row","col"];return`\n        ${MP(Yu(t,n.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Ju(p,h)});\n        }\n      `}const i=o[0],a=o[1],l=Math.ceil(n[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${i}, ${a}, ${l*Math.ceil(n[1]/2)}, ${l}, b, row, col);\n      return ${Rr().texture2D}(${e}, uv);\n    }\n  `}(t);default:return function uhe(t){const n=t.shapeInfo.logicalShape,e=n.length,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],a=i[0],l=i[1],u=Math.ceil(n[e-1]/2);let c=u*Math.ceil(n[e-2]/2),d="int b, int row, int col",h=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<e-1;p++)d=`int b${p}, `+d,c*=n[e-p-1],h=`b${p} * ${c} + `+h;return`\n    vec4 ${s}(${d}) {\n      int index = ${h};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${a});\n      return ${Rr().texture2D}(${r}, uv);\n    }\n  `}(t)}}const Vde="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ude="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Hde="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Wde="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function cl(t){return`offset${t}`}function Xu(t){const n=t.name,e=te(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function qt(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function Yu(t,n){const e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function Ju(t,n){return n.map(e=>t[e]).join(", ")}function LP(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{const s=e.logicalShape,o=n[r],i=o.shape;if(!zt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!zt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}const{addImpl:bhe,bincountImpl:BP,bincountReduceImpl:vhe,ceilImpl:xhe,concatImpl:whe,expImpl:Che,expm1Impl:Ihe,floorImpl:Dhe,gatherV2Impl:_he,greaterImpl:She,lessImpl:Ehe,linSpaceImpl:Nhe,logImpl:The,maxImpl:khe,maximumImpl:Ahe,minimumImpl:Rhe,multiplyImpl:$he,negImpl:Fhe,prodImpl:Ohe,rangeImpl:Mhe,rsqrtImpl:Phe,simpleAbsImpl:zP,sliceImpl:Lhe,stridedSliceImpl:Bhe,subImpl:zhe,tileImpl:Vhe,topKImpl:Uhe,transposeImpl:R_,uniqueImpl:Hhe}=fe;function VP(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function $r(t,n){return 1===n?[t]:VP(t,n)}class jhe{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n;const e=n.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const r=$r("rc",e),s=qt(e),o=function qhe(t,n,e){if(1===t)return`rc > ${n[0]}`;let r="";for(let s=t-2;s<t;s++)r+=`${e[s]} >= ${n[s]}`,s<t-1&&(r+="||");return r}(e,n,r),i=function Khe(t,n,e,r){if(1===t)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${n};\n    bool rEdge = rp1 >= ${e};\n  `}(e,n[n.length-1],n[n.length-2],r),a=function Xhe(t,n){const e=t.length,r=function Ghe(t,n){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<t;i++)o=`${n[n.length-1-i]},`+o;e.push(o)}return e}(e,n);return 1===e?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(n,r);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${o}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class UP{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function Yhe(t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${ul(["r","c","d"],t)}\n      return ivec3(r, c, d);\n    }\n  `}(e)}\n      ${A_(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${n[1]};\n        int cols = ${n[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Jhe{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(n,e,r){const s=WP(e,r),o=jP(n,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=HP(n,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].shift();return this.usedTextures[o].push(l),l}let a;return s===sr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):s===sr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):s===sr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):s===sr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):s===sr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,e,r,s){if(null==this.freeTextures)return;const o=WP(r,s),i=jP(e,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=HP(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=ne().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(n),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u.indexOf(n);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function HP(t,n,e,r,s){const o=function Qhe(t,n){switch(t){case sr.PACKED_2X2_FLOAT32:return $P(n);case sr.PACKED_2X2_FLOAT16:return FP(n);case sr.UNPACKED_FLOAT32:return kP(n);case sr.UNPACKED_FLOAT16:return AP(n);case sr.PACKED_4X1_UNSIGNED_BYTE:return RP(n);default:throw new Error(`Unknown physical texture type ${t}`)}}(n,r);let i;if(s){const[l,u]=ju(t[0],t[1]);i=l*u}else{const[l,u]=rf(t[0],t[1]);i=l*u}const a=function Zhe(t,n){if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${n}`)}(e,o);return i*a}function WP(t,n){if(t===ts.UPLOAD)return sr.PACKED_2X2_FLOAT32;if(t===ts.RENDER||null==t)return function efe(t){return ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?sr.PACKED_2X2_FLOAT32:sr.UNPACKED_FLOAT32:t?sr.PACKED_2X2_FLOAT16:sr.UNPACKED_FLOAT16}(n);if(t===ts.DOWNLOAD||t===ts.PIXELS)return sr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function jP(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}class ua{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const GP="return abs(x);",qy="return x;";class Zu{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class ufe{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n;const e=n.length,r=$r("rc",e),s=qt(e),o=function Whe(t,n){if(1===t)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const cfe=HI,Ky={};let yfe=(()=>{class t extends l0{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!ne().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const r=Uo(ne().getNumber("WEBGL_VERSION"));this.binaryCache=function ffe(t){return t in Ky||(Ky[t]={}),Ky[t]}(ne().getNumber("WEBGL_VERSION")),this.gpgpu=new Ade(r),this.canvas=r.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new Jhe(this.gpgpu),this.numMBBeforeWarning=function gfe(){return null==ne().global.screen?1024:ne().global.screen.height*ne().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new D$(this,Ki())}nextDataId(){return t.nextDataId++}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,r,s){if((ne().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ne().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:ts.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,i){if(ne().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:ts.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(null!=a){let f;f=u?new Zu(l,qy):new ua(l,qy);const p=this.runWebGLProgram(f,[{dataId:e,shape:l,dtype:o}],o),m=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),m}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const c=null!=this.activeTimers;let d,h;return c&&(d=Ur()),h="complex64"===o?Ci(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.getValuesFromTexture(e),c&&(this.downloadWaitMs+=Ur()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return Q(function*(){if(r.pendingRead.has(e)){const g=r.pendingRead.get(e);return new Promise(y=>g.push(y))}const s=r.texData.get(e),{values:o,shape:i,slice:a,dtype:l,complexTensorInfos:u,isPacked:c}=s;if(null!=a){let g;g=c?new Zu(i,qy):new ua(i,qy);const y=r.runWebGLProgram(g,[{dataId:e,shape:i,dtype:l}],l),b=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),b}if(null!=o)return r.convertAndCacheOnCPU(e);if(!ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ne().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&ne().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const g=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(g.texture,...sf(i))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);f=Ci(g[0],g[1])}else if(null==d)f=r.getValuesFromTexture(e);else{const g=te(i);f=r.gpgpu.downloadFloat32MatrixFromBuffer(d,g)}null!=h&&r.disposeIntermediateTensorInfo(h);const p=r.convertAndCacheOnCPU(e,f),m=r.pendingRead.get(e);return r.pendingRead.delete(e),m.forEach(g=>g(p)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Ki().removeDataId(e,r),r.pendingDeletes--),p})()}bufferSync(e){const r=this.readSync(e.dataId);let s=r;if("string"===e.dtype)try{s=r.map(o=>mu(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xt(e.shape,e.dtype,s)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!Pce(s))throw ne().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),i=te(r);if(ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(p.texture,...sf(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),m}const a=ne().getBool("WEBGL_PACK")&&!0===o,l=a?T_(r):r,u=a?new hde(l):new dde(l),c=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;return Q(function*(){const s=r.activeTimers,o=[];let i=!1;null==r.programTimersStack?(r.programTimersStack=o,i=!0):r.activeTimers.push(o),r.activeTimers=o,e();const a=cu(r.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=cu(r.activeTimers.map(c=>c.name)).filter(c=>null!=c);r.activeTimers=s,i&&(r.programTimersStack=null);const u={uploadWaitMs:r.uploadWaitMs,downloadWaitMs:r.downloadWaitMs,kernelMs:null,wallMs:null};if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(a);u.kernelMs=function iX(t){let n=0;for(let e=0;e<t.length;e++)n+=t[e];return n}(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ur(),endMs:null}}endTimer(e){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ur(),e)}getQueryTime(e){var r=this;return Q(function*(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return ne().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Ki().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,r=128){const s=this.getCPUBackend();return!ne().getBool("IS_TEST")&&!this.warnedAboutCPUBackend&&null==s&&(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=s&&e.every(o=>null==this.texData.get(o.dataId).texture&&te(o.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){Ru("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return cfe(e.shape,r)}packedUnaryOp(e,r,s){const o=new Zu(e.shape,r),i=this.compileAndRun(o,[e],s);return Ki().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=zP(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(ne().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,GP,e.dtype);const r=new ua(e.shape,GP),s=this.compileAndRun(r,[e]);return Ki().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&md(s[0])){const i=s.map(a=>mh(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){const{dataId:o}=this.makeTensorInfo(e,r,s);return Ki().makeTensorFromDataId(o,e,r,this)}unpackTensor(e){const r=new ufe(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new jhe(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Gu(e.shape),...qu(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Gu(r),...qu(r)],a=new UP(i,s),u=this.runWebGLProgram(a,[o],e.dtype,null,!0);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(e){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:i}=r,a=T_(o);let l;return l=s?new cde(a):new ude(a),{dtype:i,shape:o,dataId:this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],i,null,!0).dataId}}runWebGLProgram(e,r,s,o,i=!1){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Wu.DENSE){const y=sf(e.outputShape);l.texShape=y.map(b=>2*b)}if(null!=e.outTexUsage&&(l.usage=e.outTexUsage),0===te(a.shape))return l.values=lr(a.dtype,0),a;const u=[],c=r.map(y=>{if("complex64"===y.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(null==b.texture){if(!e.packedInputs&&te(y.shape)<=ne().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}else if(!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!Hy(b.shape,y.shape)){const v=y,x=y.shape;y.shape=b.shape,y=this.packedReshape(y,x),u.push(y),b=this.texData.get(y.dataId),v.shape=x}return this.uploadToGPU(y.dataId),{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:l,isUniform:!1},h=function yhe(t,n,e){let r="";n.concat(e).forEach(i=>{r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0}`});let o=t.constructor.name;return o+="_"+r+"_"+t.userCode,o}(e,c,d),f=this.getAndSaveBinary(h,()=>function mhe(t,n,e,r){const s=n.userCode,o=e.map((f,p)=>{const m={logicalShape:f.shape,texShape:f.isUniform?null:f.texData.texShape,isUniform:f.isUniform,isPacked:!f.isUniform&&f.texData.isPacked,flatOffset:null};return null!=f.texData&&null!=f.texData.slice&&f.texData.slice.flatOffset>0&&(m.flatOffset=f.texData.slice.flatOffset),{name:n.variableNames[p],shapeInfo:m}}),i=o.map(f=>f.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=$de(o,a,s,n.packedInputs),u=t.createProgram(l);let c=null;const d=t.getUniformLocation(u,"NAN",!1);1===ne().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(u,"INFINITY",!1));const h={};for(let f=0;f<n.variableNames.length;f++){const p=n.variableNames[f],m=!1;h[p]=t.getUniformLocation(u,p,m),h[`offset${p}`]=t.getUniformLocation(u,`offset${p}`,m)}return{program:n,source:l,webGLProgram:u,uniformLocations:h,inShapeInfos:i,outShapeInfo:a,infLoc:c,nanLoc:d}}(this.gpgpu,e,c,d)),p=null!=this.activeTimers;let m;p&&(m=this.startTimer()),function ghe(t,n,e,r,s){LP(n.inShapeInfos,e),LP([n.outShapeInfo],[r]);const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o,i[0],i[1]):t.setOutputMatrixTexture(o,i[0],i[1]),t.setProgram(n.webGLProgram),1===ne().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&t.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&t.gl.uniform1f(n.nanLoc,NaN),e.forEach((a,l)=>{const u=n.program.variableNames[l],c=n.uniformLocations[u],d=n.uniformLocations[`offset${u}`];if(null!=c){if(a.isUniform){if(te(a.shape)<2)t.gl.uniform1f(c,a.uniformValues[0]);else{let h=a.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),t.gl.uniform1fv(c,h)}return}null!=a.texData.slice&&null!=d&&t.gl.uniform1i(d,a.texData.slice.flatOffset),t.setInputMatrixTexture(a.texData.texture,c,l)}}),s?.(t,n.webGLProgram),t.executeProgram()}(this.gpgpu,f,c,d,o),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=ne().get("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=Ur();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!ne().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&!1===i){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,r,s,o,i=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ne().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=U(()=>{if(!ne().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ne().getBool("DEBUG");ne().set("DEBUG",!1);const r=this.abs(Oe(1e-8)).dataSync()[0];if(ne().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:i,texture:a,usage:l,isPacked:u}=r;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=Ur());let h=r.texShape;if(null==h&&(h=function tde(t,n=!1){let e=ne().getNumber("WEBGL_MAX_TEXTURE_SIZE");n&&(e*=2,1===(t=t.map((s,o)=>o>=t.length-2?S$(t[o]):t[o])).length&&(t=[2,t[0]])),2!==t.length&&(t=za(t).newShape);let r=te(t);if(t.length<=1&&r<=e)return[1,r];if(2===t.length&&t[0]<=e&&t[1]<=e)return t;if(3===t.length&&t[0]*t[1]<=e&&t[2]<=e)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=e&&t[1]*t[2]<=e)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=e&&t[3]<=e)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=e&&t[1]*t[2]*t[3]<=e)return[t[0],t[1]*t[2]*t[3]];if(n){const s=Gu(t);let o=2,i=2;return t.length&&([o,i]=qu(t)),r=s*(o/2)*(i/2),c0(r).map(a=>2*a)}return c0(r)}(s,u),r.texShape=h),null!=i){const f=T_(s);let p,m=h[1],g=h[0];const y=i instanceof Uint8Array;u?([m,g]=ju(h[0],h[1]),p=new pde(f,[g,m],y)):p=new fde(f,[g,m],y);const b=this.makeTensorInfo([g,m],o);this.texData.get(b.dataId).usage=y?ts.PIXELS:ts.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),m,g,i);const x=this.runWebGLProgram(p,[b],o,null,!0),w=this.texData.get(x.dataId);r.texture=w.texture,r.texShape=w.texShape,r.isPacked=w.isPacked,r.usage=w.usage,this.disposeIntermediateTensorInfo(b),this.texData.delete(x.dataId),r.values=null,c&&(this.uploadWaitMs+=Ur()-d)}else{const f=this.acquireTexture(h,l,o,u);r.texture=f}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return this.releaseGPUData(e),null!=r&&(s.values=function bfe(t,n){if("float32"===n||"complex64"===n)return t;if("int32"===n||"bool"===n){const e="int32"===n?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}throw new Error(`Unknown dtype ${n}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*d0(r)}}return t.nextDataId=0,t})();q$()&&N2("webgl",()=>new yfe,2);class Qu{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=wt(e,r),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class uf{constructor(n,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=wt(e,r);const o=this.outputShape.length;let i="";if(s)if(0===o||1===te(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${qt(o)} coords = getOutputCoords();\n        `,1===o)i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=$r("coords",o);i+=`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${n}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function ns(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const wfe={kernelName:Bd,backendName:"webgl",kernelFunc:ns};function ca(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(o.dataId),a=ns({inputs:{x:r},backend:e}),l=ns({inputs:{x:s},backend:e});return i.complexTensorInfos={real:a,imag:l},o}const Cfe={kernelName:C0,backendName:"webgl",kernelFunc:ca},KP="return (a < 0.) ? b * a : a;",XP="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Dfe={kernelName:Pm,backendName:"webgl",kernelFunc:function Ife(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r,i=e.makeTensorInfo([],"float32",Gi(o,"float32")),a=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new uf(XP,s.shape,i.shape):new Qu(KP,s.shape,i.shape),l=e.runWebGLProgram(a,[s,i],s.dtype);return e.disposeIntermediateTensorInfo(i),l}},YP="return (a < 0.) ? b * a : a;",JP="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Sfe={kernelName:ng,backendName:"webgl",kernelFunc:function _fe(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n,o=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new uf(JP,r.shape,s.shape):new Qu(YP,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}};function Nt({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const d=a.texData.get(i.dataId),h=e(d.values,l);return a.makeTensorInfo(i.shape,l,h)}let c;return c=ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Zu(i.shape,n):new ua(i.shape,t),a.runWebGLProgram(c,[i],l)}}function fr({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(r&&"complex64"===l.dtype){const p=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(v=>{const[x,w]=v,_={dataId:x.dataId,dtype:x.dtype,shape:l.shape},D={dataId:w.dataId,dtype:w.dtype,shape:u.shape},A=new Qu(t,l.shape,u.shape);return c.runWebGLProgram(A,[_,D],ps(x.dtype,w.dtype))}),b=ca({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}const d=o||ps(l.dtype,u.dtype);if(c.shouldExecuteOnCPU([l,u])&&null!=s){const p=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=s(l.shape,u.shape,p.values,m.values,d),b=c.makeTensorInfo(y,d);return c.texData.get(b.dataId).values=g,b}let f;return f=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new uf(n,l.shape,u.shape,e):new Qu(t,l.shape,u.shape),c.runWebGLProgram(f,[l,u],d)}}function Yy(t,n=!1){if("linear"===t)return"return x;";if("relu"===t)return n?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===t)return n?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return n?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===t)return n?JP:YP;if("leakyrelu"===t)return n?XP:KP;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class QP{constructor(n,e,r,s=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r;const d=Math.ceil((s?n[1]:n[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",f=o?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",x="rc.x";n[0]<e[0]?v=`int(min(float(rc.x), ${n[0]-1}.))`:e[0]<n[0]&&(x=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${g}\n\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${d}; i++) {\n          int batchA = ${v};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${m[0]});\n          result += (${p[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class tL{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=wt(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${n}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const nL="return a * b;";function rL(t){const{inputs:n,backend:e}=t,{a:r,b:s}=n,o=ps(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),u=new tL("return areal * breal - aimag * bimag;",r.shape,s.shape),c=new tL("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(u,d,"float32"),f=e.runWebGLProgram(c,d,"float32"),p=ca({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[u,c]=$he(r.shape,s.shape,a.values,l.values,o),d=e.makeTensorInfo(c,o);return e.texData.get(d.dataId).values=u,d}let i;return i=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new uf(nL,r.shape,s.shape):new Qu(nL,r.shape,s.shape),e.runWebGLProgram(i,[r,s],o)}const Tfe={kernelName:Kd,backendName:"webgl",kernelFunc:rL};function Se(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=e,a=te(s.shape),l=N$(o,a),u=te(l);S(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||Hy(s.shape,l)||null!==c.texture&&Hy(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function kfe(t,n,e){const r=[Gu(t.shape),...qu(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[Gu(n),...qu(n)],i=new UP(o,r),l=e.runWebGLProgram(i,[s],t.dtype,null,!0);return{dataId:l.dataId,shape:n,dtype:l.dtype}}(s,l,i)}const Afe={kernelName:rg,backendName:"webgl",kernelFunc:Se};class sL{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];const a=4*Math.floor(r/4),l=r%4;let u="sumValue += dot(values, ones);";if(null!=e){const d=1/e;u=`sumValue += dot(values * ${Jn(d)?d.toPrecision(2):d}, ones);`}let c="";o%r>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Rfe{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n      }\n    `,f="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function dl(t,n,e,r){const s=function $fe(t){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const e=n.length?n[n.length-1].outSize:t[1],r=Qg(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===e?0===i?new sL({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},a):new sL({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u}):new Rfe({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},e),d=o,o=r.runWebGLProgram(c,[o],n),d.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class Ffe{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[e[i]];this.outputShape=r,this.rank=r.length;const s=qt(this.rank),o=function Ofe(t){const n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let s=0;s<t.length;s++)r[t[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class Mfe{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(n.length);for(let c=0;c<r.length;c++)r[c]=n[e[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=qt(this.rank),o=VP("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Jy(t,n,e){const r=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mfe(t.shape,n):new Ffe(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function $_(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;return function Pfe(t,n,e,r){const o=t.shape.length,i=mt(n,t.shape);let a=i;const l=wn(a,o),u=null!=l;let c=t;u&&(c=Jy(t,l,r),a=kn(a.length,o)),dr("sum",a,o);const[d,h]=tr(c.shape,a);let f=d;e&&(f=xn(d,i));const p=te(h),y=Se({inputs:{x:c},attrs:{shape:[te(t.shape)/p,p]},backend:r}),v=dl(y,pC(t.dtype),"sum",r),x=Se({inputs:{x:v},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),u&&r.disposeIntermediateTensorInfo(c),x}(s,o,i,e)}const Lfe={kernelName:ug,backendName:"webgl",kernelFunc:$_};function jr(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{perm:o}=r,i=e,l=new Array(s.shape.length);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=R_(d,s.shape,s.dtype,o,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=h}else u=Jy(s,o,i);return u}const Bfe={kernelName:fg,backendName:"webgl",kernelFunc:jr};function Zy({a:t,b:n,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,c=n.shape.length,d=e?t.shape[u-2]:t.shape[u-1],h=r?n.shape[c-1]:n.shape[c-2],f=e?t.shape[u-1]:t.shape[u-2],p=r?n.shape[c-2]:n.shape[c-1],m=t.shape.slice(0,-2),g=n.shape.slice(0,-2),y=te(m),b=te(g);S(u>=2&&c>=2&&(y===b||1===y||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const w=(y>b?t.shape.slice(0,-2):n.shape.slice(0,-2)).concat([f,p]);S(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);const _=e?[y,d,f]:[y,f,d],D=r?[b,p,h]:[b,h,p],A=Se({inputs:{x:t},backend:s,attrs:{shape:_}}),R=Se({inputs:{x:n},backend:s,attrs:{shape:D}}),O=[A,R],j=Math.max(y,b),K=e?A.shape[1]:A.shape[2],G=null!=o,Z=null!=i,q="leakyrelu"===l,Y=null!=l?Yy(l,!0):null;let ee;if((1===f||1===p)&&K>1e3&&!1===(G||Z||q||null!=Y)){let ue=A,de=R;e&&(ue=jr({inputs:{x:A},backend:s,attrs:{perm:[0,2,1]}}),O.push(ue)),r&&(de=jr({inputs:{x:R},backend:s,attrs:{perm:[0,2,1]}}),O.push(de));const pe=1===p;let ye=ue;1!==p&&(ye=Se({inputs:{x:ue},backend:s,attrs:{shape:[j,K,1]}}),O.push(ye));const ve=1===p?2:1;let De=de;pe&&(De=Se({inputs:{x:de},backend:s,attrs:{shape:[j,1,K]}}),O.push(De));const Te=rL({inputs:{a:ye,b:De},backend:s});ee=$_({inputs:{x:Te},backend:s,attrs:{axis:ve,keepDims:!0}}),O.push(Te)}else{const ue=ps(t.dtype,n.dtype),de=new QP(_,D,[j,f,p],e,r,G,Y,Z,q),ge=[A,R];if(null!=o&&ge.push(o),Z&&ge.push(i),q){const pe=s.makeTensorInfo([],"float32",Gi(a,"float32"));ge.push(pe),O.push(pe)}ee=s.runWebGLProgram(de,ge,ue)}const se=Se({inputs:{x:ee},backend:s,attrs:{shape:w}});O.push(ee);for(const ue of O)s.disposeIntermediateTensorInfo(ue);return se}const Vfe={kernelName:yg,backendName:"webgl",kernelFunc:function zfe(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return Zy({a:s,b:o,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}},iL="return abs(x);",Hfe={kernelName:gm,backendName:"webgl",kernelFunc:function Ufe(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),i=zP(o.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Zu(r.shape,iL):new ua(r.shape,iL),e.runWebGLProgram(s,[r],r.dtype)}},jfe=Nt({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Gfe={kernelName:vd,backendName:"webgl",kernelFunc:jfe},Kfe=Nt({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Xfe={kernelName:xd,backendName:"webgl",kernelFunc:Kfe},aL="return a + b;",Yfe=fr({opSnippet:aL,packedOpSnippet:aL,supportsComplex:!0,cpuKernelImpl:bhe}),Jfe={kernelName:fu,backendName:"webgl",kernelFunc:Yfe};class Zfe{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class Qfe{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const epe={kernelName:ym,backendName:"webgl",kernelFunc:function Qy(t){const{inputs:n,backend:e}=t,r=n;if(1===r.length)return ns({inputs:{x:r[0]},backend:e});if(r.length>ne().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=Qy({inputs:r.slice(0,l),backend:e}),c=Qy({inputs:r.slice(l),backend:e});return Qy({inputs:[u,c],backend:e})}const s=r.map(l=>l.dtype).reduce((l,u)=>ps(l,u)),o=r.map(l=>l.shape),a=ne().getBool("WEBGL_PACK")?new Qfe(r[0].shape,o):new Zfe(r[0].shape,o);return e.runWebGLProgram(a,r,s)}},npe={kernelName:"All",backendName:"webgl",kernelFunc:function tpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=mt(o,s.shape);let u=l;const c=wn(u,a);let d=s;null!=c&&(d=jr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=kn(u.length,a)),dr("all",u,a);const[h,f]=tr(d.shape,u),m=Se({inputs:{x:d},backend:e,attrs:{shape:[-1,te(f)]}}),g=dl(m,m.dtype,"all",e);let y;return y=Se(i?{inputs:{x:g},backend:e,attrs:{shape:xn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}},spe={kernelName:"Any",backendName:"webgl",kernelFunc:function rpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=mt(o,s.shape);let u=l;const c=wn(u,a);let d=s;null!=c&&(d=jr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=kn(u.length,a)),dr("any",u,a);const[h,f]=tr(d.shape,u),m=Se({inputs:{x:d},backend:e,attrs:{shape:[-1,te(f)]}}),g=dl(m,m.dtype,"any",e);let y;return y=Se(i?{inputs:{x:g},backend:e,attrs:{shape:xn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}};class ope{constructor(n,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class ipe{constructor(n,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(n[n.length-1]/e);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=qt(l),c=$r("coords",l);let d,h;if(1===i){h=l+1;const A=qt(h);d=`\n        ${A} sourceLocR = ${A}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${A} sourceLocG = ${A}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${A} sourceLocA = ${A}(${c.join()}, 0);\n        --${c[l-1]};\n        ${A} sourceLocB = ${A}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],m=f.map(A=>"int "+A),g=$r("sourceLocR",h-1).concat("inIdx.r"),y=$r("sourceLocG",h-1).concat("inIdx.g"),b=$r("sourceLocB",h-1).concat("inIdx.b"),v=$r("sourceLocA",h-1).concat("inIdx.a"),x="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,_=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,D=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${D}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${_};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${_};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function lL(t,n,e,r=null){let s=n.shape[0],o=n.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=Qg(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new ope(a,e,null==r),u=[n];null!=r&&u.push(r);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=lL(t,n,e,c);return t.disposeIntermediateTensorInfo(c),d}function uL(t,n,e,r=null){const s=null!=r?r.shape:n.shape,i=Qg(s[s.length-1]),a=new ipe(s,i,e,null==r),u=t.runWebGLProgram(a,null==r?[n]:[n,r],"int32");if(u.shape.length===n.shape.length){const c=uL(t,n,e,u);return t.disposeIntermediateTensorInfo(u),c}return u}function cL(t,n,e,r){const s=[e];if(dr("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,n.shape.length),!ne().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const o=[],[i,a]=tr(n.shape,s),l=te(a),u=Se({inputs:{x:n},backend:t,attrs:{shape:[-1,l]}});o.push(u);const c=lL(t,u,r);o.push(c);const d=Se({inputs:{x:c},backend:t,attrs:{shape:i}});return o.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}return uL(t,n,r)}const lpe={kernelName:bm,backendName:"webgl",kernelFunc:function ape(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=mt(o,s.shape);const a=wn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=jr({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=kn(i.length,l.shape.length)),dr("argMax",[i[0]],l.shape.length);const c=cL(e,l,i[0],"max");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},cpe={kernelName:vm,backendName:"webgl",kernelFunc:function upe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=mt(o,s.shape);const a=wn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=jr({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=kn(i.length,l.shape.length)),dr("argMin",[i[0]],l.shape.length);const c=cL(e,l,i[0],"min");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},hpe=Nt({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),fpe={kernelName:wd,backendName:"webgl",kernelFunc:hpe},mpe=Nt({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),gpe={kernelName:Cd,backendName:"webgl",kernelFunc:mpe},bpe=Nt({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),vpe={kernelName:Id,backendName:"webgl",kernelFunc:bpe},Cpe=fr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Ipe={kernelName:_d,backendName:"webgl",kernelFunc:Cpe},_pe=Nt({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Spe={kernelName:Dd,backendName:"webgl",kernelFunc:_pe};class cf{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,d=n.effectiveFilterHeight,h=n.effectiveFilterWidth,f=n.padInfo.top,p=n.padInfo.left;this.outputShape=n.outShape;const m="avg"===e;let b="0.0";if(m||(b="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`:`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(x="avgValue / count");const w=4*Math.floor(i/4),_=i%4,D=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${D}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===_}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${D}\n          } else if (${2===_}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${D}\n          } else if (${3===_}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${D}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class F_{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideDepth,l=n.strideHeight,u=n.strideWidth,c=n.dilationDepth,d=n.dilationHeight,h=n.dilationWidth,f=n.effectiveFilterDepth,p=n.effectiveFilterHeight,m=n.effectiveFilterWidth,g=n.padInfo.front,y=n.padInfo.top,b=n.padInfo.left;this.outputShape=n.outShape;const v="avg"===e;let x="0.0";if(v||(x="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${u});\n        const ivec3 pads = ivec3(${g}, ${y}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${p} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let _=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(_="avgValue / count");const D=4*Math.floor(i/4),A=i%4,R=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${u});\n      const ivec3 pads = ivec3(${g}, ${y}, ${b});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${D}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${R}\n            }\n\n            int xC = xCCorner + ${D};\n            if (${1===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${R}\n            } else if (${2===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${R}\n            } else if (${3===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${R}\n            }\n          }\n          setOutput(${_});\n        }\n      }\n    `}}const Npe={kernelName:xm,backendName:"webgl",kernelFunc:function Epe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;af(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(cr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Fs(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&zt(c.inShape,c.outShape))return ns({inputs:{x:s},backend:e});const d=new cf(c,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},kpe={kernelName:wm,backendName:"webgl",kernelFunc:function Tpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,d=pi(s.shape,o,i,[1,1,1],a,l,u),h=new F_(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class Ape{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const l=n.effectiveFilterHeight,u=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-n.padInfo.top}, ${u-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${n.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Rpe{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,f=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-n.padInfo.front}, ${h-1-n.padInfo.top}, ${f-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterDepth*n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Fpe={kernelName:x0,backendName:"webgl",kernelFunc:function $pe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=pi(i.shape,a,l,[1,1,1],u,c),f=new Rpe(h);return e.runWebGLProgram(f,[s],i.dtype)}},Mpe={kernelName:v0,backendName:"webgl",kernelFunc:function Ope(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;af([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Fs(i.shape,a,l,1,u),d=new Ape(c);return e.runWebGLProgram(d,[s],i.dtype)}},Lpe={kernelName:Cm,backendName:"webgl",kernelFunc:function Ppe(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;return Zy({a:s,b:o,transposeA:i,transposeB:a,backend:e})}};class Bpe{constructor(n,e,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],wt(n,e),wt(n,r);let a="0.0";null!=s&&(wt(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=o&&(wt(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class zpe{constructor(n,e,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],wt(n,e),wt(n,r);let a="vec4(0.0)";null!=s&&(wt(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(wt(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Vpe={kernelName:Fm,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;S(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const u=[r,s,o];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=a&&(d=a.shape,u.push(a));const h=ne().getBool("WEBGL_PACK_NORMALIZATION")?new zpe(r.shape,s.shape,o.shape,c,d,l):new Bpe(r.shape,s.shape,o.shape,c,d,l);return n.runWebGLProgram(h,u,u[0].dtype)}};class Upe{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const e=qt(this.rank),r=`uniform int start[${this.rank}];`,s=function Hpe(t){if(1===t)return"sourceLoc";if(t<=6)return O_.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let o;o=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${n.map((a,l)=>`sourceLoc.${O_[l]} = start[${l}] + coords.${O_[l]};`).join("\n")}\n      `,this.userCode=`\n      ${r}\n      void main() {\n        ${o}\n        setOutput(getSource(${s}));\n      }\n    `}getCustomSetupFunc(n){if(n.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${n.length})`);return(e,r)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(r,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,n)}}}const O_=["x","y","z","w","u","v"];class Wpe{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length;const e=qt(this.rank),r=$r("coords",this.rank),s=$r("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${n.map((c,d)=>`start[${d}]`).join()});`:n.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(n){if(n.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${n.length})`);return(e,r)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(r,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,n)}}}function df(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r,[a,l]=Ag(s,o,i);if(OC(s,a,l),0===te(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=Lhe(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=e.texData.get(s.dataId),c=MC(s.shape,a,l);if(u||!c){const d=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Wpe(l):new Upe(l),h=d.getCustomSetupFunc(a);return e.runWebGLProgram(d,[s],s.dtype,h)}return e.uploadToGPU(s.dataId),function jpe(t,n,e,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(e,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=e,i.dtype=t.dtype;let a=PC(n,Ve(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}(s,a,l,e)}const Gpe={kernelName:lg,backendName:"webgl",kernelFunc:df},qpe={kernelName:Im,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;S(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((b,v)=>b*v),l=Fh(s.shape,o,a),u=Oh(l.length,o.length),c=Mh(s.shape,o,a),d=kI(i,o.length),h=AI(c,i,o.length),f=[],p=Se({inputs:{x:s},backend:e,attrs:{shape:l}}),m=jr({inputs:{x:p},backend:e,attrs:{perm:u}}),g=Se({inputs:{x:m},backend:e,attrs:{shape:c}}),y=df({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return f.push(p),f.push(m),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},Xpe={kernelName:w0,backendName:"webgl",kernelFunc:function Kpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,a=e.readSync(s.dataId),l=e.readSync(o.dataId),u=BP(a,l,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},dL=fr({opSnippet:"return float(a != b);",dtype:"bool"}),Ype={kernelName:Jm,backendName:"webgl",kernelFunc:dL};function hf(t){const{inputs:n,backend:e}=t,{input:r}=n;return ns({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const Jpe={kernelName:J0,backendName:"webgl",kernelFunc:hf},eme={kernelName:Sd,backendName:"webgl",kernelFunc:function M_(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return ns({inputs:{x:s},backend:e});const i=An(s.shape),a=M_({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=ca({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=hf({inputs:{input:s},backend:e}),a=M_({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!T$(s.dtype,o)){const i=ns({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if("int32"===o)return function Qpe(t,n){const e=new ua(t.shape,"return float(int(x));"),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const i=e.makeTensorInfo([],"bool",lr("bool",1)),l=dL({inputs:{a:s,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},hL="return ceil(x);",tme=Nt({opSnippet:hL,packedOpSnippet:hL,cpuKernelImpl:xhe}),nme={kernelName:Ed,backendName:"webgl",kernelFunc:tme};class rme{constructor(n){this.variableNames=["A"],this.outputShape=n,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(n,e){return(r,s)=>{null==this.minLoc&&(this.minLoc=r.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=r.getUniformLocationNoThrow(s,"maxVal")),r.gl.uniform1f(this.minLoc,n),r.gl.uniform1f(this.maxLoc,e)}}}class sme{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(n,e){return(r,s)=>{null==this.minLoc&&(this.minLoc=r.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=r.getUniformLocationNoThrow(s,"maxVal")),r.gl.uniform1f(this.minLoc,n),r.gl.uniform1f(this.maxLoc,e)}}}const ime={kernelName:Nd,backendName:"webgl",kernelFunc:function ome(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{clipValueMin:o,clipValueMax:i}=r;let a;a=ne().getBool("WEBGL_PACK_CLIP")?new sme(s.shape):new rme(s.shape);const l=a.getCustomSetupFunc(o,i);return e.runWebGLProgram(a,[s],s.dtype,l)}};class ame{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function fL(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}const ume={kernelName:Dm,backendName:"webgl",kernelFunc:function lme(t){const{inputs:n,backend:e}=t,{x:r}=n,s=e.texData.get(r.dataId),o=new ame(r.shape),i=[fL(r,s.complexTensorInfos.real),fL(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,i,i[0].dtype)}};class cme{constructor(n){this.outputShape=[],this.outputShape=wi(n,1),this.variableNames=n.map((i,a)=>`T${a}`);const e=new Array(n.length-1);e[0]=n[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+n[i][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class dme{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=wi(n,e);const r=this.outputShape,s=r.length,o=qt(s),i=$r("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=n.map((m,g)=>`T${g}`);const l=new Array(n.length-1);l[0]=n[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+n[m][e];const u=a[e],c=a.slice(-2),d=a.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${eb(a,u,g)}),\n            vec2(${eb(c,u,g)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${eb(a,u,p)}),\n          vec2(${eb(c,u,p)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function eb(t,n,e){const r=t.indexOf(n);return t.map((o,i)=>i===r?`${o} - ${e}`:o).join()}function tb(t){const{inputs:n,backend:e}=t,{input:r}=n;return ns({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const hme={kernelName:B0,backendName:"webgl",kernelFunc:tb};function ec(t,n,e){const r=t[0].dtype;if("complex64"===r){const u=t.map(p=>hf({inputs:{input:p},backend:e})),c=t.map(p=>tb({inputs:{input:p},backend:e})),d=ec(u,n,e),h=ec(c,n,e),f=ca({inputs:{real:d,imag:h},backend:e});return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),c.forEach(p=>e.disposeIntermediateTensorInfo(p)),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),f}if("string"===r){const{tensors2D:u,outShape:c}=pL(t,n,e),d=u.map(g=>({vals:e.readSync(g.dataId),shape:g.shape})),f=whe(d,c,r,1===u[0].shape[0]),p=wi(t.map(g=>g.shape),n),m=e.makeTensorInfo(p,r,f);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}if(t.length>ne().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(t.length/2),c=ec(t.slice(0,u),n,e),d=ec(t.slice(u),n,e),h=ec([c,d],n,e);return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),h}if(ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const u=new dme(t.map(c=>c.shape),n);return e.runWebGLProgram(u,t,r)}const{tensors2D:s,outShape:o}=pL(t,n,e),i=new cme(s.map(u=>u.shape)),a=e.runWebGLProgram(i,s,r);s.forEach(u=>e.disposeIntermediateTensorInfo(u));const l=Se({inputs:{x:a},attrs:{shape:o},backend:e});return e.disposeIntermediateTensorInfo(a),l}function pL(t,n,e){const r=wi(t.map(o=>o.shape),n);return{tensors2D:t.map(o=>Se({inputs:{x:o},attrs:{shape:[-1,te(o.shape.slice(n))]},backend:e})),outShape:r}}function mL(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=mt(s,n[0].shape)[0],i=wi(n.map(u=>u.shape),o);if(0===te(i))return e.makeTensorInfo(i,n[0].dtype,[]);const a=n.filter(u=>te(u.shape)>0);return 1===a.length?ns({inputs:{x:a[0]},backend:e}):(EI(a.map(u=>u.shape),o),ec(a,o,e))}const fme={kernelName:_m,backendName:"webgl",kernelFunc:mL};class gL{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const i=n.padInfo.top,a=n.padInfo.left,l=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,d=n.dilationWidth,h=n.filterHeight,f=n.filterWidth,p=4*Math.floor(n.inChannels/4),m=n.inChannels%4,g="channelsLast"===n.dataFormat,y=g?1:2,b=g?2:3,v=g?3:1;let x="",w="";r&&(x=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const _=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${v}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${_}\n        ${w}\n        setOutput(result);\n      }\n    `}}class pme{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const e=n.padInfo.front,r=n.padInfo.top,s=n.padInfo.left,o=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,c=n.dilationWidth,d=n.filterDepth,h=n.filterHeight,f=n.filterWidth,p=4*Math.floor(n.inChannels/4),m=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mme{constructor(n,e,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const{filterWidth:s,inChannels:o,strideWidth:i,strideHeight:a,padInfo:l,outWidth:u,dilationWidth:c,dilationHeight:d,dataFormat:h}=r,{left:f,top:p}=l,m=o*s,g=Rr(),y="channelsLast"===h,b=y?0:1,v=y?1:2;let x="";for(let w=0;w<=1;w++)for(let _=0;_<=1;_++)x+=`\n          blockIndex = rc.y + ${_};\n          pos = rc.x + ${w};\n\n          if(blockIndex < ${n[1]} && pos < ${n[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${a} - ${p};\n            d0 = offsetY + ${d} * (pos / ${m});\n\n            if(d0 < ${e[b]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${i}. - ${f}.);\n              d1 = offsetX + ${c} * (int(mod(float(pos), ${m}.) / ${o}.));\n\n              if(d1 < ${e[v]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${o}.));\n\n                if (${y}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*w+_}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*w+_}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${x}\n\n        ${g.output} = result;\n      }\n    `}}function yL({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=t.shape,u=r.texData.get(t.dataId),f="channelsLast"===e.dataFormat;let g;const y=[],v=l[2]%2!=0&&!!u.isPacked;if((1!=l[0]*l[1]*l[2]&&1!==e.outChannels||!(e.inChannels>1e3))&&ne().getBool("WEBGL_LAZILY_UNPACK")&&ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&v){const w={dataId:t.dataId,shape:[1,f?l[0]*l[1]*(l[2]+1):l[0]*l[2]*(l[3]+1),e.inChannels],dtype:t.dtype},_=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,S(Hy(u.shape,w.shape),()=>`packed reshape ${u.shape} to ${w.shape} isn't free`);const D=Se({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(D);const A=Zy({a:w,b:D,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),R=r.texData.get(A.dataId);S(R.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=_,R.shape=e.outShape,g=ns({inputs:{x:A},backend:r}),g.shape=e.outShape,y.push(A)}else{const w=Se({inputs:{x:t},backend:r,attrs:{shape:[1,f?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],e.inChannels]}}),_=Se({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),D=Zy({a:w,b:_,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});g=Se({inputs:{x:D},backend:r,attrs:{shape:e.outShape}}),y.push(w),y.push(_),y.push(D)}for(const x of y)r.disposeIntermediateTensorInfo(x);return g}function bL({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:f}=e,p="channelsLast"===f,m=l*u*c,g=h*d,y=[m,g],x=[],w=Se({inputs:{x:t},backend:r,attrs:{shape:t.shape.slice(1)}}),_=Se({inputs:{x:n},backend:r,attrs:{shape:[1,m,te(n.shape)/m]}});x.push(w),x.push(_);const D=new mme(y,w.shape,e),A=r.runWebGLProgram(D,[w],"float32"),R=Se({inputs:{x:A},backend:r,attrs:{shape:[1,y[0],y[1]]}});x.push(A),x.push(R);const O=null!=s,j=null!=o,K="leakyrelu"===a,G=a?Yy(a,!0):null,Z=new QP(R.shape,_.shape,[1,g,e.outChannels],!0,!1,O,G,j,K),q=[R,_];if(s&&q.push(s),j&&q.push(o),K){const se=r.makeTensorInfo([],"float32",Gi(i,"float32"));q.push(se),x.push(se)}const Y=r.runWebGLProgram(Z,q,"float32"),ee=Se({inputs:{x:Y},backend:r,attrs:{shape:p?[1,h,d,e.outChannels]:[1,e.outChannels,h,d]}});x.push(Y);for(const se of x)r.disposeIntermediateTensorInfo(se);return ee}const yme={kernelName:Sm,backendName:"webgl",kernelFunc:function gme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=mi(l),h=er(s.shape,o.shape,i,u,a,c,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(ne().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])f=bL({x:s,filter:o,convInfo:h,backend:e});else{const m=new gL(h);f=e.runWebGLProgram(m,[s,o],"float32")}else f=yL({x:s,filter:o,convInfo:h,backend:e});const p=Se({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),p}};class bme{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===n.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vme{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,i="channelsLast"===n.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xme{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${n.strideDepth} - ${n.padInfo.front};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wme{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterDepth,r=n.filterHeight,s=n.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-n.padInfo.front}, ${r-1-n.padInfo.top}, ${s-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${n.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ime={kernelName:I0,backendName:"webgl",kernelFunc:function Cme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=mi(l),h=er(s.shape,c,i,1,a,u,!1,d),f=new bme(h);return e.runWebGLProgram(f,[s,o],"float32")}},_me={kernelName:Em,backendName:"webgl",kernelFunc:function Dme(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=mi(u),h=er(i,o.shape,a,1,l,c,!1,d),f=new vme(h);return e.runWebGLProgram(f,[s,o],"float32")}},Eme={kernelName:Nm,backendName:"webgl",kernelFunc:function Sme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=Yi(s.shape,o.shape,i,l,a),c=new pme(u);return e.runWebGLProgram(c,[s,o],"float32")}},Tme={kernelName:D0,backendName:"webgl",kernelFunc:function Nme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r,u=Yi(s.shape,l,i,1,a),c=new xme(u);return e.runWebGLProgram(c,[s,o],"float32")}},Ame={kernelName:_0,backendName:"webgl",kernelFunc:function kme(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r,u=Yi(l,o.shape,a,1,i),c=new wme(u);return e.runWebGLProgram(c,[s,o],"float32")}},$me=Nt({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),Fme={kernelName:Td,backendName:"webgl",kernelFunc:$me},Ome=Nt({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Mme={kernelName:kd,backendName:"webgl",kernelFunc:Ome};class Pme{constructor(n,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=n,[c]=e,[d,h]=r;this.outputShape=[c,d,h,u];const f="bilinear"===s?1:0,[p,m]=[a-1+".0",l-1+".0"],[g,y,b]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,x,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${x};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Lme={kernelName:S0,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,c=new Pme(s.shape,o.shape,a,l,u);return e.runWebGLProgram(c,[s,o,i],"float32")}};class vL{constructor(n,e,r){this.variableNames=["x"],this.outputShape=n;const s=n.length,o=e?"0.0":`getX(${xL(s,"coords")})`,i=n[n.length-1];let a="",l="";e?(a=r?"end != "+(i-1):"end != 0",l=r?"end + 1":"end - 1"):(a=r?`end + pow2 < ${i}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${qt(s)} coords = getOutputCoords();\n        int end = ${wL(s,"coords")};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${l};\n          ${wL(s,"coords")} = idx;\n          val += getX(${xL(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(n){return(e,r)=>{null==this.index&&(this.index=e.getUniformLocation(r,"index")),e.gl.uniform1f(this.index,n)}}}function xL(t,n){if(1===t)return`${n}`;if(2===t)return`${n}.x, ${n}.y`;if(3===t)return`${n}.x, ${n}.y, ${n}.z`;if(4===t)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function wL(t,n){if(1===t)return`${n}`;if(2===t)return`${n}.y`;if(3===t)return`${n}.z`;if(4===t)return`${n}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}const zme={kernelName:Tm,backendName:"webgl",kernelFunc:function Bme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r,l=s.shape.length,u=wn([o],l);let c=s;null!=u&&(c=jr({inputs:{x:s},backend:e,attrs:{perm:u}}));const d=kn(1,l)[0];if(d!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);const h=c.shape[d];let f=ns({inputs:{x:c},backend:e});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){const m=new vL(c.shape,!1,a),g=m.getCustomSetupFunc(p),y=f;f=e.runWebGLProgram(m,[f],f.dtype,g),e.disposeIntermediateTensorInfo(y)}if(i){const p=new vL(c.shape,i,a),m=f;f=e.runWebGLProgram(p,[f],f.dtype),e.disposeIntermediateTensorInfo(m)}if(null!=u){const m=jr({inputs:{x:f},backend:e,attrs:{perm:_u(u)}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(c),m}return f}},Ume={kernelName:E0,backendName:"webgl",kernelFunc:function Vme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=BP(l,u,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const l=e.bufferSync(s),u=e.bufferSync(o),c=vhe(l,u,i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class Hme{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const jme={kernelName:N0,backendName:"webgl",kernelFunc:function Wme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r;S(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const a=s.shape[0],d=("NHWC"===i?s.shape[1]:s.shape[2])*o,h=("NHWC"===i?s.shape[2]:s.shape[3])*o,f=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),m=new Hme("NHWC"===i?[a,d,h,f]:[a,f,d,h],o,i);return e.runWebGLProgram(m,[s],s.dtype)}};class CL{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const i=n.inHeight,a=n.inWidth,l=n.padInfo.top,u=n.padInfo.left,c=n.strideHeight,d=n.strideWidth,h=n.dilationHeight,f=n.dilationWidth,p=n.filterHeight,m=n.filterWidth,g=n.outChannels/n.inChannels;let y="",b="";r&&(y=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,b="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${c}, ${d});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${g};\n        int q = d2 - d1 * ${g};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${m}; wC++) {\n            int xC = xCCorner + wC * ${f};\n\n            if (xC < 0 || xC >= ${a}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${b}\n        setOutput(result);\n      }\n    `}}class IL{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.outShape;const i=n.inHeight,a=n.inWidth,l=n.padInfo.top,u=n.padInfo.left,c=n.strideHeight,d=n.strideWidth,h=n.dilationHeight,f=n.dilationWidth,p=n.filterHeight,m=n.filterWidth,g=m;let y="int xR; int xC; int xCOffset;";for(let w=0;w<p;w++)for(let _=0;_<m;_++)y+=`\n          vec4 xTexelR${w}C${2*_} = vec4(0.);\n          vec4 wR${w}C${_} = vec4(0.);\n          vec4 xR${w}C${_} = vec4(0.);`;for(let w=0;w<p;w++)for(let _=0;_<g;_++){const D=2*_;if(y+=`\n          xR = xRCorner + ${w*h};\n          xC = xCCorner + ${D*f};\n        `,1===d){if(D<m&&(y+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${i} && xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${w}C${D} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    xTexelR${w}C${D}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${w}C${D} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${i} && xCOffset >= 0 && xCOffset < ${a}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${w}C${D} = vec4(previous.zw, xTexelR${w}C${D}.xy);\n                } else {\n                  xR${w}C${D} = vec4(0, 0, xTexelR${w}C${D}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${i} && xC >= 0 && xC < ${a}) {\n                  xTexelR${w}C${D} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${w}C${D} = vec4(0.);\n                }\n\n                xR${w}C${D} = xTexelR${w}C${D};\n              `,D+1<m)){const A=u%2==0?S$(f):f;f%2==0&&u%2==1||f%2!=0&&u%2!=1?(y+=`\n                  xCOffset = xC + ${u%2} + ${A};\n\n                  if(xR >= 0 && xR < ${i} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${w}C${D+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,f>1&&(y+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${i} &&\n                      xCOffset >= 0 && xCOffset < ${a}) {\n                      xTexelR${w}C${D} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${w}C${D} = vec4(0.);\n                    }\n                  `),y+=`\n                  xR${w}C${D+1} = vec4(\n                    xTexelR${w}C${D}.zw, xTexelR${w}C${D+2}.xy);\n                `):y+=`\n                  xCOffset = xC + ${A};\n\n                  if(xR >= 0 && xR < ${i} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${w}C${D+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${w}C${D+1} = xTexelR${w}C${D+2};\n                `}}else D<m&&(y+=`\n              if(xR >= 0 && xR < ${i}) {\n            `,u%2==1?(y+=`\n                xCOffset = xC + 1 - ${d};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${w}C${D} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${w}C${D} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a}) {\n                  xTexelR${w}C${D+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${w}C${D+2} = vec4(0.);\n                }\n\n                xR${w}C${D} = vec4(\n                  xTexelR${w}C${D}.zw, xTexelR${w}C${D+2}.zw);\n              `,D+1<m&&(y+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${d};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${w}C${D+1} = vec4(xTexelR${w}C${D+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${a}) {\n                  xTexelR${w}C${D} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${w}C${D} = vec4(0.);\n                }\n\n                xCOffset = xC + ${d};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${w}C${D+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${w}C${D+2} = vec4(0.);\n                }\n\n                xR${w}C${D} = vec4(\n                  xTexelR${w}C${D}.xy, xTexelR${w}C${D+2}.xy);\n              `,D+1<m&&(y+=`\n                  xR${w}C${D+1} = vec4(\n                    xTexelR${w}C${D}.zw, xTexelR${w}C${D+2}.zw);\n                `)),y+="}");D<m&&(y+=`\n            vec4 wTexelR${w}C${D} = getW(${w}, ${D}, d1, q);\n            wR${w}C${D} = vec4(wTexelR${w}C${D}.xz, wTexelR${w}C${D}.xz);\n          `,D+1<m&&(y+=`\n              vec4 wTexelR${w}C${D+1} = getW(${w}, ${D+1}, d1, q);\n              wR${w}C${D+1} =\n                vec4(wTexelR${w}C${D+1}.xz, wTexelR${w}C${D+1}.xz);`))}for(let w=0;w<p;w++)for(let _=0;_<m;_++)y+=`dotProd += xR${w}C${_} * wR${w}C${_};`;let b="",v="";r&&(b=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,v="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${c}, ${d});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${y}\n\n        vec4 result = dotProd;\n        ${x}\n        ${v}\n        setOutput(result);\n      }\n    `}}const qme={kernelName:km,backendName:"webgl",kernelFunc:function Gme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),S(cr(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=er(s.shape,o.shape,i,c,a,u,!0);let h;return h=ne().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new IL(d):new CL(d),e.runWebGLProgram(h,[s,o],"float32")}};class Kme{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${n.outChannels/n.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Xme{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,l=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Jme={kernelName:T0,backendName:"webgl",kernelFunc:function Yme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,d=er(s.shape,c,i,a,l,u,!0),h=new Kme(d);return e.runWebGLProgram(h,[s,o],"float32")}},Qme={kernelName:k0,backendName:"webgl",kernelFunc:function Zme(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,d=er(c,o.shape,i,a,l,u,!0),h=new Xme(d);return e.runWebGLProgram(h,[s,o],"float32")}};class ege{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const nge={kernelName:"Diag",backendName:"webgl",kernelFunc:function tge(t){const{inputs:n,backend:e}=t,{x:r}=n,s=[...r.shape,...r.shape],o=te(r.shape),i=Se({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new ege(o),l=e.runWebGLProgram(a,[i],i.dtype),u=Se({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}};class rge{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=n,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const oge={kernelName:Am,backendName:"webgl",kernelFunc:function sge(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=wh(s.shape,o.shape,i,a,"NHWC",l);let c;const d=new rge(u);c=e.runWebGLProgram(d,[s,o],"float32");const h=Se({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),h}},ige=Nt({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),age={kernelName:Rd,backendName:"webgl",kernelFunc:ige},cge={kernelName:$0,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e}=t,{dy:r,y:s}=n,o=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new uf("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Qu("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},dge=fr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),hge={kernelName:Rm,backendName:"webgl",kernelFunc:dge},pge=Nt({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${$I};\n  float a1 = ${FI};\n  float a2 = ${OI};\n  float a3 = ${MI};\n  float a4 = ${PI};\n  float a5 = ${LI};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),mge={kernelName:$d,backendName:"webgl",kernelFunc:pge},DL="return exp(x);",_L=Nt({opSnippet:DL,packedOpSnippet:DL,cpuKernelImpl:Che}),gge={kernelName:Fd,backendName:"webgl",kernelFunc:_L};function P_(t){const{inputs:n,attrs:e,backend:r}=t,{dim:s}=e,{input:o}=n,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(S(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Se({inputs:{x:o},backend:r,attrs:{shape:a}})}const yge={kernelName:$m,backendName:"webgl",kernelFunc:P_},SL="return exp(x) - 1.0;",bge=Nt({opSnippet:SL,packedOpSnippet:SL,cpuKernelImpl:Ihe}),vge={kernelName:Od,backendName:"webgl",kernelFunc:bge};class EL{constructor(n,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===n)a="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function NL(t,n,e){const r=e.texData.get(t.dataId),s=te(t.shape),o=t.shape[t.shape.length-1],a=Se({inputs:{x:t},backend:e,attrs:{shape:[s/o,o]}}),l=a.shape,u=new EL("real",l,n),c=new EL("imag",l,n),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(u,d,"float32"),f=e.runWebGLProgram(c,d,"float32"),p=ca({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const m=Se({inputs:{x:p},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(p),m}const wge={kernelName:"FFT",backendName:"webgl",kernelFunc:function xge(t){const{inputs:n,backend:e}=t,{input:r}=n;return NL(r,!1,e)}};class Cge{constructor(n,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(n){return(e,r)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(r,"value")),e.gl.uniform1f(this.valueLoc,n)}}}function L_(t){const{backend:n,attrs:e}=t,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||gd(s),"string"===o){const i=hu(o,te(r));return i.fill(s),n.makeTensorInfo(r,o,i)}{const i=new Cge(r,s),a=i.getCustomSetupFunc(s);return n.runWebGLProgram(i,[],o,a)}}const Ige={kernelName:O0,backendName:"webgl",kernelFunc:L_};class Dge{constructor(n){this.variableNames=["Image"],this.outputShape=[];const e=n[2];this.outputShape=n,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const _ge={kernelName:M0,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t,r=n,s=new Dge(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},TL="return floor(x);",Sge=Nt({opSnippet:TL,packedOpSnippet:TL,cpuKernelImpl:Dhe}),Ege={kernelName:Md,backendName:"webgl",kernelFunc:Sge},Nge=fr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Tge={kernelName:Pd,backendName:"webgl",kernelFunc:Nge};class kge{constructor(n){this.variableNames=["A"];const e=Rr(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Age{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Rr(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const Rge={kernelName:aC,backendName:"webgl",kernelFunc:function $ge(t){const{inputs:n,backend:e,attrs:r}=t;let{pixels:s}=n;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,o];(a||i)&&(null==tc&&(tc=document.createElement("canvas").getContext("2d")),tc.canvas.width=l,tc.canvas.height=u,tc.drawImage(s,0,0,l,u),s=tc.canvas);const h=e.makeTensorInfo(c,"int32");e.texData.get(h.dataId).usage=ts.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const f=ne().getBool("WEBGL_PACK")?new Age(d):new kge(d),p=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),p}};let tc;const Oge={kernelName:bg,backendName:"webgl",kernelFunc:function Fge(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r,m=mi(c),g=er(s.shape,o.shape,l,d,u,h,!1,m);let y;const b=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(ne().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])y=bL({x:s,filter:o,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const x=null!=i,w=null!=a,_="leakyrelu"===f,D=f?Yy(f,!1):null,A=new gL(g,x,D,w,_),R=[s,o];if(i&&R.push(i),a&&R.push(a),_){const O=e.makeTensorInfo([],"float32",Gi(p,"float32"));R.push(O),b.push(O)}y=e.runWebGLProgram(A,R,"float32")}else y=yL({x:s,filter:o,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const v=Se({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(x=>e.disposeIntermediateTensorInfo(x)),v}},Pge={kernelName:vg,backendName:"webgl",kernelFunc:function Mge(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,p=[];let m=c;null==m&&(m=[1,1]),S(cr(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=er(s.shape,o.shape,l,m,u,d,!0),y=ne().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?Yy(h,y):null,v=[s,o],x=null!=i,w=null!=a,_="leakyrelu"===h;if(x&&v.push(i),w&&v.push(a),_){const R=e.makeTensorInfo([],"float32",Gi(f,"float32"));v.push(R),p.push(R)}let D;D=y?new IL(g,x,b,w,_):new CL(g,x,b,w,_);const A=e.runWebGLProgram(D,v,"float32");return p.forEach(R=>e.disposeIntermediateTensorInfo(R)),A}};class Lge{constructor(n,e,r){this.sliceDim=n,this.strides=e,this.variableNames=["x","indices"],this.outputShape=r;const s=qt(e.length),o=qt(r.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const zge={kernelName:P0,backendName:"webgl",kernelFunc:function Bge(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=s.shape,i=o[o.length-1],[a,l,u,c]=RI(r,s),d=Se({inputs:{x:s},backend:e,attrs:{shape:[l,i]}}),h=Se({inputs:{x:r},backend:e,attrs:{shape:[te(r.shape)/u,u]}}),f=new Lge(i,c,[l,u]),p=e.runWebGLProgram(f,[h,d],h.dtype),m=Se({inputs:{x:p},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),m}};class Vge{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=qt(this.rank),s=function Uge(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)r.push(2===s?"int(getIndices(resRC.x, resRC.z))":`${e[s]}`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}const Wge={kernelName:Om,backendName:"webgl",kernelFunc:function Hge(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r,u=VI(s,o,mt(i,s.shape)[0],a),c=te(o.shape),d=[],h=Se({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=Se({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(f);const p=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const b=e.bufferSync(f),v=e.bufferSync(h),x=_he(v,b,p);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(u.outputShape,x.dtype,x.values)}const m=new Vge(h.shape,p),g=e.runWebGLProgram(m,[h,f],h.dtype);d.push(g);const y=Se({inputs:{x:g},backend:e,attrs:{shape:u.outputShape}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},jge=fr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:She,dtype:"bool"}),Gge={kernelName:Mm,backendName:"webgl",kernelFunc:jge},qge=fr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),Kge={kernelName:Ld,backendName:"webgl",kernelFunc:qge},Yge={kernelName:L0,backendName:"webgl",kernelFunc:function Xge(t){const{inputs:n,backend:e}=t,{input:r}=n;return NL(r,!0,e)}},Jge=Nt({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Zge={kernelName:zd,backendName:"webgl",kernelFunc:Jge},Qge=Nt({opSnippet:"return float(isinf(x));",dtype:"bool"}),eye={kernelName:Vd,backendName:"webgl",kernelFunc:Qge},tye=Nt({opSnippet:"return float(isnan(x));",dtype:"bool"}),nye={kernelName:Ud,backendName:"webgl",kernelFunc:tye},rye=fr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Ehe,dtype:"bool"}),sye={kernelName:Lm,backendName:"webgl",kernelFunc:rye},oye=fr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),iye={kernelName:Bm,backendName:"webgl",kernelFunc:oye},lye={kernelName:z0,backendName:"webgl",kernelFunc:function aye(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=Nhe(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},uye=Nt({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:The}),cye={kernelName:Hd,backendName:"webgl",kernelFunc:uye},dye=Nt({opSnippet:"return log(1.0 + x);"}),hye={kernelName:Wd,backendName:"webgl",kernelFunc:dye},fye=fr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),pye={kernelName:zm,backendName:"webgl",kernelFunc:fye},mye=Nt({opSnippet:"return float(!(x >= 1.0));"}),gye={kernelName:Vm,backendName:"webgl",kernelFunc:mye},yye=fr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),bye={kernelName:Um,backendName:"webgl",kernelFunc:yye};class vye{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=e,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class xye{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const wye={kernelName:Hm,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r,u=ne().getBool("WEBGL_PACK_NORMALIZATION")?new xye(s.shape,o,i,a,l):new vye(s.shape,o,i,a,l);return e.runWebGLProgram(u,[s],s.dtype)}};class Cye{constructor(n,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Iye={kernelName:V0,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r,d=new Cye(s.shape,a,l,u,c);return e.runWebGLProgram(d,[s,o,i],s.dtype)}};function kL(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=mt(o,s.shape);let u=l;const c=wn(u,a),d=null!=c,h=e.shouldExecuteOnCPU([s]);let f=s;if(d){if(h){const v=e.texData.get(f.dataId).values,x=new Array(a);for(let D=0;D<x.length;D++)x[D]=s.shape[c[D]];const w=R_(v,s.shape,s.dtype,c,x);f=e.makeTensorInfo(x,s.dtype),e.texData.get(f.dataId).values=w}else f=Jy(s,c,e);u=kn(u.length,a)}dr("max",u,a);const[p,m]=tr(f.shape,u);let y,g=p;if(i&&(g=xn(p,l)),h){const v=e.texData.get(f.dataId).values,x=khe(v,te(m),g,s.dtype);y=e.makeTensorInfo(g,s.dtype),e.texData.get(y.dataId).values=x}else y=function Dye(t,n,e,r){const s=te(n),a=Se({inputs:{x:t},attrs:{shape:[te(t.shape)/s,s]},backend:r}),l=dl(a,t.dtype,"max",r),u=Se({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(f,m,g,e);return d&&e.disposeIntermediateTensorInfo(f),y}const _ye={kernelName:Wm,backendName:"webgl",kernelFunc:kL},Nye=fr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Ahe}),Tye={kernelName:jd,backendName:"webgl",kernelFunc:Nye},Aye={kernelName:jm,backendName:"webgl",kernelFunc:function kye(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;af(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(cr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Fs(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&zt(c.inShape,c.outShape))return ns({inputs:{x:s},backend:e});const d=new cf(c,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},$ye={kernelName:Gm,backendName:"webgl",kernelFunc:function Rye(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,d=pi(s.shape,o,i,[1,1,1],a,u,l),h=new F_(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class Fye{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const o=n.effectiveFilterHeight,i=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-n.padInfo.top}, ${i-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Oye{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const l=n.effectiveFilterDepth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-n.padInfo.front}, ${u-1-n.padInfo.top}, ${c-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Pye={kernelName:H0,backendName:"webgl",kernelFunc:function Mye(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=pi(i.shape,a,l,[1,1,1],u,c),f=new F_(h,"max",!0),p=e.runWebGLProgram(f,[i],i.dtype),m=new Oye(h),g=e.runWebGLProgram(m,[s,p],i.dtype);return e.disposeIntermediateTensorInfo(p),g}},Bye={kernelName:U0,backendName:"webgl",kernelFunc:function Lye(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;af([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Fs(a.shape,l,u,1,c,d),p=new cf(h,"max",!0),m=e.runWebGLProgram(p,[a],a.dtype),g=new Fye(h),y=e.runWebGLProgram(g,[s,m],a.dtype);return e.disposeIntermediateTensorInfo(m),y}},Vye={kernelName:W0,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=e;S(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];S(cr(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Fs(r.shape,s,o,u,i),[d,h]=function zye(t,n,e,r){let s=new cf(e,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");return s=new cf(e,"max",!0,!0,n),[o,r.runWebGLProgram(s,[t],"float32")]}(r,a,c,l);return[d,h]}},Hye={kernelName:qm,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{keepDims:s,axis:o}=n,i=e,a=r.shape.length,l=mt(o,r.shape);let u=l;const c=wn(u,a),d=null!=c,h=i.shouldExecuteOnCPU([r]),f=[];let p=r;if(d){if(h){const x=i.texData.get(p.dataId).values,w=new Array(a);for(let A=0;A<w.length;A++)w[A]=r.shape[c[A]];const _=R_(x,r.shape,r.dtype,c,w);p=i.makeTensorInfo(w,r.dtype),i.texData.get(p.dataId).values=_}else p=Jy(r,c,i);f.push(p),u=kn(u.length,a)}dr("sum",u,a);const[m,g]=tr(p.shape,u);let y=m;s&&(y=xn(m,l));const b=function Uye(t,n,e,r){const s=te(n),a=Se({inputs:{x:t},attrs:{shape:[te(t.shape)/s,s]},backend:r}),l=dl(a,"float32","mean",r),u=Se({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(p,g,y,i);for(const v of f)i.disposeIntermediateTensorInfo(v);return b}},jye={kernelName:Km,backendName:"webgl",kernelFunc:function Wye(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=mt(o,s.shape);let u=l;const c=wn(u,a);let d=s;null!=c&&(d=jr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=kn(u.length,s.shape.length)),dr("min",u,a);const[h,f]=tr(d.shape,u),m=Se({inputs:{x:d},backend:e,attrs:{shape:[-1,te(f)]}}),g=dl(m,m.dtype,"min",e);let y;return y=Se(i?{inputs:{x:g},backend:e,attrs:{shape:xn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}},Kye=fr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Rhe}),Xye={kernelName:Gd,backendName:"webgl",kernelFunc:Kye};class Yye{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((c,d)=>c[0]+n[d]+c[1]);const s=n.length,o=qt(s),i=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+n[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Jye{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,m)=>p[0]+n[m]+p[1]);const s=n.length,o=qt(s),i=e.map(p=>p[0]).join(","),a=e.map((p,m)=>p[0]+n[m]).join(","),l=$r("rc",s),u=$r("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===r?0:1;let f="";if(1===s){const p=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${o} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const p=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${o} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${c}) {\n            ${p}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const Zye={kernelName:Xm,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r}=t,{paddings:s,mode:o}=e,i=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Jye(r.shape,s,o):new Yye(r.shape,s,o);return n.runWebGLProgram(i,[r],r.dtype)}},tbe=fr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),nbe={kernelName:qd,backendName:"webgl",kernelFunc:tbe};class rbe{constructor(n,e,r){this.variableNames=["probs"],this.outputShape=[n,r],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(n){return(e,r)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(r,"seed")),e.gl.uniform1f(this.seedLoc,n)}}}const AL=fr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),sbe={kernelName:Ad,backendName:"webgl",kernelFunc:AL},RL="return a - b;",$L=fr({opSnippet:RL,packedOpSnippet:RL,supportsComplex:!0,cpuKernelImpl:zhe}),obe={kernelName:uh,backendName:"webgl",kernelFunc:$L};function FL(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=mt([o],s.shape),a=kL({inputs:{x:s},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=xn(a.shape,i),u=Se({inputs:{x:a},backend:e,attrs:{shape:l}}),c=$L({inputs:{a:s,b:u},backend:e}),d=_L({inputs:{x:c},backend:e}),h=$_({inputs:{x:d},backend:e,attrs:{axis:i,keepDims:!1}}),f=Se({inputs:{x:h},backend:e,attrs:{shape:l}}),p=AL({inputs:{a:d,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}const ibe={kernelName:hg,backendName:"webgl",kernelFunc:FL},lbe={kernelName:j0,backendName:"webgl",kernelFunc:function abe(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r,l=a?s:FL({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new rbe(l.shape[0],l.shape[1],o),h=d.getCustomSetupFunc(i),f=e.runWebGLProgram(d,[l],"int32",h);return a||e.disposeIntermediateTensorInfo(l),f}},OL="return -x;",cbe={kernelName:Ym,backendName:"webgl",kernelFunc:function ube(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[i,a]=Fhe(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let s;return s=ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Zu(r.shape,OL):new ua(r.shape,OL),e.runWebGLProgram(s,[r],r.dtype)}},dbe=uI,fbe={kernelName:G0,backendName:"webgl",kernelFunc:function hbe(t){Ru("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),{selectedIndices:d}=dbe(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},pbe=cI,gbe={kernelName:q0,backendName:"webgl",kernelFunc:function mbe(t){Ru("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),{selectedIndices:h,validOutputs:f}=pbe(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},ybe=dI,vbe={kernelName:K0,backendName:"webgl",kernelFunc:function bbe(t){Ru("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),h=i,f=a,p=l,m=u,{selectedIndices:g,selectedScores:y}=ybe(c,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class xbe{constructor(n,e,r,s){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const wbe={kernelName:Qm,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{depth:o,onValue:i,offValue:a}=r,l=te(s.shape),u=new xbe(l,o,i,a),c=Se({inputs:{x:s},backend:e,attrs:{shape:[l]}}),d=e.runWebGLProgram(u,[c],s.dtype);e.disposeIntermediateTensorInfo(c);const f=Se({inputs:{x:d},backend:e,attrs:{shape:[...s.shape,o]}});return e.disposeIntermediateTensorInfo(d),f}};function nb(t){const{inputs:n,backend:e}=t,{x:r}=n;if("complex64"===r.dtype){const s=hf({inputs:{input:r},backend:e}),o=nb({inputs:{x:s},backend:e}),i=tb({inputs:{input:r},backend:e}),a=nb({inputs:{x:i},backend:e}),l=ca({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return L_({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const Cbe={kernelName:gg,backendName:"webgl",kernelFunc:nb},Ibe={kernelName:Zm,backendName:"webgl",kernelFunc:function ML(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=hf({inputs:{input:r},backend:e}),o=ML({inputs:{x:s},backend:e}),i=tb({inputs:{input:r},backend:e}),a=nb({inputs:{x:i},backend:e}),l=ca({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return L_({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},_be={kernelName:eg,backendName:"webgl",kernelFunc:function Dbe(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return P_({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{fs(o,c.shape,"All tensors passed to stack must have matching shapes"),S(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=mL({inputs:n.map(c=>{const d=P_({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}};class Sbe{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((u,c)=>u[0]+n[c]+u[1]);const s=n.length,o=qt(s),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+n[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n      uniform float value;\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(n){return(e,r)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(r,"value")),e.gl.uniform1f(this.valueLoc,n)}}}class Ebe{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((m,g)=>m[0]+n[g]+m[1]);const s=n.length,o=qt(s),i=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+n[g]).join(","),l=$r("rc",s),u=$r("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${c}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${c}) {`],f=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=1===s?2:4;m<g;m++)p+=`\n        ${h[m]}\n        if (${f}) {\n          result[${m}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${m}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n      uniform float value;\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(n){return(e,r)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(r,"value")),e.gl.uniform1f(this.valueLoc,n)}}}const PL=t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r,a=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ebe(s.shape,o,i):new Sbe(s.shape,o,i),l=a.getCustomSetupFunc(i);return e.runWebGLProgram(a,[s],s.dtype,l)},Nbe={kernelName:tg,backendName:"webgl",kernelFunc:PL},Abe=fr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Rbe={kernelName:Xd,backendName:"webgl",kernelFunc:Abe},Fbe={kernelName:X0,backendName:"webgl",kernelFunc:function $be(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],u=mt(o,s.shape);let c=u;const d=wn(c,a);let f,h=s;if(null!=d&&(h=jr({inputs:{x:s},backend:e,attrs:{perm:d}}),c=kn(c.length,a),l.push(h)),dr("prod",c,a),e.shouldExecuteOnCPU([h])){const p=e.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=Ohe(h.shape,h.dtype,p,c);f=e.makeTensorInfo(g,y,m)}else{const[p,m]=tr(h.shape,c),g=te(m),y=Se({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),v=dl(y,pC(s.dtype),"prod",e);f=Se({inputs:{x:v},backend:e,attrs:{shape:p}}),l.push(y),l.push(v)}if(i){l.push(f);const p=xn(f.shape,u);f=Se({inputs:{x:f},backend:e,attrs:{shape:p}})}return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},LL=t=>{const{backend:n,attrs:e}=t,{start:r,stop:s,step:o,dtype:i}=e,a=Mhe(r,s,o,i);return n.makeTensorInfo([a.length],i,a)},Obe={kernelName:Y0,backendName:"webgl",kernelFunc:LL},Mbe=Nt({opSnippet:"return 1.0 / x;"}),Pbe={kernelName:Yd,backendName:"webgl",kernelFunc:Mbe},Bbe=Nt({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),zbe={kernelName:Jd,backendName:"webgl",kernelFunc:Bbe},Ube=Nt({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Hbe={kernelName:Zd,backendName:"webgl",kernelFunc:Ube};class Wbe{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class jbe{constructor(n,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const qbe={kernelName:og,backendName:"webgl",kernelFunc:function Gbe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=ne().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new jbe(s.shape,l,u,o,i):new Wbe(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],"float32")}};class Kbe{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Ybe={kernelName:Q0,backendName:"webgl",kernelFunc:function Xbe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new Kbe(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class Jbe{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}const Qbe={kernelName:sg,backendName:"webgl",kernelFunc:function Zbe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=new Jbe(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],s.dtype)}};class eve{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const nve={kernelName:Z0,backendName:"webgl",kernelFunc:function tve(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new eve(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class rve{constructor(n,e){this.variableNames=["x"];const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const o=n.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==n[a]?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),i=qt(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class sve{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;const s=$r("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=qt(r);function h(p){const m=n.map((b,v)=>function f(p,m){return-1!==e.indexOf(p)&&1!==n[p]?`${n[p]} - ${m[p]} - 1`:`${m[p]}`}(v,p));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(s.slice())};\n          if(${o}){\n            result.g = ${function u(p){return p[r-1]="("+p[r-1]+" + 1)",h(p)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function c(p){return p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            if(${o}) {\n              result.a = ${function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const ive={kernelName:ig,backendName:"webgl",kernelFunc:function ove(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r,i=s.shape.length,a=mt(o,s.shape);if(0===i)return ns({inputs:{x:s},backend:e});const l=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sve(s.shape,a):new rve(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class ave{constructor(n,e){this.variableNames=["Image"],this.outputShape=[];const r=n[1],s=n[2];this.outputShape=n;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(n,e,r,s){return(o,i)=>{null==this.paramsLoc&&(this.paramsLoc=o.getUniformLocationNoThrow(i,"params")),o.gl.uniform4f(this.paramsLoc,n,e,r,s)}}}const lve={kernelName:lC,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,l=new ave(r.shape,o),[u,c]=TI(i,r.shape[1],r.shape[2]),d=l.getCustomSetupFunc(u,c,Math.sin(s),Math.cos(s));return a.runWebGLProgram(l,[r],r.dtype,d)}},uve=Nt({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),cve={kernelName:Qd,backendName:"webgl",kernelFunc:uve},dve=Nt({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Phe}),hve={kernelName:eh,backendName:"webgl",kernelFunc:dve};class BL{constructor(n,e,r,s,o,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const l=qt(o.length),u=qt(i.length);let c="";1===r?c="i":2===r&&(c="i, j");let h="";1===s?h="i":2===s&&(h="i, coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${c}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${h});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const pve={kernelName:eC,backendName:"webgl",kernelFunc:function fve(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Ph(0,s,i),h=[d/u,u];if(0===d)return e.makeTensorInfo(i,s.dtype);const f=Se({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),p=Se({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new BL(l,a,f.shape.length,p.shape.length,c,h),y=e.runWebGLProgram(g,[p,f,m],p.dtype),b=Se({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),b}};class mve{constructor(n,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<n&&l.push(`${a[c]}`);s=l.join(),o=u.join()}const i=qt(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const yve={kernelName:ag,backendName:"webgl",kernelFunc:function gve(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n,i=new mve(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(i,[r,s,o],ps(s.dtype,o.dtype))}},vve=Nt({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${ey};\n  float scale = ${ty};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),xve={kernelName:th,backendName:"webgl",kernelFunc:vve},wve=Nt({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),Cve={kernelName:oh,backendName:"webgl",kernelFunc:wve},Ive=Nt({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Dve={kernelName:sh,backendName:"webgl",kernelFunc:Ive},Sve=Nt({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),Eve={kernelName:nh,backendName:"webgl",kernelFunc:Sve},Nve=Nt({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Tve={kernelName:rh,backendName:"webgl",kernelFunc:Nve},kve=Nt({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Ave={kernelName:ih,backendName:"webgl",kernelFunc:kve},Rve={kernelName:cg,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;S(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+o.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=PL({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=Fh(c.shape,o,a,!1),h=Oh(d.length,o.length,!1),f=Mh(c.shape,o,a,!1),p=Se({inputs:{x:c},backend:e,attrs:{shape:d}}),m=jr({inputs:{x:p},backend:e,attrs:{perm:h}}),g=Se({inputs:{x:m},backend:e,attrs:{shape:f}});return u.push(c),u.push(p),u.push(m),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}},Fve={kernelName:nC,backendName:"webgl",kernelFunc:function $ve(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,strides:c,outputSize:d}=Ph(0,s,a),f=new BL(u,l,s.shape.length,o.shape.length,c,[d,1],!1),p=e.runWebGLProgram(f,[o,s,i],o.dtype),m=Se({inputs:{x:p},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(p),m}},Mve={kernelName:dg,backendName:"webgl",kernelFunc:function Ove(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=mt(i,s.shape)[0],l=zI(s,o,a),c=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=df({inputs:{x:s},backend:e,attrs:{begin:c,size:f}});return c[a]+=h,p})}},Pve=Nt({opSnippet:"return sqrt(x);"}),Lve={kernelName:ah,backendName:"webgl",kernelFunc:Pve},zve={kernelName:tC,backendName:"webgl",kernelFunc:Nt({opSnippet:"return x * x;"})},zL="return (a - b) * (a - b);",Vve=fr({opSnippet:zL,packedOpSnippet:zL}),Uve={kernelName:lh,backendName:"webgl",kernelFunc:Vve},Wve={kernelName:fh,backendName:"webgl",kernelFunc:function Hve({inputs:t,attrs:n,backend:e}){const{x:r}=t,o=new ua(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class jve{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=qt(r.length),i=qt(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,1===r.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${n});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const qve={kernelName:rC,backendName:"webgl",kernelFunc:function Gve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{nonStrided:f,$begin:p,$strides:m,size:g,newShape:y,outShape:b}=LC(s.shape,o,i,a,l,u,c,d,h),v=Se({inputs:{x:s},backend:e,attrs:{shape:y}});let x;if(f){const _=df({inputs:{x:v},backend:e,attrs:{begin:p,size:g}});x=Se({inputs:{x:_},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(_)}else if(b.some(_=>0===_))x=e.makeTensorInfo(b,s.dtype,[]);else if(e.shouldExecuteOnCPU([v])){const A=e.texData.get(v.dataId).values,R=xt(v.shape,v.dtype,A),O=Bhe(b,R,m,p);x=e.makeTensorInfo(b,v.dtype,O.values)}else{const D=new jve(p,m,b);x=e.runWebGLProgram(D,[v],v.dtype)}const w=Se({inputs:{x},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),w}},Kve=Nt({opSnippet:"return tan(x);"}),Xve={kernelName:ch,backendName:"webgl",kernelFunc:Kve},Yve=Nt({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Jve={kernelName:dh,backendName:"webgl",kernelFunc:Yve};class Zve{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*e[i];this.outputShape=r,this.rank=r.length;const s=qt(this.rank),o=function Qve(t){const n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${t[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${e[s]}, ${t[s]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function VL(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;if("string"===s.dtype){const u=e.readSync(s.dataId).map(h=>mu(h)),c=xt(s.shape,s.dtype,u),d=Vhe(c,o);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new Zve(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const exe={kernelName:hh,backendName:"webgl",kernelFunc:VL},nxe={kernelName:sC,backendName:"webgl",kernelFunc:function txe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o,sorted:i}=r,a=e.readSync(s.dataId),[l,u]=Uhe(a,s.shape,s.dtype,o,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}};class rxe{constructor(n,e,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const oxe={kernelName:oC,backendName:"webgl",kernelFunc:function sxe(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,d,h,f]=s.shape,[p,m]=u??[d,h],y=new rxe(d,h,i,a,l,[c,p,m,f]);return e.runWebGLProgram(y,[s,o],"float32")}},axe={kernelName:iC,backendName:"webgl",kernelFunc:function ixe(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;af(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=Hhe(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},uxe={kernelName:pg,backendName:"webgl",kernelFunc:function lxe(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],u=new Array(a-1);let c=0;for(let m=0;m<a;m++)m!==o&&(u[c++]=i.shape[m]);const d=[],h=new Array(a).fill(0),f=i.shape.slice();f[o]=1;const p=new Array(l);for(let m=0;m<p.length;m++){h[o]=m;const g=df({inputs:{x:i},backend:e,attrs:{begin:h,size:f}}),y=Se({inputs:{x:g},backend:e,attrs:{shape:u}});p[m]=y,d.push(g)}return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}};class cxe{constructor(n,e){this.variableNames=["x","segmentIds"];const r=n.windowSize,s=n.batchSize,o=n.inSize,i=n.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const c=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const fxe=[wye,Iye,Vfe,Hfe,Gfe,Xfe,Jfe,epe,npe,spe,lpe,cpe,fpe,gpe,Ipe,vpe,Spe,kpe,Npe,Fpe,Mpe,Lpe,Vpe,qpe,Xpe,eme,nme,ime,ume,Cfe,fme,Ime,_me,yme,Tme,Ame,Eme,Fme,Mme,Lme,zme,Ume,jme,Jme,Qme,qme,nge,oge,age,cge,hge,mge,gge,yge,vge,wge,Ige,_ge,Ege,Tge,Rge,Oge,Pge,zge,Wge,Gge,Kge,wfe,Yge,hme,Zge,eye,nye,Dfe,sye,iye,lye,hye,cye,pye,gye,bye,_ye,$ye,Aye,Pye,Bye,Vye,Tye,Hye,jye,Xye,Zye,nbe,lbe,Tfe,cbe,fbe,gbe,vbe,Ype,wbe,Ibe,_be,Nbe,Rbe,Sfe,Fbe,Obe,Jpe,sbe,Pbe,Hbe,zbe,Afe,qbe,Ybe,Qbe,nve,ive,lve,cve,hve,pve,yve,xve,Cve,Dve,Eve,Tve,Gpe,ibe,Ave,Rve,Fve,Mve,Lve,zve,Uve,Wve,qve,obe,Lfe,Xve,Jve,exe,nxe,oxe,Bfe,axe,uxe,{kernelName:mg,backendName:"webgl",kernelFunc:function dxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r,a=s.shape.length,l=[];let u=0;const c=wn([u],a);let d=s;null!=c&&(d=jr({inputs:{x:s},backend:e,attrs:{perm:c}}),l.push(d),u=kn(1,a)[0]);const h=sF(d.shape,u,i),f=te([d.shape[u]]),p=Se({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}});l.push(p);const m=pC(s.dtype),g=(x,w,_,D,A)=>{const R=x.shape[0],O=x.shape[1],j=rF(O,A),G=new cxe({windowSize:j,inSize:O,batchSize:R,numSegments:A},w),Z=e.compileAndRun(G,[x,_],D);if(l.push(Z),Z.shape[1]===A)return Z;const q=LL({backend:e,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),Y=VL({inputs:{x:q},backend:e,attrs:{reps:[O/j]}});return l.push(q),l.push(Y),g(Z,w,Y,D,A)},b=Se({inputs:{x:g(p,"unsortedSegmentSum",o,m,i)},backend:e,attrs:{shape:h}});let v=b;if(null!=c){l.push(b);const x=_u(c);v=jr({inputs:{x:v},backend:e,attrs:{perm:x}})}return l.forEach(x=>e.disposeIntermediateTensorInfo(x)),v}},Cbe];for(const t of fxe)dC(t);const yxe={flipHorizontal:!1,outputStride:16,imageScaleFactor:1,maxNumBoxes:20,iouThreshold:.2,scoreThreshold:.6,modelType:"ssd320fpnlite",modelSize:"small",bboxLineWidth:"2",fontSize:17,basePath:"https://cdn.jsdelivr.net/npm/handtrackjs@latest/models/webmodel/",labelMap:{1:"open",2:"closed",3:"pinch",4:"point",5:"face",6:"pointtip",7:"pinchtip"},renderThresholds:null},bxe={large:"base",medium:"fp16",small:"int8"},UL={open:"#374151",closed:"#B91C1C",pinch:"#F59E0B",point:"#10B981",face:"#3B82F6",pointtip:"#6366F1",pinchtip:"#EC4899"},HL={ssd320fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],ssd640fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],centernet512fpn:["Identity_4:0","Identity:0","Identity_2:0"]};function B_(){return(B_=Q(function*(t){let n=Object.assign({},yxe,t);const e=new Cxe(n);return yield e.load(),e})).apply(this,arguments)}function z_(){return(z_=Q(function*(){if(!window.localStream)return!1;window.localStream.getTracks().forEach(t=>(t.stop(),!0))})).apply(this,arguments)}class Cxe{constructor(n){this.modelPath=n.basePath+n.modelType+"/"+(bxe[n.modelSize]||"base")+"/model.json ",this.modelParams=n}load(){var n=this;return Q(function*(){n.fps=0,n.model=yield function yse(t){return i_.apply(this,arguments)}(n.modelPath);const e=An([1,300,300,3],"int32"),r=yield n.model.executeAsync(e,HL[n.modelParams.modelType]);r.map(function(){var s=Q(function*(o){return yield o.data()});return function(o){return s.apply(this,arguments)}}()),r.map(function(){var s=Q(function*(o){return o.dispose()});return function(o){return s.apply(this,arguments)}}()),ut(e)})()}detect(n){var e=this;return Q(function*(){let r=Date.now();const[s,o]=function Ixe(t){return t instanceof un?[t.shape[0],t.shape[1]]:[t.height,t.width]}(n),i=WL(e.modelParams.imageScaleFactor,s,e.modelParams.outputStride),a=WL(e.modelParams.imageScaleFactor,o,e.modelParams.outputStride),l=U(()=>{const c=_7(n);return e.modelParams.flipHorizontal?c.reverse(1).resizeBilinear([i,a]).expandDims(0).toInt():c.resizeBilinear([i,a]).expandDims(0).toInt()}),u=e;return e.model.executeAsync(l,HL[e.modelParams.modelType]).then(function(c){l.dispose();let d=[];if("centernet512fpn"===u.modelParams.modelType){const f=c[0].dataSync(),p=c[1].arraySync(),m=c[2].dataSync();ut(c),d=u.buildDetectObjectsCenternet(o,s,p[0],f,m),console.log(d)}else{const f=c[0].dataSync(),p=c[1].dataSync();ut(c);const[m,g]=function Dxe(t,n,e){const r=[],s=[];for(let o=0;o<n;o++){let i=Number.MIN_VALUE,a=-1;for(let l=0;l<e;l++)t[o*e+l]>i&&(i=t[o*e+l],a=l);r[o]=i,s[o]=a}return[r,s]}(f,c[0].shape[1],c[0].shape[2]),y=function N7(){return F.backendName}();E2("cpu");const b=U(()=>{const x=Ah(p,[c[1].shape[1],c[1].shape[3]]);return Za.nonMaxSuppression(x,m,u.modelParams.maxNumBoxes,u.modelParams.iouThreshold,u.modelParams.scoreThreshold)}),v=b.dataSync();b.dispose(),E2(y),d=u.buildDetectedObjects(o,s,p,m,v,g)}let h=Date.now();return u.fps=Math.round(1e3/(h-r)),d})})()}buildDetectedObjects(n,e,r,s,o,i){const a=o.length,l=[];for(let u=0;u<a;u++){const c=[];for(let g=0;g<4;g++)c[g]=r[4*o[u]+g];const d=c[0]*e,h=c[1]*n,f=c[2]*e,p=c[3]*n;c[0]=h,c[1]=d,c[2]=p-h,c[3]=f-d;const m=Math.round(i[o[u]])+1;l.push({bbox:c,class:m,label:this.modelParams.labelMap[m],score:s[o[u]].toFixed(2)})}return l}buildDetectObjectsCenternet(n,e,r,s,o){const i=[];for(let a=0;a<s.length;a++){const l=r[a],u=l[0]*e,c=l[1]*n,d=l[2]*e,h=l[3]*n;l[0]=c,l[1]=u,l[2]=h-c,l[3]=d-u;const f=Math.round(o[a])+1;i.push({bbox:l,class:f,label:this.modelParams.labelMap[f],score:s[a].toFixed(2)})}return i.slice(0,10)}getFPS(){return this.fps}setModelParameters(n){this.modelParams=Object.assign({},this.modelParams,n)}getModelParameters(){return this.modelParams}roundRect(n,e,r,s,o,i,a,l){if(typeof l>"u"&&(l=!0),typeof i>"u"&&(i=5),"number"==typeof i)i={tl:i,tr:i,br:i,bl:i};else{var u={tl:0,tr:0,br:0,bl:0};for(var c in u)i[c]=i[c]||u[c]}n.beginPath(),n.moveTo(e+i.tl,r),n.lineTo(e+s-i.tr,r),n.quadraticCurveTo(e+s,r,e+s,r+i.tr),n.lineTo(e+s,r+o-i.br),n.quadraticCurveTo(e+s,r+o,e+s-i.br,r+o),n.lineTo(e+i.bl,r+o),n.quadraticCurveTo(e,r+o,e,r+o-i.bl),n.lineTo(e,r+i.tl),n.quadraticCurveTo(e,r,e+i.tl,r),n.closePath(),a&&n.fill(),l&&n.stroke()}renderPredictions(n,e,r,s){r.clearRect(0,0,e.width,e.height),e.width=s.width,e.height=s.height,e.style.height=parseInt(e.style.width)*(s.height/s.width).toFixed(2)+"px",r.save(),this.modelParams.flipHorizontal&&(r.scale(-1,1),r.translate(-s.width,0)),r.drawImage(s,0,0,s.width,s.height),r.restore(),r.font="bold "+this.modelParams.fontSize+"px Arial";const o=this.modelParams.renderThresholds;for(let i=0;i<n.length;i++){const a=n[i];(!o||a.score>o[a.label])&&(r.beginPath(),r.fillStyle="rgba(255, 255, 255, 0.6)",r.fillRect(a.bbox[0]+1,a.bbox[1]+1,a.bbox[2]-1,1.5*this.modelParams.fontSize),r.lineWidth=this.modelParams.bboxLineWidth,this.roundRect(r,a.bbox[0],a.bbox[1],a.bbox[2],a.bbox[3],5,!1,!0),r.strokeStyle=UL[a.label],r.fillStyle=UL[a.label],r.stroke(),r.beginPath(),r.arc(a.bbox[0]+a.bbox[2]/2,a.bbox[1]+a.bbox[3]/2,2,0,2*Math.PI),r.fill(),r.stroke(),r.fillText(a.score+" | "+a.label,a.bbox[0]+5,a.bbox[1]+1.1*this.modelParams.fontSize))}r.fillStyle="rgba(255, 255, 255, 0.6)",this.roundRect(r,10,10,4.6*this.modelParams.fontSize,this.modelParams.fontSize+8,5,!0,!1),r.strokeStyle="#374151",r.fillStyle="#374151",r.font="bold "+this.modelParams.fontSize+"px Arial",r.fillText("FPS: "+this.fps,18,this.modelParams.fontSize+12)}dispose(){this.model&&this.model.dispose()}}function WL(t,n,e){const r=n*t-1;return r-r%e+1}class _xe{constructor(n){this.prediction="None",this.prediction=n}getPrediction(){return this.prediction}}const Sxe=["htvideo"];let Exe=(()=>{class t{constructor(){this.onPrediction=new Nr,this.SAMPLERATE=100,this.detectedGesture="None",this.width="400",this.height="400",this.model=null,this.runInterval=null,this.modelParams={flipHorizontal:!1,maxNumBoxes:20,iouThreshold:.5,scoreThreshold:.63},this.status="Loading Page Components..."}ngOnInit(){(function vxe(t){return B_.apply(this,arguments)})(this.modelParams).then(e=>{this.model=e,console.log("Loaded"),this.status="Successfully Loaded"})}ngOnDestroy(){this.model.dispose()}startVideo(){return this.status="Loading Video",function xxe(t){return new Promise(function(n,e){t||n({status:!1,msg:"please provide a valid video element"}),t.width=t.width||640,t.height=t.width*(t.videoHeight/t.videoWidth),t.style.height="20px",navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user"}}).then(r=>{window.localStream=r,t.srcObject=r,t.onloadedmetadata=()=>{t.height=t.width*(t.videoHeight/t.videoWidth),t.style.height=parseInt(t.style.width)*(t.videoHeight/t.videoWidth).toFixed(2)+"px",t.play(),n({status:!0,msg:"webcam successfully initiated."})}}).catch(function(r){n({status:!1,msg:r})})})}(this.video.nativeElement).then(function(e){return e},e=>e).then(this.status="Video Successfully Loaded")}startDetection(){this.startVideo().then(()=>{this.video.nativeElement.style.height="200px",this.status="Started Predictions",console.log("starting predictions"),this.runInterval=setInterval(()=>{this.runDetection()},this.SAMPLERATE)},e=>{console.log(e)})}stopDetection(){this.status="Stopped Predictions",console.log("stopping predictions"),clearInterval(this.runInterval),function wxe(){z_.apply(this,arguments)}(this.video.nativeElement)}runDetection(){null!=this.model?this.model.detect(this.video.nativeElement).then(r=>{if(r.length<=0)return;let s=0,o=0,i=0,a=0;for(let l of r)"open"==l.label&&(s++,this.startOpenHandPos=this.currOpenHandPos,this.currOpenHandPos=l.bbox),"closed"==l.label&&o++,"point"==l.label&&i++,"pinch"==l.label&&a++;if(1==s&&(this.recentOpenHandTime=(new Date).getTime()),(0==s||2==s&&null!=this.startOpenHandPos)&&(new Date).getTime()-this.recentOpenHandTime>500&&(this.startOpenHandPos=null,this.currOpenHandPos=null,this.recentOpenHandTime=null,this.swipeDir=null),this.swipeDir)return this.swipeDir;s>1?this.detectedGesture="Two Open Hands":1==s&&(this.detectedGesture="Open Hand"),o>1?this.detectedGesture="Two Closed Hands":1==o&&(this.detectedGesture="Closed Hand"),i>1?this.detectedGesture="Two Hands Pointing":1==i&&(this.detectedGesture="Hand Pointing"),0==s&&0==o&&0==i&&0==a&&(this.detectedGesture="None"),1==s&&this.startOpenHandPos&&this.startOpenHandPos[0]>this.currOpenHandPos[0]?(this.swipeDir="Swiping right",this.detectedGesture="Swiping right"):1==s&&this.startOpenHandPos&&this.currOpenHandPos[0]>this.startOpenHandPos[0]&&(this.swipeDir="Swiping Left",this.detectedGesture="Swiping left"),this.previouslyEmitted!=this.detectedGesture&&(this.previouslyEmitted=this.detectedGesture,this.onPrediction.emit(new _xe(this.detectedGesture)))},r=>{console.log("ERROR"),console.log(r)}):console.log("no model")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ya({type:t,selectors:[["app-handtracker"]],viewQuery:function(e,r){if(1&e&&Rx(Sxe,5),2&e){let s;xp(s=wp())&&(r.video=s.first)}},outputs:{onPrediction:"onPrediction"},decls:13,vars:2,consts:[[1,"start-stop"],[3,"click"],["id","htvideo","name","htvideo","autoplay","autoplay",1,"videobox"],["htvideo",""]],template:function(e,r){1&e&&(Je(0,"p"),_t(1,"Detected Gesture"),Ze(),Je(2,"h1"),_t(3),Ze(),Je(4,"div",0)(5,"button",1),br("click",function(){return r.startDetection()}),_t(6,"Start"),Ze(),Je(7,"button",1),br("click",function(){return r.stopDetection()}),_t(8,"Stop"),Ze()(),qn(9,"video",2,3),Je(11,"p"),_t(12),Ze()),2&e&&(Sn(3),Eo(r.detectedGesture),Sn(9),fp("Status: ",r.status,""))},styles:[".videobox[_ngcontent-%COMP%]{border:3px solid #0063FF;border-color:#0063ff;width:200px;height:200px}*[_ngcontent-%COMP%]{font-family:Oswald,sans-serif}.start-stop[_ngcontent-%COMP%]{display:flex;justify-content:center}.start-stop[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{width:50%}"]}),t})();function Nxe(t,n){if(1&t){const e=ql();Je(0,"app-handtracker",6),br("onPrediction",function(s){return Zs(e),Qs(Er().prediction(s))}),Ze()}}function Txe(t,n){1&t&&(Je(0,"div")(1,"a",7),_t(2,"Hand icons created by Vitaly Gorbachev - Flaticon"),Ze(),Je(3,"a",8),_t(4,"Cursor icons created by berkahicon - Flaticon"),Ze(),Je(5,"a",9),_t(6,"Fist icons created by vectorspoint - Flaticon"),Ze(),Je(7,"a",10),_t(8,"Next icons created by Arkinasi - Flaticon"),Ze(),Je(9,"a",11),_t(10,"Previous icons created by Arkinasi - Flaticon"),Ze(),Je(11,"a",12),_t(12,"Star icons created by Pixel perfect - Flaticon"),Ze(),Je(13,"a",12),_t(14,"Star icons created by mim_studio - Flaticon"),Ze(),Je(15,"a",13),_t(16,"Zoom in icons created by Prosymbols - Flaticon"),Ze(),Je(17,"a",14),_t(18,"Trash icons created by Freepik - Flaticon"),Ze()())}const kxe=[{path:"",component:(()=>{class t{constructor(){this.gesture="",this.viewImageSources=!1}ngOnInit(){}prediction(e){this.gesture=e.getPrediction(),console.log(`EVENT RECEIVED: ${this.gesture}`),"Swiping left"==this.gesture?this.jokesInterface.prev():"Swiping right"==this.gesture?this.jokesInterface.next():"Closed Hand"==this.gesture?this.jokesInterface.reveal():"Two Hands Pointing"==this.gesture?this.jokesInterface.discardAll():"Two Open Hands"==this.gesture?this.jokesInterface.generateJokes():"Hand Pointing"==this.gesture&&this.jokesInterface.favorite(),"Two Closed Hands"==this.gesture?this.jokesInterface.zoom():this.jokesInterface.unzoom()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ya({type:t,selectors:[["app-home-page"]],viewQuery:function(e,r){if(1&e&&Rx(C$,5),2&e){let s;xp(s=wp())&&(r.jokesInterface=s.first)}},decls:11,vars:2,consts:[["rel","preconnect","href","https://fonts.googleapis.com"],["rel","preconnect","href","https://fonts.gstatic.com","crossorigin",""],["href","https://fonts.googleapis.com/css2?family=Oswald:wght@500&display=swap","rel","stylesheet"],[3,"onPrediction",4,"ngIf"],["name","button",3,"click"],[4,"ngIf"],[3,"onPrediction"],["href","https://www.flaticon.com/free-icons/hand","title","hand icons"],["href","https://www.flaticon.com/free-icons/cursor","title","cursor icons"],["href","https://www.flaticon.com/free-icons/fist","title","fist icons"],["href","https://www.flaticon.com/free-icons/next","title","next icons"],["href","https://www.flaticon.com/free-icons/previous","title","previous icons"],["href","https://www.flaticon.com/free-icons/star","title","star icons"],["href","https://www.flaticon.com/free-icons/zoom-in","title","zoom in icons"],["href","https://www.flaticon.com/free-icons/trash","title","trash icons"]],template:function(e,r){1&e&&(qn(0,"link",0)(1,"link",1)(2,"link",2),Je(3,"body")(4,"div"),qn(5,"app-jokes-generating-interface"),Es(6,Nxe,1,0,"app-handtracker",3),Ze(),qn(7,"br"),Je(8,"button",4),br("click",function(){return r.viewImageSources=!r.viewImageSources}),_t(9,"View Image Credits"),Ze(),Es(10,Txe,19,0,"div",5),Ze()),2&e&&(Sn(6),hs("ngIf",1),Sn(4),hs("ngIf",r.viewImageSources))},dependencies:[hw,Exe,C$],styles:["[_ngcontent-%COMP%]:root{--dark: #0a121f}body[_ngcontent-%COMP%]{background-color:#d2d2d9;height:100%;width:100%;margin:0}div[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:space-between}app-jokes-generating-interface[_ngcontent-%COMP%]{width:90%}*[_ngcontent-%COMP%]{font-family:Oswald,sans-serif}"]}),t})()}];let Axe=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Ai({type:t}),t.\u0275inj=Ko({imports:[s$.forRoot(kxe),s$]}),t})(),Rxe=(()=>{class t{constructor(){this.title="at-alternative-interaction-solution"}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ya({type:t,selectors:[["app-root"]],decls:1,vars:0,template:function(e,r){1&e&&qn(0,"router-outlet")},dependencies:[Hw]}),t})(),$xe=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Ai({type:t,bootstrap:[Rxe]}),t.\u0275inj=Ko({imports:[F8,Axe,qK]}),t})();$8().bootstrapModule($xe).catch(t=>console.error(t))},537:(ce,_e,B)=>{var he=B(123),at=B(786),X=B(516),Qe=B(868),be=B(902),Ce=B(576),ie=B(390);ie.alea=he,ie.xor128=at,ie.xorwow=X,ie.xorshift7=Qe,ie.xor4096=be,ie.tychei=Ce,ce.exports=ie},123:function(ce,_e,B){var he;!function(at,X,Qe){function be(I){var k=this,$=function P(){var I=4022871197;return function($){$=$.toString();for(var E=0;E<$.length;E++){var N=.02519603282416938*(I+=$.charCodeAt(E));N-=I=N>>>0,I=(N*=I)>>>0,I+=4294967296*(N-=I)}return 2.3283064365386963e-10*(I>>>0)}}();k.next=function(){var E=2091639*k.s0+2.3283064365386963e-10*k.c;return k.s0=k.s1,k.s1=k.s2,k.s2=E-(k.c=0|E)},k.c=1,k.s0=$(" "),k.s1=$(" "),k.s2=$(" "),k.s0-=$(I),k.s0<0&&(k.s0+=1),k.s1-=$(I),k.s1<0&&(k.s1+=1),k.s2-=$(I),k.s2<0&&(k.s2+=1),$=null}function Ce(I,k){return k.c=I.c,k.s0=I.s0,k.s1=I.s1,k.s2=I.s2,k}function ie(I,k){var $=new be(I),E=k&&k.state,N=$.next;return N.int32=function(){return 4294967296*$.next()|0},N.double=function(){return N()+11102230246251565e-32*(2097152*N()|0)},N.quick=N,E&&("object"==typeof E&&Ce(E,$),N.state=function(){return Ce($,{})}),N}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.alea=ie}(0,ce=B.nmd(ce))},576:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.next=function(){var E=I.b,N=I.c,z=I.d,H=I.a;return E=E<<25^E>>>7^N,N=N-z|0,z=z<<24^z>>>8^H,H=H-E|0,I.b=E=E<<20^E>>>12^N,I.c=N=N-z|0,I.d=z<<16^N>>>16^H,I.a=H-E|0},I.a=0,I.b=0,I.c=-1640531527,I.d=1367130551,P===Math.floor(P)?(I.a=P/4294967296|0,I.b=0|P):k+=P;for(var $=0;$<k.length+20;$++)I.b^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.a=P.a,I.b=P.b,I.c=P.c,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.tychei=ie}(0,ce=B.nmd(ce))},786:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.x=0,I.y=0,I.z=0,I.w=0,I.next=function(){var E=I.x^I.x<<11;return I.x=I.y,I.y=I.z,I.z=I.w,I.w^=I.w>>>19^E^E>>>8},P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor128=ie}(0,ce=B.nmd(ce))},902:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this;I.next=function(){var z,H,$=I.w,E=I.X,N=I.i;return I.w=$=$+1640531527|0,H=E[N+34&127],z=E[N=N+1&127],H^=H<<13,z^=z<<17,H=E[N]=(H^=H>>>15)^(z^=z>>>12),I.i=N,H+($^$>>>16)|0},function k($,E){var N,z,H,et,Mt,Dt=[],Dn=128;for(E===(0|E)?(z=E,E=null):(E+="\0",z=0,Dn=Math.max(Dn,E.length)),H=0,et=-32;et<Dn;++et)E&&(z^=E.charCodeAt((et+32)%E.length)),0===et&&(Mt=z),z^=z<<10,z^=z>>>15,z^=z<<4,z^=z>>>13,et>=0&&(H=0==(N=Dt[127&et]^=z+(Mt=Mt+1640531527|0))?H+1:0);for(H>=128&&(Dt[127&(E&&E.length||0)]=-1),H=127,et=512;et>0;--et)z=Dt[H+34&127],N=Dt[H=H+1&127],z^=z<<13,N^=N<<17,Dt[H]=(z^=z>>>15)^(N^=N>>>12);$.w=Mt,$.X=Dt,$.i=H}(I,P)}function Ce(P,I){return I.i=P.i,I.w=P.w,I.X=P.X.slice(),I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&($.X&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor4096=ie}(0,ce=B.nmd(ce))},868:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this;I.next=function(){var N,z,$=I.x,E=I.i;return N=$[E],z=(N^=N>>>7)^N<<24,z^=(N=$[E+1&7])^N>>>10,z^=(N=$[E+3&7])^N>>>3,z^=(N=$[E+4&7])^N<<7,N=$[E+7&7],$[E]=z^=(N^=N<<13)^N<<9,I.i=E+1&7,z},function k($,E){var N,H=[];if(E===(0|E))H[0]=E;else for(E=""+E,N=0;N<E.length;++N)H[7&N]=H[7&N]<<15^E.charCodeAt(N)+H[N+1&7]<<13;for(;H.length<8;)H.push(0);for(N=0;N<8&&0===H[N];++N);for(8==N&&(H[7]=-1),$.x=H,$.i=0,N=256;N>0;--N)$.next()}(I,P)}function Ce(P,I){return I.x=P.x.slice(),I.i=P.i,I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&($.x&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorshift7=ie}(0,ce=B.nmd(ce))},516:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.next=function(){var E=I.x^I.x>>>2;return I.x=I.y,I.y=I.z,I.z=I.w,I.w=I.v,(I.d=I.d+362437|0)+(I.v=I.v^I.v<<4^E^E<<1)|0},I.x=0,I.y=0,I.z=0,I.w=0,I.v=0,P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),$==k.length&&(I.d=I.x<<10^I.x>>>4),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I.v=P.v,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorwow=ie}(0,ce=B.nmd(ce))},390:(ce,_e,B)=>{var he;!function(at,X){var N,Qe=this,be=256,P="random",I=X.pow(be,6),k=X.pow(2,52),$=2*k,E=255;function z(fe,ae,Ye){var Re=[],ke=Dt(Mt((ae=1==ae?{entropy:!0}:ae||{}).entropy?[fe,_n(at)]:fe??function Dn(){try{var fe;return N&&(fe=N.randomBytes)?fe=fe(be):(fe=new Uint8Array(be),(Qe.crypto||Qe.msCrypto).getRandomValues(fe)),_n(fe)}catch{var ae=Qe.navigator,Ye=ae&&ae.plugins;return[+new Date,Qe,Ye,Qe.screen,_n(at)]}}(),3),Re),He=new H(Re),bt=function(){for(var dt=He.g(6),kt=I,pt=0;dt<k;)dt=(dt+pt)*be,kt*=be,pt=He.g(1);for(;dt>=$;)dt/=2,kt/=2,pt>>>=1;return(dt+pt)/kt};return bt.int32=function(){return 0|He.g(4)},bt.quick=function(){return He.g(4)/4294967296},bt.double=bt,Dt(_n(He.S),at),(ae.pass||Ye||function(dt,kt,pt,Rt){return Rt&&(Rt.S&&et(Rt,He),dt.state=function(){return et(He,{})}),pt?(X[P]=dt,kt):dt})(bt,ke,"global"in ae?ae.global:this==X,ae.state)}function H(fe){var ae,Ye=fe.length,Re=this,ke=0,He=Re.i=Re.j=0,bt=Re.S=[];for(Ye||(fe=[Ye++]);ke<be;)bt[ke]=ke++;for(ke=0;ke<be;ke++)bt[ke]=bt[He=E&He+fe[ke%Ye]+(ae=bt[ke])],bt[He]=ae;(Re.g=function(dt){for(var kt,pt=0,Rt=Re.i,mr=Re.j,$n=Re.S;dt--;)kt=$n[Rt=E&Rt+1],pt=pt*be+$n[E&($n[Rt]=$n[mr=E&mr+kt])+($n[mr]=kt)];return Re.i=Rt,Re.j=mr,pt})(be)}function et(fe,ae){return ae.i=fe.i,ae.j=fe.j,ae.S=fe.S.slice(),ae}function Mt(fe,ae){var ke,Ye=[],Re=typeof fe;if(ae&&"object"==Re)for(ke in fe)try{Ye.push(Mt(fe[ke],ae-1))}catch{}return Ye.length?Ye:"string"==Re?fe:fe+"\0"}function Dt(fe,ae){for(var Re,Ye=fe+"",ke=0;ke<Ye.length;)ae[E&ke]=E&(Re^=19*ae[E&ke])+Ye.charCodeAt(ke++);return _n(ae)}function _n(fe){return String.fromCharCode.apply(0,fe)}if(X["seed"+P]=z,Dt(X.random(),at),ce.exports){ce.exports=z;try{N=B(914)}catch{}}else void 0!==(he=function(){return z}.call(_e,B,_e,ce))&&(ce.exports=he)}([],Math)},349:(ce,_e,B)=>{var he=B(300),at=B(650),X=B(100),Qe=B(69),be=B(120),Ce=B(703),ie=B(97);ie.alea=he,ie.xor128=at,ie.xorwow=X,ie.xorshift7=Qe,ie.xor4096=be,ie.tychei=Ce,ce.exports=ie},300:function(ce,_e,B){var he;!function(at,X,Qe){function be(I){var k=this,$=function P(){var I=4022871197;return function($){$=$.toString();for(var E=0;E<$.length;E++){var N=.02519603282416938*(I+=$.charCodeAt(E));N-=I=N>>>0,I=(N*=I)>>>0,I+=4294967296*(N-=I)}return 2.3283064365386963e-10*(I>>>0)}}();k.next=function(){var E=2091639*k.s0+2.3283064365386963e-10*k.c;return k.s0=k.s1,k.s1=k.s2,k.s2=E-(k.c=0|E)},k.c=1,k.s0=$(" "),k.s1=$(" "),k.s2=$(" "),k.s0-=$(I),k.s0<0&&(k.s0+=1),k.s1-=$(I),k.s1<0&&(k.s1+=1),k.s2-=$(I),k.s2<0&&(k.s2+=1),$=null}function Ce(I,k){return k.c=I.c,k.s0=I.s0,k.s1=I.s1,k.s2=I.s2,k}function ie(I,k){var $=new be(I),E=k&&k.state,N=$.next;return N.int32=function(){return 4294967296*$.next()|0},N.double=function(){return N()+11102230246251565e-32*(2097152*N()|0)},N.quick=N,E&&("object"==typeof E&&Ce(E,$),N.state=function(){return Ce($,{})}),N}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.alea=ie}(0,ce=B.nmd(ce))},703:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.next=function(){var E=I.b,N=I.c,z=I.d,H=I.a;return E=E<<25^E>>>7^N,N=N-z|0,z=z<<24^z>>>8^H,H=H-E|0,I.b=E=E<<20^E>>>12^N,I.c=N=N-z|0,I.d=z<<16^N>>>16^H,I.a=H-E|0},I.a=0,I.b=0,I.c=-1640531527,I.d=1367130551,P===Math.floor(P)?(I.a=P/4294967296|0,I.b=0|P):k+=P;for(var $=0;$<k.length+20;$++)I.b^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.a=P.a,I.b=P.b,I.c=P.c,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.tychei=ie}(0,ce=B.nmd(ce))},650:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.x=0,I.y=0,I.z=0,I.w=0,I.next=function(){var E=I.x^I.x<<11;return I.x=I.y,I.y=I.z,I.z=I.w,I.w^=I.w>>>19^E^E>>>8},P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor128=ie}(0,ce=B.nmd(ce))},120:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this;I.next=function(){var z,H,$=I.w,E=I.X,N=I.i;return I.w=$=$+1640531527|0,H=E[N+34&127],z=E[N=N+1&127],H^=H<<13,z^=z<<17,H=E[N]=(H^=H>>>15)^(z^=z>>>12),I.i=N,H+($^$>>>16)|0},function k($,E){var N,z,H,et,Mt,Dt=[],Dn=128;for(E===(0|E)?(z=E,E=null):(E+="\0",z=0,Dn=Math.max(Dn,E.length)),H=0,et=-32;et<Dn;++et)E&&(z^=E.charCodeAt((et+32)%E.length)),0===et&&(Mt=z),z^=z<<10,z^=z>>>15,z^=z<<4,z^=z>>>13,et>=0&&(H=0==(N=Dt[127&et]^=z+(Mt=Mt+1640531527|0))?H+1:0);for(H>=128&&(Dt[127&(E&&E.length||0)]=-1),H=127,et=512;et>0;--et)z=Dt[H+34&127],N=Dt[H=H+1&127],z^=z<<13,N^=N<<17,Dt[H]=(z^=z>>>15)^(N^=N>>>12);$.w=Mt,$.X=Dt,$.i=H}(I,P)}function Ce(P,I){return I.i=P.i,I.w=P.w,I.X=P.X.slice(),I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&($.X&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor4096=ie}(0,ce=B.nmd(ce))},69:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this;I.next=function(){var N,z,$=I.x,E=I.i;return N=$[E],z=(N^=N>>>7)^N<<24,z^=(N=$[E+1&7])^N>>>10,z^=(N=$[E+3&7])^N>>>3,z^=(N=$[E+4&7])^N<<7,N=$[E+7&7],$[E]=z^=(N^=N<<13)^N<<9,I.i=E+1&7,z},function k($,E){var N,H=[];if(E===(0|E))H[0]=E;else for(E=""+E,N=0;N<E.length;++N)H[7&N]=H[7&N]<<15^E.charCodeAt(N)+H[N+1&7]<<13;for(;H.length<8;)H.push(0);for(N=0;N<8&&0===H[N];++N);for(8==N&&(H[7]=-1),$.x=H,$.i=0,N=256;N>0;--N)$.next()}(I,P)}function Ce(P,I){return I.x=P.x.slice(),I.i=P.i,I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&($.x&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorshift7=ie}(0,ce=B.nmd(ce))},100:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.next=function(){var E=I.x^I.x>>>2;return I.x=I.y,I.y=I.z,I.z=I.w,I.w=I.v,(I.d=I.d+362437|0)+(I.v=I.v^I.v<<4^E^E<<1)|0},I.x=0,I.y=0,I.z=0,I.w=0,I.v=0,P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),$==k.length&&(I.d=I.x<<10^I.x>>>4),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I.v=P.v,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorwow=ie}(0,ce=B.nmd(ce))},97:(ce,_e,B)=>{var he;!function(at,X){var N,Qe=this,be=256,P="random",I=X.pow(be,6),k=X.pow(2,52),$=2*k,E=255;function z(fe,ae,Ye){var Re=[],ke=Dt(Mt((ae=1==ae?{entropy:!0}:ae||{}).entropy?[fe,_n(at)]:fe??function Dn(){try{var fe;return N&&(fe=N.randomBytes)?fe=fe(be):(fe=new Uint8Array(be),(Qe.crypto||Qe.msCrypto).getRandomValues(fe)),_n(fe)}catch{var ae=Qe.navigator,Ye=ae&&ae.plugins;return[+new Date,Qe,Ye,Qe.screen,_n(at)]}}(),3),Re),He=new H(Re),bt=function(){for(var dt=He.g(6),kt=I,pt=0;dt<k;)dt=(dt+pt)*be,kt*=be,pt=He.g(1);for(;dt>=$;)dt/=2,kt/=2,pt>>>=1;return(dt+pt)/kt};return bt.int32=function(){return 0|He.g(4)},bt.quick=function(){return He.g(4)/4294967296},bt.double=bt,Dt(_n(He.S),at),(ae.pass||Ye||function(dt,kt,pt,Rt){return Rt&&(Rt.S&&et(Rt,He),dt.state=function(){return et(He,{})}),pt?(X[P]=dt,kt):dt})(bt,ke,"global"in ae?ae.global:this==X,ae.state)}function H(fe){var ae,Ye=fe.length,Re=this,ke=0,He=Re.i=Re.j=0,bt=Re.S=[];for(Ye||(fe=[Ye++]);ke<be;)bt[ke]=ke++;for(ke=0;ke<be;ke++)bt[ke]=bt[He=E&He+fe[ke%Ye]+(ae=bt[ke])],bt[He]=ae;(Re.g=function(dt){for(var kt,pt=0,Rt=Re.i,mr=Re.j,$n=Re.S;dt--;)kt=$n[Rt=E&Rt+1],pt=pt*be+$n[E&($n[Rt]=$n[mr=E&mr+kt])+($n[mr]=kt)];return Re.i=Rt,Re.j=mr,pt})(be)}function et(fe,ae){return ae.i=fe.i,ae.j=fe.j,ae.S=fe.S.slice(),ae}function Mt(fe,ae){var ke,Ye=[],Re=typeof fe;if(ae&&"object"==Re)for(ke in fe)try{Ye.push(Mt(fe[ke],ae-1))}catch{}return Ye.length?Ye:"string"==Re?fe:fe+"\0"}function Dt(fe,ae){for(var Re,Ye=fe+"",ke=0;ke<Ye.length;)ae[E&ke]=E&(Re^=19*ae[E&ke])+Ye.charCodeAt(ke++);return _n(ae)}function _n(fe){return String.fromCharCode.apply(0,fe)}if(X["seed"+P]=z,Dt(X.random(),at),ce.exports){ce.exports=z;try{N=B(778)}catch{}}else void 0!==(he=function(){return z}.call(_e,B,_e,ce))&&(ce.exports=he)}([],Math)},340:(ce,_e,B)=>{var he=B(235),at=B(992),X=B(657),Qe=B(583),be=B(929),Ce=B(83),ie=B(818);ie.alea=he,ie.xor128=at,ie.xorwow=X,ie.xorshift7=Qe,ie.xor4096=be,ie.tychei=Ce,ce.exports=ie},235:function(ce,_e,B){var he;!function(at,X,Qe){function be(I){var k=this,$=function P(){var I=4022871197;return function($){$=$.toString();for(var E=0;E<$.length;E++){var N=.02519603282416938*(I+=$.charCodeAt(E));N-=I=N>>>0,I=(N*=I)>>>0,I+=4294967296*(N-=I)}return 2.3283064365386963e-10*(I>>>0)}}();k.next=function(){var E=2091639*k.s0+2.3283064365386963e-10*k.c;return k.s0=k.s1,k.s1=k.s2,k.s2=E-(k.c=0|E)},k.c=1,k.s0=$(" "),k.s1=$(" "),k.s2=$(" "),k.s0-=$(I),k.s0<0&&(k.s0+=1),k.s1-=$(I),k.s1<0&&(k.s1+=1),k.s2-=$(I),k.s2<0&&(k.s2+=1),$=null}function Ce(I,k){return k.c=I.c,k.s0=I.s0,k.s1=I.s1,k.s2=I.s2,k}function ie(I,k){var $=new be(I),E=k&&k.state,N=$.next;return N.int32=function(){return 4294967296*$.next()|0},N.double=function(){return N()+11102230246251565e-32*(2097152*N()|0)},N.quick=N,E&&("object"==typeof E&&Ce(E,$),N.state=function(){return Ce($,{})}),N}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.alea=ie}(0,ce=B.nmd(ce))},83:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.next=function(){var E=I.b,N=I.c,z=I.d,H=I.a;return E=E<<25^E>>>7^N,N=N-z|0,z=z<<24^z>>>8^H,H=H-E|0,I.b=E=E<<20^E>>>12^N,I.c=N=N-z|0,I.d=z<<16^N>>>16^H,I.a=H-E|0},I.a=0,I.b=0,I.c=-1640531527,I.d=1367130551,P===Math.floor(P)?(I.a=P/4294967296|0,I.b=0|P):k+=P;for(var $=0;$<k.length+20;$++)I.b^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.a=P.a,I.b=P.b,I.c=P.c,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.tychei=ie}(0,ce=B.nmd(ce))},992:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.x=0,I.y=0,I.z=0,I.w=0,I.next=function(){var E=I.x^I.x<<11;return I.x=I.y,I.y=I.z,I.z=I.w,I.w^=I.w>>>19^E^E>>>8},P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor128=ie}(0,ce=B.nmd(ce))},929:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this;I.next=function(){var z,H,$=I.w,E=I.X,N=I.i;return I.w=$=$+1640531527|0,H=E[N+34&127],z=E[N=N+1&127],H^=H<<13,z^=z<<17,H=E[N]=(H^=H>>>15)^(z^=z>>>12),I.i=N,H+($^$>>>16)|0},function k($,E){var N,z,H,et,Mt,Dt=[],Dn=128;for(E===(0|E)?(z=E,E=null):(E+="\0",z=0,Dn=Math.max(Dn,E.length)),H=0,et=-32;et<Dn;++et)E&&(z^=E.charCodeAt((et+32)%E.length)),0===et&&(Mt=z),z^=z<<10,z^=z>>>15,z^=z<<4,z^=z>>>13,et>=0&&(H=0==(N=Dt[127&et]^=z+(Mt=Mt+1640531527|0))?H+1:0);for(H>=128&&(Dt[127&(E&&E.length||0)]=-1),H=127,et=512;et>0;--et)z=Dt[H+34&127],N=Dt[H=H+1&127],z^=z<<13,N^=N<<17,Dt[H]=(z^=z>>>15)^(N^=N>>>12);$.w=Mt,$.X=Dt,$.i=H}(I,P)}function Ce(P,I){return I.i=P.i,I.w=P.w,I.X=P.X.slice(),I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&($.X&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor4096=ie}(0,ce=B.nmd(ce))},583:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this;I.next=function(){var N,z,$=I.x,E=I.i;return N=$[E],z=(N^=N>>>7)^N<<24,z^=(N=$[E+1&7])^N>>>10,z^=(N=$[E+3&7])^N>>>3,z^=(N=$[E+4&7])^N<<7,N=$[E+7&7],$[E]=z^=(N^=N<<13)^N<<9,I.i=E+1&7,z},function k($,E){var N,H=[];if(E===(0|E))H[0]=E;else for(E=""+E,N=0;N<E.length;++N)H[7&N]=H[7&N]<<15^E.charCodeAt(N)+H[N+1&7]<<13;for(;H.length<8;)H.push(0);for(N=0;N<8&&0===H[N];++N);for(8==N&&(H[7]=-1),$.x=H,$.i=0,N=256;N>0;--N)$.next()}(I,P)}function Ce(P,I){return I.x=P.x.slice(),I.i=P.i,I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&($.x&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorshift7=ie}(0,ce=B.nmd(ce))},657:function(ce,_e,B){var he;!function(at,X,Qe){function be(P){var I=this,k="";I.next=function(){var E=I.x^I.x>>>2;return I.x=I.y,I.y=I.z,I.z=I.w,I.w=I.v,(I.d=I.d+362437|0)+(I.v=I.v^I.v<<4^E^E<<1)|0},I.x=0,I.y=0,I.z=0,I.w=0,I.v=0,P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),$==k.length&&(I.d=I.x<<10^I.x>>>4),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I.v=P.v,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var H=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===H);return H},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorwow=ie}(0,ce=B.nmd(ce))},818:(ce,_e,B)=>{var he;!function(at,X){var N,Qe=(0,eval)("this"),be=256,P="random",I=X.pow(be,6),k=X.pow(2,52),$=2*k,E=255;function z(fe,ae,Ye){var Re=[],ke=Dt(Mt((ae=1==ae?{entropy:!0}:ae||{}).entropy?[fe,_n(at)]:fe??function Dn(){try{var fe;return N&&(fe=N.randomBytes)?fe=fe(be):(fe=new Uint8Array(be),(Qe.crypto||Qe.msCrypto).getRandomValues(fe)),_n(fe)}catch{var ae=Qe.navigator,Ye=ae&&ae.plugins;return[+new Date,Qe,Ye,Qe.screen,_n(at)]}}(),3),Re),He=new H(Re),bt=function(){for(var dt=He.g(6),kt=I,pt=0;dt<k;)dt=(dt+pt)*be,kt*=be,pt=He.g(1);for(;dt>=$;)dt/=2,kt/=2,pt>>>=1;return(dt+pt)/kt};return bt.int32=function(){return 0|He.g(4)},bt.quick=function(){return He.g(4)/4294967296},bt.double=bt,Dt(_n(He.S),at),(ae.pass||Ye||function(dt,kt,pt,Rt){return Rt&&(Rt.S&&et(Rt,He),dt.state=function(){return et(He,{})}),pt?(X[P]=dt,kt):dt})(bt,ke,"global"in ae?ae.global:this==X,ae.state)}function H(fe){var ae,Ye=fe.length,Re=this,ke=0,He=Re.i=Re.j=0,bt=Re.S=[];for(Ye||(fe=[Ye++]);ke<be;)bt[ke]=ke++;for(ke=0;ke<be;ke++)bt[ke]=bt[He=E&He+fe[ke%Ye]+(ae=bt[ke])],bt[He]=ae;(Re.g=function(dt){for(var kt,pt=0,Rt=Re.i,mr=Re.j,$n=Re.S;dt--;)kt=$n[Rt=E&Rt+1],pt=pt*be+$n[E&($n[Rt]=$n[mr=E&mr+kt])+($n[mr]=kt)];return Re.i=Rt,Re.j=mr,pt})(be)}function et(fe,ae){return ae.i=fe.i,ae.j=fe.j,ae.S=fe.S.slice(),ae}function Mt(fe,ae){var ke,Ye=[],Re=typeof fe;if(ae&&"object"==Re)for(ke in fe)try{Ye.push(Mt(fe[ke],ae-1))}catch{}return Ye.length?Ye:"string"==Re?fe:fe+"\0"}function Dt(fe,ae){for(var Re,Ye=fe+"",ke=0;ke<Ye.length;)ae[E&ke]=E&(Re^=19*ae[E&ke])+Ye.charCodeAt(ke++);return _n(ae)}function _n(fe){return String.fromCharCode.apply(0,fe)}if(X["seed"+P]=z,Dt(X.random(),at),ce.exports){ce.exports=z;try{N=B(42)}catch{}}else void 0!==(he=function(){return z}.call(_e,B,_e,ce))&&(ce.exports=he)}([],Math)},914:()=>{},410:()=>{},628:()=>{},778:()=>{},601:()=>{},792:()=>{},42:()=>{}},ce=>{ce(ce.s=471)}]);